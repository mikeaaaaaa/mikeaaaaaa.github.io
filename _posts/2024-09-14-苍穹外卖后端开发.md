---

title: 苍穹外卖后端开发
date: 2024-09-14 11:00:00 +0800
categories: [Springboot]
tags: [SpringBoot]

---
# 苍穹外卖

## 给定代码分析

主要分为三个子模块，分别为：

1. sky-common：一些常量类、异常类、属性类、结果封装类(Result)、一些工具类（对已有工具包的一个封装）
2. sky-pojo：DTO（Data Trains object 接收数据类）、VO（Vies Object）、entity（实体类，与数据库的表对应）
3. sky-server：主要就是和`MVC`相关的包

### 主模块sky-take-out

### sky-common

![image-20240914161819092](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240914161819092.png)

### sky-pojo

![image-20240914161905406](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240914161905406.png)

### sky-server

![image-20240914161920703](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240914161920703.png)

## 后继开发

### 用户登录

#### 登录流程

1 用户提交登录信息：

- 用户通过前端页面提交用户名和密码，通常通过 HTTPS 安全协议传输，防止明文密码在网络中被窃取。（一般认为http传输自已保证数据传输的安全！！！）

2 服务器端验证流程：

- 服务器接收到用户名和密码后，从数据库中获取与该用户名对应的加盐值和哈希值。
- 服务器使用相同的加密算法，将用户输入的密码与存储在数据库中的哈希值进行对比。如果匹配，则表示验证通过。

#### 依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
    <version>3.3.0</version>
</dependency>

<!-- BCrypt password encoder -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
    <version>6.3.3</version>
</dependency>
```

#### BCrypt 加密和加盐机制

`BCryptPasswordEncoder` 自动生成盐值，并在加密过程中使用这个盐值。**生成的哈希值中已经包含了盐值**，因此不需要单独存储盐；

````txt
$2a$10$E9jfYV3LszqwIkwCndY7uOh0B97OLfj1sJfULkw5N5/VOaDOzYxDq
````

**$2a$**：表示使用的 BCrypt 算法版本。

**10**：表示加密强度（成本因子，越高加密强度越大）。

**后面的字符串**：是盐值和哈希值的组合。

用户注册代码：

```java
@Service
public class UserService {

    private final UserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = new BCryptPasswordEncoder();
    }

    public void registerUser(String username, String rawPassword) {
        // 使用 BCrypt 进行密码加密
        String encryptedPassword = passwordEncoder.encode(rawPassword);

        // 创建用户并保存到数据库
        User user = new User(username, encryptedPassword);
        userRepository.save(user);
    }
}
```

用户登录验证代码：

```java
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class AuthenticationService {
	
    @AutoWired
    private final UserRepository userRepository;
    @AutoWired
    private final BCryptPasswordEncoder passwordEncoder;

    public AuthenticationService(UserRepository userRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = new BCryptPasswordEncoder();
    }

    public boolean login(String username, String rawPassword) {
        // 根据用户名查找用户
        User user = userRepository.findByUsername(username);
        if (user == null) {
            return false; // 用户不存在
        }

        // 验证密码是否匹配
        return passwordEncoder.matches(rawPassword, user.getPassword());
    }
}
```

安全配置类：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(); // 使用 BCrypt 加密
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()  // 关闭 CSRF（仅作示例，实际应根据需要配置）
            .authorizeRequests()
            .antMatchers("/login", "/register").permitAll() // 允许访问登录和注册页面
            .anyRequest().authenticated()  // 其他页面需认证
            .and()
            .formLogin().permitAll();  // 启用默认的表单登录页面
        return http.build();
    }
}
```

### 令牌机制（JWT）

JWT（Json Web Token）是目前最主流的无状态认证机制，当你最开始登录成功后，服务端会给客户端返回一个JWT（包含加密后的用户信息和国企时间），之后的每次请求前端都需要将JWT放置到请求头当中，服务器通过请求头中的JWT来鉴别用户身份；

我们整合登录过程，我们将整个流程具体化：

![前后端身份验证_前端后台模板身份验证-CSDN博客](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2a16584aaf86f24840c3c50370d3665b.png)

其实这里大部分都是说的后端服务器干的事情，那么前端vue服务器都需要做些什么呢？

1. 登录成功后，将后端服务器返回的token信息存储到浏览器![image-20240916173834306](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240916173834306.png)

2. 定义request.js （1）统一处理发送的请求：为其加上token（2）统一处理响应：若为验证未成功，则让用户到登录页面重新登陆

    ```java
    import axios from 'axios'
    import router from "@/router";
    
    const request = axios.create({
        baseURL: 'http://localhost:8081',  // 注意！！ 这里是全局统一加上了 '/api' 前缀，也就是说所有接口都会加上'/api'前缀在，页面里面写接口的时候就不要加 '/api'了，否则会出现2个'/api'，类似 '/api/api/user'这样的报错，切记！！！
        timeout: 5000
    })
    
    // request 拦截器
    // 可以自请求发送前对请求做一些处理
    // 比如统一加token，对请求参数统一加密
    request.interceptors.request.use(config => {
        config.headers['Content-Type'] = 'application/json;charset=utf-8';
        //从前端拿到user对象 登陆时进行了存储
        let user = localStorage.getItem("user") ? JSON.parse(localStorage.getItem("user")) : null
        if (user) {
            config.headers['token'] = user.token;  // 设置请求头
        }
        return config
    }, error => {
        return Promise.reject(error)
    });
    
    // response 拦截器
    // 可以在接口响应后统一处理结果
    request.interceptors.response.use(
        response => {
            let res = response.data;
            // 如果是返回的文件
            if (response.config.responseType === 'blob') {
                return res
            }
            // 兼容服务端返回的字符串数据
            if (typeof res === 'string') {
                res = res ? JSON.parse(res) : res
            }
    
            // 当权限验证不通过的时候给出提示
            if(res.code === '401'){
                router.push("/login")
            }
    
            return res;
        },
        error => {
            console.log('err' + error) // for debug
            return Promise.reject(error)
        }
    )
    
    
    export default request
    ```

    



已知Token是存储在客户端本地的，那么已知常用的存储方法有四种，分别是：

cookie、local storage、session storage、session

下面我们对其进行对比分析

| 特性             | Cookie                                       | Local Storage                          | Session Storage                    | Session                            |
| ---------------- | -------------------------------------------- | -------------------------------------- | ---------------------------------- | ---------------------------------- |
| 数据存储位置     | 客户端（浏览器）                             | 客户端（浏览器）                       | 客户端（浏览器）                   | 服务器                             |
| 数据容量限制     | 约 4KB                                       | 约 5-10MB                              | 约 5-10MB                          | 无明确限制                         |
| 生命周期         | 可以设置过期时间，默认在浏览器关闭后仍可保留 | 除非手动删除，否则**永久保留**         | 会话结束（关闭页面或浏览器）时删除 | 在会话结束或超时后失效             |
| 跨页面访问       | 可以**跨多个页面共享**                       | 可以**跨多个页面共享**                 | **仅限于同一页面会话**             | 可以在服务器端**跨多个页面共享**   |
| 是否发送到服务器 | 每次 HTTP 请求都会自动发送到服务器           | 不会自动发送                           | 不会自动发送                       | 服务器端管理，不需要通过网络传输   |
| 安全性           | 不安全，可能会被劫持或伪造                   | 相对安全，不会随请求发送               | 相对安全，不会随请求发送           | 服务器端控制，更安全               |
| 用途             | 主要用于保存用户会话、偏好设置等             | 用于持久化数据（用户偏好、本地缓存等） | 用于短期数据存储（如表单数据）     | 用于存储服务器端的会话信息         |
| 访问方式         | `document.cookie`                            | `localStorage`                         | `sessionStorage`                   | 通过后端语言（如 Java、PHP）等访问 |
| 与服务器的关系   | 客户端与服务器间传递数据                     | 仅客户端使用，不与服务器交互           | 仅客户端使用，不与服务器交互       | 仅服务器端维护，客户端无法直接访问 |
| 示例             | 登录状态、跟踪用户行为                       | 持久化登录状态、主题颜色等             | 临时保存用户输入                   | 用户登录会话管理                   |

上述表格的补充：上述四种存储方式都支持 key-value形式存储数据；已知cookie会每次随着request的发送附加到请求同当中，因此cookie不宜过大， 不然会浪费带宽，因此需要本地存储 localStrorage与session Storage两个配合，并且localStorage可永久存储，而Session Storage页面关闭就没了（不支持跨标签页）。

依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
    <version>3.3.0</version>
</dependency>

<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.12.6</version>
</dependency>

```



创建`JWT`工具类：

当然以下有几点还是需要改进的，"your_secret_key"应该从`application.yml`文件当中读取，为此，我们可以设置一个 `JWTProperties`类，用来自动读取一些属性创建`JWT`工具类；

```java
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;

public class JwtUtil {

    private static final String SECRET_KEY = "your_secret_key";

    // 生成 JWT 令牌
    public static String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) // 有效期 10 小时
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    // 解析 JWT 令牌
    public static Claims extractClaims(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody();
    }

    // 验证令牌是否过期
    public static boolean isTokenExpired(String token) {
        return extractClaims(token).getExpiration().before(new Date());
    }

    // 提取用户名
    public static String extractUsername(String token) {
        return extractClaims(token).getSubject();
    }
}
```



创建用户认证过滤器：

```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        String authorizationHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        // 检查 Authorization 头是否包含 Bearer 字段
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            username = jwtUtil.extractUsername(jwt);
        }

        // 如果用户名不为空且用户未认证
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

            // 验证 JWT 是否有效
            if (jwtUtil.isTokenExpired(jwt) == false) {
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }

        chain.doFilter(request, response);
    }
}
```

UserDetailsService类：

`UserDetailsService` 是 Spring Security 提供的一个接口，用于通过用户的用户名加载用户的详细信息（如用户名、密码、权限等）。它的主要目的是提供一种方式，让开发者可以通过自定义的方式加载用户数据，并将这些数据用于认证和授权。	在用户登录时，Spring Security 会调用 `UserDetailsService` 的实现类，获取用户的信息，并与传入的凭据（如用户名和密码）进行比较，从而判断用户是否有权限访问系统。







安全配置类

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationManagerResolver;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter; // 自定义 JWT 过滤器

    @Autowired
    private UserDetailsService userDetailsService; // 自定义 UserDetailsService

    // 配置密码加密器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // 配置 AuthenticationManager，进行身份验证
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception {
        return http.getSharedObject(AuthenticationManagerBuilder.class)
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder())
                .and()
                .build();
    }

    // 配置 SecurityFilterChain，用于 HTTP 安全配置
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()  // 禁用 CSRF
            .authorizeRequests()
            .antMatchers("/login", "/register").permitAll() // 公开的 API
            .anyRequest().authenticated()  // 其他请求需要认证
            .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);  // 无状态的会话

        // 添加自定义的 JWT 认证过滤器
        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}

```

登录接口handler

```java
@RestController
public class AuthController {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserDetailsService userDetailsService;

    @PostMapping("/login")
    public String login(@RequestBody AuthRequest authRequest) throws Exception {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(authRequest.getUsername(), authRequest.getPassword()));
        } catch (AuthenticationException e) {
            throw new Exception("Invalid username or password");
        }

        UserDetails userDetails = userDetailsService.loadUserByUsername(authRequest.getUsername());
        return jwtUtil.generateToken(userDetails.getUsername());
    }
}
```



### 时间配置

#### 基本使用

java8之前的时间相关操作大多使用Date类或者Calendar类，比如：

```java
Date date = new Date();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
sout(df.format(date))
```

在Java8之后新增的LocalDate、LocalTime、LocalDateTime和Zoned，我们可以更加方便的处理日期时间；

| 日期实践类    | 说明             |
| ------------- | ---------------- |
| LocalDate     | 只包含年月日     |
| LocalTime     | 只包含时分秒     |
| LocalDateTime | 包含年月日时分秒 |

如何获取具体值：

```java
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDateTime);//2021-04-06T09:51:11.987  获取当前的年月日时分秒
        System.out.println(localDateTime.getYear());//2021 获取当前年份
        System.out.println(localDateTime.getMonth().getValue());//4 获取当前月
        System.out.println(localDateTime.getDayOfMonth());//6 获取当前日
        System.out.println(localDateTime.getHour());//9 获取当前时
        System.out.println(localDateTime.getMinute());//51 获取当前分
        System.out.println(localDateTime.getSecond());//11 获取当前秒
        System.out.println(localDateTime.getDayOfYear());//96 今天是今年的第几天
        System.out.println(localDateTime.getDayOfWeek().getValue());//2 今天是星期几

```

日期格式化（字符串化）：

```java
LocalDateTime localDateTime = LocalDateTime.now();
DataTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss");
sout(localDateTime.format(formatter));
```

当然，如果我们使用默认的日期格式化，可以更快：

```java
LocalDateTime localDateTime = LocalDateTime.now();
sout(localDateTime.toString());//2021-04-06T11:33:59.617
```

反格式化：

```java
String dateTimeStr = "2024-09-14 10:30:45";
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss");
LocalDateTime dateTime = LocalDateTime.parse(dateTimeStr, formatter);
```

当然，如果我们使用默认的日期格式化，可以更快：

```java
String dateTimeStr = "2024-09-14T10:30:45";
LocalDateTime dateTime = LocalDateTime.parse(dateTimeStr);
System.out.println(dateTime);
```



#### Java格式化：

```java
import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class Event {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime eventTime;

    // Getters and setters
}
```

这样此Java格式化为Json字符串时，就会按照指定格式；通过 `@JsonFormat` 注解可以控制时间格式的序列化和反序列化，确保传输到前端时是正确的格式

#### **重点**（使用消息转换器）：

像这样一条一调加注解太麻烦了，我们可以在 `WebMvcConfiguration`中扩展啊Spring MVC 的消息转换器，同意对日期类型进行格式化处理；消息转换器的作用就是同意对 后端返回给前端的数据做处理；我们在`webmvcconfig`类中重写一个方法即可：

```java
  @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 创建一个消息转换器对象
        MappingJackson2CborHttpMessageConverter converter = new MappingJackson2CborHttpMessageConverter();
        // 需要为消息转换器设置一个对象转换器，对象转换器是用来将对象转换为 JSON 格式的
        converter.setObjectMapper(new JacksonObjectMapper());
        // 将消息转换器添加到 Spring MVC 中，通常需要
        converters.add(0，converter);

    }
```

自己写的数据转换器如下：

```java
/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    //public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}

```



#### 数据库映射：

+ 在数据库中，通常使用 `DATETIME` 或 `TIMESTAMP` 字段类型存储日期时间信息。
+ `LocalDateTime` 可以很好地映射到这两种类型，无需额外的转换。





### 测试

有时候测试，不能仅仅依靠前后端联调，实际开发中前后端可能开发进步不同；因此测试主要依靠 **接口文档测试**；

#### swagger

接口文档的生成就依靠 `swagger`：

Swagger 是一种用于设计、构建、记录和测试 **RESTful API** 的开源框架。通过使用 Swagger，你可以为你的 API 自动生成可交互的文档，从而简化 API 开发、调试、和维护。Swagger 的核心是通过注解、配置文件等方式描述 API 的行为，生成可视化和可交互的文档供开发者使用。

#### Knife4j

我们开发所选择使用的就是： `Knife4j-Spring-Boot—Starter`

**Knife4j** 是 Swagger 的增强版，提供了更多功能、更友好的 UI 界面和文档显示方式。它解决了 `springfox-swagger` 一些局限性，尤其在中文用户群中很受欢迎。`knife4j-spring-boot-starter` 是为 Spring Boot 提供的快速集成 Knife4j 的启动器，简化了集成过程。

使用：

```java
@Bean
    public Docket docket() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }
```



我们有四种常用的注解，用于进一步丰富文档信息：

+ @Api(tags= "员工管理")：一般是用在Controller类上
+ @ApiOperation("员工登录")：一般使用在Controller类的handler方法上
+ @ApiModel(description="员工登录返回数据格式")
+ @ApiModelProperty("用户名")

访问：localhost:8080/doc.html

一般是对静态资源有拦截的，我们无法访问到此doc'文档，因此我们还需要在webmvc配置中进行静态资源访问控制：

```java
/**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 表示当用户访问localhost:port/doc.html时，Springboot会根据addResourceLocations指定的路径返回文件
        registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
        // 这种配置允许通过 /webjars/ URL 前缀访问项目中的第三方静态资源文件，例如 JavaScript 库或样式文件。Spring Boot 项目中常使用 WebJars 来管理依赖的静态文件
         /* /META-INF/resources文件夹在普通的 Spring Boot 项目开发目录中默认是不存在的，
         因为这个目录是用于JAR 文件内部的资源存放，而不是用于项目源代码的开发目录，静态访问最后因该是访问jar包中到了一些静态资源，所以要以打包后的位置为准！！！*/
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
    }
```



### ThreadLocal

根据之前学习的JWT知识，我们通过解析JWT我们是能够解析出用户ID的，但是我们将解析过程制作成了 `Interceptor`，我们无法在Service中获取到用户ID。

还有我们需要知道，客户端每一个发送的请求都对应着一个线程 `Thread`，我们在 Interceptor、handler、service中打印 `Thread.currentThrad.getId()`，会得到相同的结果。

ThreadLocal为每个线程提供一个单独的存储空间，具有线程隔离的效果，因此我们可以在线程空间中存储用户ID，为此我们创建了一个 `BaseContext`的方法类：

```java
package com.sky.context;

public class BaseContext {

    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }

}
```

通过上述代码我们可以猜到，ThreadLoca只能存储一个数值，但是好在其允许存储任意一个对象，当数值较多的时候，我们可以将各个数值封装到一个对象当中即可。

### 分页查询

1. 根据页码展示员工信息
2. 每页展示10条数据
3. 分页查询时，可根据员工姓名进一步筛选
4. 每条信息都支持 修改、禁用、删除操作

插播一条小知识：![image-20240916191019718](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240916191019718.png),这个按钮其实非常好用，可以快速在当前文件的位置！！！



对于翻页查询，本质上是基于 底层mysql的分页查询：

```mysql
select * from employee limit 0,10 // 表示从第0条开始，查询10条
```

我们要做的就是将这两个数值计算出来填一下就好了，但是需要我们自己计算的话，就太麻烦了，我们有专门的插件来完成：

`mybatis`提供了一个非常好的插件 page-helper，依赖如下：

```xml
<!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.4.5</version>
</dependency>
```

插件的原理就是mybatis底层的拦截器，之后进行mysql语句的拼接，哈哈看了看源码就会发现 他也是通过ThreadLocal将页码与每页记录数传递给mysql拦截器！！

之后代码层面就非常简单了：

```java
public PageResult<Employee> pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {
        // 开始分页查询，首先设置页码和每页的记录数
        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
        // 查询员工列表
        Page<Employee> employeePage = employeeMapper.pageQuery(employeePageQueryDTO);
        // 封装分页结果
        PageResult<Employee> pageResult = new PageResult<>();
        pageResult.setTotal(employeePage.getTotal());
        pageResult.setRecords(employeePage.getResult());
        return pageResult;
    }
```

还有，为了实现模糊查询，我们首先了解一下sql的模糊查询：

like关键字：搭配常见的以下通配符：

+ 百分号%：表示0或多个字符（最常用
+ 下划线_：表示单个字符
+ 方括号[]：表示字符集中任意一个字符
+ 排除字符集[^]：表示排除字符集中任意一个数值

举例如下：

```mysql
select * from employee where name like '%hao[12]'
```





此外还需要使用一项技术，那就是动态sql语句：

如下：

```xml
<mapper namespace="com.sky.mapper.EmployeeMapper">

    <select id="pageQuery" resultType="Employee">
        select * from employee
        <where>
            <if test="name != null and name != ''">
                and name like concat('%', #{name}, '%')
            </if>
        </where>
        order by create_time desc
    </select>
</mapper>
```

有几项需要注意的点：

1. 前面说了，Page是ListArray的子类，所以ResultType只需要写泛型类就行
2. 使用了pagehelper就不需要再使用limit进行sql语句拼接
3. 想要实现mapper类与xml文件快速跳转，只需要下载一个idea插件 `mubatisx`即可

最后，我们可以通过设置mapper接口文件的日志输出设置为debug，我们就能看到pagehelper为我们设置好的 sql 语句输出！！！



### 各种坑

1. 大驼峰映射在动态sql语句编写的时候作用到底是什么

    回答：在 SQL 查询结果返回时，`user_id` 字段会自动映射到 `userId` 属性，`user_name` 字段会自动映射到 `userName` 属性，无需额外配置，只有这么一个作用，就是我们可以不再写 **别名**了！！！

2. 为什么

    ```
    <if test="status != null">
        status = #{status},
    </if>
    ```

可以但是

```
<if test="status != null and status!=''">
    status = #{status},
</if>
```

不行！！！，这个很正常，因为status是基本数据类型，不能和空字符串做比较，会报错的！！！

3. 关于@RequestBody的使用，我们只需要在post请求时使用这个注解，当使用的是get请求时，我们写了这个注解反而会报错，只需要什么都不屑就能够实现对象的映射；
4. 

