---

title: 苍穹外卖后端开发
date: 2024-09-14 11:00:00 +0800
categories: [Springboot]
tags: [SpringBoot]

---
# 苍穹外卖

## 给定代码分析

主要分为三个子模块，分别为：

1. sky-common：一些常量类、异常类、属性类、结果封装类(Result)、一些工具类（对已有工具包的一个封装）
2. sky-pojo：DTO（Data Trains object 接收数据类）、VO（Vies Object）、entity（实体类，与数据库的表对应）
3. sky-server：主要就是和`MVC`相关的包

### 主模块sky-take-out

### sky-common

![image-20240914161819092](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240914161819092.png)

### sky-pojo

![image-20240914161905406](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240914161905406.png)

### sky-server

![image-20240914161920703](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/image-20240914161920703.png)

## 后继开发

### 用户登录

#### 登录流程

1 用户提交登录信息：

- 用户通过前端页面提交用户名和密码，通常通过 HTTPS 安全协议传输，防止明文密码在网络中被窃取。（一般认为http传输自已保证数据传输的安全！！！）

2 服务器端验证流程：

- 服务器接收到用户名和密码后，从数据库中获取与该用户名对应的加盐值和哈希值。
- 服务器使用相同的加密算法，将用户输入的密码与存储在数据库中的哈希值进行对比。如果匹配，则表示验证通过。

#### 依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
    <version>3.3.0</version>
</dependency>

<!-- BCrypt password encoder -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
    <version>6.3.3</version>
</dependency>
```

#### BCrypt 加密和加盐机制

`BCryptPasswordEncoder` 自动生成盐值，并在加密过程中使用这个盐值。**生成的哈希值中已经包含了盐值**，因此不需要单独存储盐；

````txt
$2a$10$E9jfYV3LszqwIkwCndY7uOh0B97OLfj1sJfULkw5N5/VOaDOzYxDq
````

**$2a$**：表示使用的 BCrypt 算法版本。

**10**：表示加密强度（成本因子，越高加密强度越大）。

**后面的字符串**：是盐值和哈希值的组合。

用户注册代码：

```java
@Service
public class UserService {

    private final UserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = new BCryptPasswordEncoder();
    }

    public void registerUser(String username, String rawPassword) {
        // 使用 BCrypt 进行密码加密
        String encryptedPassword = passwordEncoder.encode(rawPassword);

        // 创建用户并保存到数据库
        User user = new User(username, encryptedPassword);
        userRepository.save(user);
    }
}
```

用户登录验证代码：

```java
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class AuthenticationService {
	
    @AutoWired
    private final UserRepository userRepository;
    @AutoWired
    private final BCryptPasswordEncoder passwordEncoder;

    public AuthenticationService(UserRepository userRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = new BCryptPasswordEncoder();
    }

    public boolean login(String username, String rawPassword) {
        // 根据用户名查找用户
        User user = userRepository.findByUsername(username);
        if (user == null) {
            return false; // 用户不存在
        }

        // 验证密码是否匹配
        return passwordEncoder.matches(rawPassword, user.getPassword());
    }
}
```

安全配置类：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(); // 使用 BCrypt 加密
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()  // 关闭 CSRF（仅作示例，实际应根据需要配置）
            .authorizeRequests()
            .antMatchers("/login", "/register").permitAll() // 允许访问登录和注册页面
            .anyRequest().authenticated()  // 其他页面需认证
            .and()
            .formLogin().permitAll();  // 启用默认的表单登录页面
        return http.build();
    }
}
```

### 令牌机制（JWT）

JWT（Json Web Token）是目前最主流的无状态认证机制，当你最开始登录成功后，服务端会给客户端返回一个JWT（包含加密后的用户信息和国企时间），之后的每次请求前端都需要将JWT放置到请求头当中，服务器通过请求头中的JWT来鉴别用户身份；

依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
    <version>3.3.0</version>
</dependency>

<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.12.6</version>
</dependency>

```



创建`JWT`工具类：

当然以下有几点还是需要改进的，"your_secret_key"应该从`application.yml`文件当中读取，为此，我们可以设置一个 `JWTProperties`类，用来自动读取一些属性创建`JWT`工具类；

```java
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;

public class JwtUtil {

    private static final String SECRET_KEY = "your_secret_key";

    // 生成 JWT 令牌
    public static String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) // 有效期 10 小时
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    // 解析 JWT 令牌
    public static Claims extractClaims(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody();
    }

    // 验证令牌是否过期
    public static boolean isTokenExpired(String token) {
        return extractClaims(token).getExpiration().before(new Date());
    }

    // 提取用户名
    public static String extractUsername(String token) {
        return extractClaims(token).getSubject();
    }
}
```



创建用户认证过滤器：

```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        String authorizationHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        // 检查 Authorization 头是否包含 Bearer 字段
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            username = jwtUtil.extractUsername(jwt);
        }

        // 如果用户名不为空且用户未认证
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

            // 验证 JWT 是否有效
            if (jwtUtil.isTokenExpired(jwt) == false) {
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }

        chain.doFilter(request, response);
    }
}
```

UserDetailsService类：

`UserDetailsService` 是 Spring Security 提供的一个接口，用于通过用户的用户名加载用户的详细信息（如用户名、密码、权限等）。它的主要目的是提供一种方式，让开发者可以通过自定义的方式加载用户数据，并将这些数据用于认证和授权。	在用户登录时，Spring Security 会调用 `UserDetailsService` 的实现类，获取用户的信息，并与传入的凭据（如用户名和密码）进行比较，从而判断用户是否有权限访问系统。







安全配置类

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationManagerResolver;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter; // 自定义 JWT 过滤器

    @Autowired
    private UserDetailsService userDetailsService; // 自定义 UserDetailsService

    // 配置密码加密器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // 配置 AuthenticationManager，进行身份验证
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception {
        return http.getSharedObject(AuthenticationManagerBuilder.class)
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder())
                .and()
                .build();
    }

    // 配置 SecurityFilterChain，用于 HTTP 安全配置
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()  // 禁用 CSRF
            .authorizeRequests()
            .antMatchers("/login", "/register").permitAll() // 公开的 API
            .anyRequest().authenticated()  // 其他请求需要认证
            .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);  // 无状态的会话

        // 添加自定义的 JWT 认证过滤器
        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}

```

登录接口handler

```java
@RestController
public class AuthController {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserDetailsService userDetailsService;

    @PostMapping("/login")
    public String login(@RequestBody AuthRequest authRequest) throws Exception {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(authRequest.getUsername(), authRequest.getPassword()));
        } catch (AuthenticationException e) {
            throw new Exception("Invalid username or password");
        }

        UserDetails userDetails = userDetailsService.loadUserByUsername(authRequest.getUsername());
        return jwtUtil.generateToken(userDetails.getUsername());
    }
}
```



### 数据库时间存储

java8之前的时间相关操作大多使用Date类或者Calendar类，比如：

```java
Date date = new Date();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
sout(df.format(date))
```

在Java8之后新增的LocalDate、LocalTime、LocalDateTime和Zoned，我们可以更加方便的处理日期时间；

| 日期实践类    | 说明             |
| ------------- | ---------------- |
| LocalDate     | 只包含年月日     |
| LocalTime     | 只包含时分秒     |
| LocalDateTime | 包含年月日时分秒 |

如何获取具体值：

```java
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDateTime);//2021-04-06T09:51:11.987  获取当前的年月日时分秒
        System.out.println(localDateTime.getYear());//2021 获取当前年份
        System.out.println(localDateTime.getMonth().getValue());//4 获取当前月
        System.out.println(localDateTime.getDayOfMonth());//6 获取当前日
        System.out.println(localDateTime.getHour());//9 获取当前时
        System.out.println(localDateTime.getMinute());//51 获取当前分
        System.out.println(localDateTime.getSecond());//11 获取当前秒
        System.out.println(localDateTime.getDayOfYear());//96 今天是今年的第几天
        System.out.println(localDateTime.getDayOfWeek().getValue());//2 今天是星期几

```

日期格式化（字符串化）：

```java
LocalDateTime localDateTime = LocalDateTime.now();
DataTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss");
sout(localDateTime.format(formatter));
```

当然，如果我们使用默认的日期格式化，可以更快：

```java
LocalDateTime localDateTime = LocalDateTime.now();
sout(localDateTime.toString());//2021-04-06T11:33:59.617
```

反格式化：

```java
String dateTimeStr = "2024-09-14 10:30:45";
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss");
LocalDateTime dateTime = LocalDateTime.parse(dateTimeStr, formatter);
```

当然，如果我们使用默认的日期格式化，可以更快：

```java
String dateTimeStr = "2024-09-14T10:30:45";
LocalDateTime dateTime = LocalDateTime.parse(dateTimeStr);
System.out.println(dateTime);
```



Java格式化：

```java
import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class Event {

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime eventTime;

    // Getters and setters
}
```

这样此Java格式化为Json字符串时，就会按照指定格式；通过 `@JsonFormat` 注解可以控制时间格式的序列化和反序列化，确保传输到前端时是正确的格式

数据库映射：

+ 在数据库中，通常使用 `DATETIME` 或 `TIMESTAMP` 字段类型存储日期时间信息。
+ `LocalDateTime` 可以很好地映射到这两种类型，无需额外的转换。

### 测试

有时候测试，不能仅仅依靠前后端联调，实际开发中前后端可能开发进步不同；因此测试主要依靠 **接口文档测试**；

#### swagger

接口文档的生成就依靠 `swagger`：

Swagger 是一种用于设计、构建、记录和测试 **RESTful API** 的开源框架。通过使用 Swagger，你可以为你的 API 自动生成可交互的文档，从而简化 API 开发、调试、和维护。Swagger 的核心是通过注解、配置文件等方式描述 API 的行为，生成可视化和可交互的文档供开发者使用。

#### Knife4j

我们开发所选择使用的就是： `Knife4j-Spring-Boot—Starter`

**Knife4j** 是 Swagger 的增强版，提供了更多功能、更友好的 UI 界面和文档显示方式。它解决了 `springfox-swagger` 一些局限性，尤其在中文用户群中很受欢迎。`knife4j-spring-boot-starter` 是为 Spring Boot 提供的快速集成 Knife4j 的启动器，简化了集成过程。

使用：

```java
@Bean
    public Docket docket() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }
```



我们有四种常用的注解，用于进一步丰富文档信息：

+ @Api(tags= "员工管理")：一般是用在Controller类上
+ @ApiOperation("员工登录")：一般使用在Controller类的handler方法上
+ @ApiModel(description="员工登录返回数据格式")
+ @ApiModelProperty("用户名")

访问：localhost:8080/doc.html

一般是对静态资源有拦截的，我们无法访问到此doc'文档，因此我们还需要在webmvc配置中进行静态资源访问控制：

```java
/**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 表示当用户访问localhost:port/doc.html时，Springboot会根据addResourceLocations指定的路径返回文件
        registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
        // 这种配置允许通过 /webjars/ URL 前缀访问项目中的第三方静态资源文件，例如 JavaScript 库或样式文件。Spring Boot 项目中常使用 WebJars 来管理依赖的静态文件
         /* /META-INF/resources文件夹在普通的 Spring Boot 项目开发目录中默认是不存在的，
         因为这个目录是用于JAR 文件内部的资源存放，而不是用于项目源代码的开发目录，静态访问最后因该是访问jar包中到了一些静态资源，所以要以打包后的位置为准！！！*/
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
    }
```



