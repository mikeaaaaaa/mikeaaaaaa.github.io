---

---

# Spring Boot 响应式编程

## 教程简介

首先我们来看一下 响应式编程与传统的阻塞式编程的区别：

![image-20241027150007992](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-54516e7bf9b022464b997c12984bc272.png)

从图中我们可以看到，SpringBoot对于两套技术栈都有相应的支持，阻塞式通常以`Tomcat`作为容器，而阻塞式通常使用`Netty`作为容器；

阻塞式天然更加支持 高并发、高吞吐量！！！



讲解方案图：

![image-20241027150406421](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-708e918b3d71c34651927bea98d4199b.png)

## 前置知识

### Lambda表达式

java8提出的语法糖：

**语法糖**：可以让我们不用写那么多冗余代码，提供便捷的功能；

我们看看传统的匿名实现类，非常冗余：

```java
MyInterface myInterface = new MyInterface(){
    @Override
    public int sum(int i,int j){
        return i*i + j*j;
    }
}
```

可以看到我们其实写了非常多的不必要代码，因为除了复写的函数体，其余其实都是固定写法的！！！！！，因此语法糖就出来了；

```java
MyInterface myInterface = (int i,int j)-> {
    return i*i + j*j;
};
```

上述还是完整写法，我们还可以进一步简化：

1、参数类型可以不写，参数名称可以随意定义

2、方法体只有一句话，{}可以不要 



注意：函数式接口值得是 **只有一个未实现方法的接口**，注意从Java8开始允许接口提供默认实现的方法，即`default`方法，如下这个接口依然是函数式接口

```java
public interface Myinterface{
    int add(int i,int j); // 未实现方法
    default int minus(int i,int j){ // 默认实现
        returtn i-j;
    }
}
```



但是当`defalt`默认实现方法太多了，导致我们不好判断怎么办？

答案是使用`jdk`提供的注解：`@FunctionalInterface`注解，可以帮我快速判断编写的接口是不是符合 `lambda`表达式规范。

还有更加进阶的使用方法：假如有一个类中的**实例方法或者静态方法**的参数以及返回值符合我们的预期，我们可以直接引用这个方法来代替`lambda`表达式，引用方法为 `Class：Method`：

```java
List<String> stringList = new ArrayList<String>(); // 比较器的用法
Collections.sort(names,String::compareTo);

// 开启线程的方法
new Thread(
	()->{
        
    }
);
```



Java提供了多个内置的函数式接口供我们实现，他们的区别是定义了多少个参数，有没有定义返回值，总共有四种类型，每种类型根据参数的数量又分为好多好多种：

![image-20241027173746803](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-3ec34458fef10bf90df8c6eada3b17fe.png)

![image-20241027174019827](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-8635f62c2267ddda402a3d3903afd5e6.png)

所有的Function定义都在：**Java.util.function**包中，其中 `Supply`、`Predicate`、 `Fuinction`  、`Consumer`**都是我们需要掌握的**；
这些个函数接口种类都是由特征方法的分别是：`get`、`test`、`apply`、`accept`

其中还有一个叫**断言**的函数式接口，用于判断一个东西是不是我们需要的：

![image-20241027174234718](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-ea609301dcd665397a87807977195ebb.png)

### Stream API

**最佳实战**：**以后凡是用到For循环的地方，统一使用Stream API**

流本质上就是一堆元素走流水线；

![image-20241027202712037](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-66e0933bd398ad2a6fbf86677ade50ac.png)

（1）流是懒加载的，虽然我们定义了一堆处理流的方法，但是并不会立即执行，流只会在我们真正要使用的时候才会执行：

因为filter在流中属于 中间操作，但是像 max、count这些就属于最终操作，最终操作会触发具体方法的执行；

```java
list.stream()
    .fiter(
	item -> sout(item); // 这里并不会立即打印,因为filter是中间操作；
);
```

![image-20241027203317449](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-bd64cb2ca09a76c9b3581cd434b60e25.png)

对于 max这个终止操作来说，调用会返回一个`Optional`对象，这个对象是Java8提供的防止空指针的一个东西；使用如下：![image-20241027203557324](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-cc3ac9eaa8ae34d2bad69d0ac1dd06fc.png)

下面主要讲解一些中间操作和终止操作：

1、`filter`

过滤，挑选出我们的元素

2、`map`

一一映射，可以转化成新类型的元素

3、`flatMap`

一对多映射，打散，散列，**需要将每一个元素转化成一个流**

4、`distinct`

去重

5、`sort`

排序，接收一个比较器

6、`peek`

接受一个`Consumer`，只接受不返回

7、`takeWhile`

**终止流**，相当于`break`，不满足直接结束流操作

8、`groupBy`

按照某个属性进行分组，最终可以返回一个Map对象

```java
Map<String,List<String>> map = list.stream().collect(Collectors.groupingBy(t -> t.gender));
```



其实从流操作开始，已经开始使用声明式编程（基于事件机制的回调），其实就是我们有没显示的进行调用，基于底层事件触发调用我们定义的方法；

## Reactive响应式编程

### Reactive Stream

首先我们得理解Tomcat传统的工作方式：

老的Tomcat：

Tomcat维护一个线程池，每来一个请求，分配一个线程专门用于处理该请求，该线程直到任务处理完毕之前都不能切换处理其他请求，这样假如一个Tomcat有100个线程，主机上一共有4个内核，那么就会导致一个内核上最多会有25个线程同时工作，虽然线程已经非常轻便了，但也难免会有切换开销，所以就要想办法能不能将这部分开销给降到最低！！！（所以**多线程并不是线程越多越好，最佳的应该是和内核数量相同，保证每个内核时刻高速工作**）

新版Tomcat：

他有一个专门`acceptor`线程用于接收请求并将其保存至缓冲区中（**缓存起来**），后面根据内核的数量分配`work`线程，每个线程不断从缓冲区中读取请求处理。我们也给每个线程分配缓冲区，当遇到阻塞（网络IO、文件IO这些IO操作底层都是操作系统在执行，不归我们管的，我们让操作系统做这些费时操作的时候，我们完全可以转头干其他事情，而不用死等。等到操作系统将数据都读取到线程缓冲区时，线程再继续处理），该线程就会从缓冲中再加载一个请求处理！！！保证每个内核时刻在工作； **通过全异步的方式，加缓冲区构建一个实时的数据流系统**

![image-20241028114910319](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-2040311da54c36e985d45e4df7b8d526.png)



老版本Tomcat：活越多大不了我招更多的员工

新版本Tomcat：活越多我越压榨员工，无限压榨资源利用率；

本质上这种方式和Kafka、MQ非常类似，Kafka时能构建出大型分布式响应式系统；本地化缺少一种能让所有的异步线程能相互监听消息，处理消息，构建实时消息处理流---->所以Java为我们提供了`Reactive-Stream`

这张图基本就讲清楚了响应式系统





从`Java9`开始，官方加入了 `java.util.concurrent` 包，底下有一个 `Flow`API，下面有几个接口非常重要！！！！

这个Flow中有很多的函数式接口，例如`Publisher`、`Subscribe`等

这里我们再回顾一下声明式编程（其实就是响应式编程）：数据是自流动的，我们感知不到数据的流动，并且有一个推拉模型（普通的迭代是拉，自己遍历，自己拉去，而推模型是：上游有数据则自动推给下游）

知道这些概念后，整个FlowAPI就不难理解了：

![](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-dcb16e66f8cb192161e044597de7f021.png)



发布者`Publisher`发布数据实际上就是往消息队列/缓冲区中存放数据，但是这个消息队列是依靠Java帮我们实现的，而不是依靠kafka啥的；

 ![image-20241028132831363](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-1f0d57d55f18f5571fe1a94b5a81a956.png)

 



