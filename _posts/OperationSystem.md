# 操作系统

## 操作系统概述

操作系统定义：





**every thing is state machine**：在计算机的世界里，任何东西都是状态机，对于 CPU 来说，其内部有寄存器，直接操作内存（有的甚至直接 cpu 内部集成内存），接收机器指令改变状态；对于汇编代码，我们可以使 gdb 对其实现清晰的观察，毫无疑问也是一个状态机；对于高级语言 C 来说，老师用了一个将汉诺塔非递归改写来举例说明其也是一个状态机；

从软件的角度来看，我们来分析一下 `geditor`，这是一个简单的文本编辑器，类似于记事本，他的背后其实就是一个可执行文件，那么他是怎么做到当在键盘中敲下一个键盘，在屏幕上就能显示出这个字符呢？实际上在我们系统上有一个专门的进程用于屏幕显示，对于 geditor 来说，其只要告诉这个屏幕显示的进程我要在什么位置显示什么字符就行了，这个 **告诉** 就得依靠 `系统调用`，另外没当我们按下一个键盘或者移动鼠标，操作系统通过设备驱动来感知到这些事件，之后会将这些事件传输给对应的应用程序（这个事件一般也是通过一个专门的进程管理的）；我们可以看到，此时的操作系统就是在硬件设备的基础上进行了一层抽象，就是 `系统调用`，为操作系统上的应用提供系统调用；

从硬件角度来说，操作系统的一切都是合理的，当我按下 reset 按键（或者开启）时，CPU 都会按照规定将状态机的状态按照手册回归初始，PC 指针会指向一个一个叫做 firmware（以前叫作 bios，后来为满足更加丰富的功能改为了 uefi）的系统，起作用有很多，比如进行硬件的检查、硬件的各种配置，本质是此时是直接和硬件对接的，最终作用为加载操作系统；那么操作系统在哪呢？操作系统在一个称之为 esp（efi system partition）分区，这个分区并不大，存储者“xxx.efi”的 **引导加载程序**，后续是由这个引导加载程序正式加载操作系统，我们在 linux 中可以看看目录结构：

![image-20241230222518851](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-12-aca2706317d8f8efb422dee0e5b52fb2.png)

我们可能会发现，为什么会有这么多的引导程序呢？实际上，`grubx64.efi` 是一个非常好用的管理启动系统的一个引导程序，它可以帮助我们选择从哪个操作系统启动；这个程序需要在 linux 系统中安装；

对于多核 CPU 来说，每一个核都有一个专门的 `寄存器集合`，这个非常关键，这就能够保证了不同的状态机可以在不同的核心上同时执行，这是不违背 everything is state Machine 这个理论的，而对于单核 cpu 来说，操作系统就是 **状态机的集合**，每一时间操作系统选择一个状态机来执行，是一个状态机的管理者，但是站在整个系统的层面上，可以看作一个大的 state machine；

这门课上给我的第一个启发：当你觉得某件事麻烦的时候，那么必定有办法解决这种麻烦，如果没有办法解决，那么恭喜你，你如果能将其变得简便就或许会成为一个大牛（这种概率非常小非常小，百分之九十九点九别人都解决过）；例如，当我们看见一个非常复杂的 makefile，我们看着 makefile 的语法结构以及非常多的变量定义，我们第一反应：哇！这也太复杂了！！！，还是不看了，或者是直接复制非常不负责的复制扔给 GPT（不是说这样依赖 gpt 不行，而是没有了自己的独立思考），此时我们不妨站在 everything is machine 的角度，就是执行一条命令从一个状态到了另一个状态，当我们有了这种思维后，我们就绝对确定操作系统能够感知到状态如何变化，我们再一提问发现除了使用 `strace` 命令查看系统调用外，还可以使用 `-nB` 选项来查看 make xxx 具体执行了什么指令，会一条一条罗列出来；这种思维我们需要熟练记忆！！！，其次，直接命令行的输出不好看，我们还可以使用 `| vim -`, 并且将所有的 空格替换为 “  \n”这样会更加增加我们的阅读体验！！！





>  tips: 在调试任何程序前都应该配置环境，例如我们在调试一个 python 程序前应该写一个 launch.json 文件，以便对调试器进行更加细致的自定义，举个例子，如果你有一个需要特定环境变量或者不同工作目录的程序，`launch.json` 让你不必每次手动设置这些参数，而是将它们集中在一个文件中，便于复用和管理。

![image-20241231000255244](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-12-44c24201bcc43b00d587804f89966528.png)

随后老师放出了大招：使用 `python` 写了一个操作系统玩具，一共有三个系统调用，分别是 read、write、spawn，然后里利用 python 提供的 `yield` 命令的特性，将系统调用修改成 `yield xxx`，这样当前执行的函数就会将执行权力交还给调用者，并且会保存当前状态机的状态，直到重新调用 `send` 函数才会继续执行；





从数学角度来看，我们的程序就是一个确定性的数学模型，当我们的代码写好之后，他后面的状态也就确定了，这句话在并发编程前说都是对的，”“程序仅仅有两个不确定性”1：**处理器** 2、**外部输入**，初次之后的 all 都是确定性质的数学模型，

## 多处理器

### 多处理器入门

我们的 CPu 通常会有多个核心，当我们有多个线程时并且这些线程不冲突，就可以放到每个核心上运行，这也就会使得在 ubuntu 系统上使用 top 看到的 cpu 使用率超过了 100%；

并且在我们能够创建线程之后，我们很容易去想这些线程是不是共享内存的呢？每个线程都独立拥有栈，那么这个栈的大小有没有限制呢？这就需要我们使用递归并创建局部变量消耗每个线程的局部空间，老师给了个例子，可以看看。

编译优化对于多处理器变成也是一个很大的阻碍，默认 gcc 会有三板斧编译

+ 对于内联函数，

