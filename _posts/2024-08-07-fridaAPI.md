## frida API语法学习


| Runtime Information               | 包含脚本运行时信息、Frida自身信息、以及进程、线程、模块和内存的相关操作。                                                 |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| Data Types, Function and Callback | 定义用于处理数据类型、函数和回调的相关功能。包括对不同数据类型和函数调用的处理方法。                                      |
| File and Stream                   | 提供文件和流处理的方法，用于在Frida脚本中进行文件读写和流操作。                                                           |
| Database                          | 包含对 SQLite 数据库操作的相关功能。                                                                                      |
| Instrumentation                   | 提供用于对应用程序进行逆向分析和修改的工具，如`Interceptor`、`Stalker` 等，用于拦截函数、跟踪执行、对代码进行修改等操作。 |
| ObjC 和 Java                      | 用于与 Objective-C 和 Java 进行交互的功能模块，允许在 Frida 脚本中调用 Objective-C 和 Java 的方法、访问对象等。           |
| CPU Instruction                   | 提供对不同 CPU 架构的指令和重定位进行操作的功能。支持 x86、Arm、Arm64、Mips 等架构的指令写入和重定位操作。                |
| Other                             | 包含一些其他功能模块，如控制台输出、十六进制转储、简化操作、主机和注入进程之间的通信、定时事件等。                        |

### 变量

#### 变量类型


| 索引 | API                  | 含义                                                                                    |
| ---- | -------------------- | --------------------------------------------------------------------------------------- |
| 1    | new Int64(v)         | 定义一个**有符号Int64**类型的变量值为v，参数v可以是**字符串或者以0x开头的的十六进制值** |
| 2    | new UInt64(v)        | 定义一个**无符号Int64类型**的变量值为v，参数v可以是字符串或者以0x开头的的十六进制值     |
| 3    | new NativePointer(s) | 定义一个**指针**，指针**地址为s**                                                       |
| 4    | ptr(“0”)           | 同上，也是定义一个指针                                                                  |

```js
Java.perform(function () {
    console.log("");
    console.log("new Int64(1):"+new Int64(1));
    console.log("new UInt64(1):"+new UInt64(1));
    console.log("new NativePointer(0xEC644071):"+new NativePointer(0xEC644071));
    console.log("new ptr('0xEC644071'):"+new ptr(0xEC644071));
});
    输出效果如下：
    new Int64(1):1
    new UInt64(1):1
    new NativePointer(0xEC644071):0xec644071
    new ptr('0xEC644071'):0xec644071
```

#### Int64(v)相关API


| `索引`` | API                                  | 含义                             |
| ------- | ------------------------------------ | -------------------------------- |
| 1       | add(rhs)、and(rhs) sub(rsh) xor(rhs) | 运算                             |
| 2       | shr(N) shl(N)                        | 移动位数                         |
| 3       | Compare(Rhs)                         | 比较                             |
| 4       | toNunber()                           | 转为数字                         |
| 5       | toString([radix=10])                 | 转换为可选基数的字符串(默认为10) |

```js
function hello_type() {
    Java.perform(function () {
        console.log("");
        //8888 + 1 = 8889
        console.log("8888 + 1:"+new Int64("8888").add(1));
        //8888 - 1 = 8887
        console.log("8888 - 1:"+new Int64("8888").sub(1));
        //8888 << 1 = 4444
        console.log("8888 << 1:"+new Int64("8888").shr(1));
        //8888 == 22 = 1 1是false
        console.log("8888 == 22:"+new Int64("8888").compare(22));
        //转string
        console.log("8888 toString:"+new Int64("8888").toString());
    });
}
```

### java层与native层

#### Java 层：

Android 应用程序的大部分逻辑和功能通常是用 Java 编程语言编写的。
Java 层包括 Android 应用程序中的活动（Activities）、服务（Services）、广播接收器（Broadcast Receivers）等组件，以及与用户界面交互的部分。
Android 提供了一个基于 Java 的框架，用于开发应用程序的业务逻辑和用户界面。这些代码在 Java 虚拟机（JVM）上运行

#### `Native 层`：

Android 平台允许使用 C/C++ 等语言编写一部分代码，这部分代码在本地执行，不依赖于 Java 虚拟机。
Native 层包括使用 C/C++ 编写的库、组件和系统功能。例如，图形处理、音频处理、加速算法等。
通过 JNI（Java Native Interface），Java 层的代码可以与 Native 层进行交互和调用，这使得开发者可以在需要时利用 C/C++ 的性能优势。

#### `某些java第三方库`

有些 Java 库函数的底层实现会使用 C/C++ 编写，这些函数通常是为了提高性能、利用底层系统资源或者访问特定的硬件。这种情况下，Java 的库函数会通过 JNI（Java Native Interface）与底层的 C/C++ 代码进行交互

就拿okHTTP3来说，它主要是用 Java 编写的，但它的底层实现确实依赖了一些 C/C++ 的库和函数。具体来说，OkHttp 在 Android 平台上的底层实现依赖于 Android 系统提供的网络底层库，这些库通常是用 C/C++ 编写的。
在 Android 上，网络访问和连接是通过底层的网络库来实现的，例如 libcore、libc、libnetd 等。OkHttp 库在其底层实现中可能直接或间接地使用了这些系统级的 C/C++ 库和函数来处理网络连接、数据传输、TLS 加密等操作。
具体来说，OkHttp 的底层并不直接调用 C/C++ 函数，而是依赖于 Android 系统的底层网络实现。这些底层实现涉及各种系统级的网络函数、套接字（sockets）、TLS/SSL 加密库等，这些底层功能是由 Android 系统提供并通过 Java API 提供访问接口给 OkHttp。

### `Thread

在 Frida 中，Thread 模块提供了对目标进程中线程的访问和操作功能。它允许用户监控和控制目标进程中的线程，执行线程级别的操作，以及查看线程相关的信息。

以下是 Frida 的 Thread 模块的一些功能和用法：

1. `**获取线程列表：** 使用 Thread.enumerateThreads() 方法可以获取目标进程中当前正在运行的线程列表，包括线程的 ID、名称等信息。
2. `**附加到线程：** 使用 Thread.attach(tid) 方法可以将 Frida 附加到指定 TID 的线程，允许用户对该线程进行监控和控制。
3. `**分离线程：** 使用 detach() 方法可以将 Frida 从附加的线程中分离，结束 Frida 对该线程的监控和控制。
4. `**线程暂停和恢复：** Thread.suspend(tid) 和 Thread.resume(tid) 方法允许用户暂停和恢复指定线程的执行。
5. `**获取线程状态和信息：** 使用 getThreadState(tid) 和 getThreadContext(tid) 方法可以获取指定线程的状态和上下文信息。
6. `**监视线程事件：** Frida 允许用户监听线程级别的事件，比如线程创建、结束等。

#### `Thread.backtrace([context, backtracer])

生成当前线程的backtrace，返回一个由一 个由 	NativePointer objects 组成的数组。

- `可选参数 context: 在 Interceptor 的 onEnter 或 onLeave 回调中调用此函数时，你应该为可选的 context 参数提供 this.context，这样会给出更准确的回溯信息。如果省略 context，则回溯将从当前堆栈位置生成，由于 JavaScript VM 的堆栈帧，这可能不会给出很好的回溯信息。
- `可选参数 backtracer: 指定要使用的回溯器类型，必须是 Backtracer.FUZZY 或 Backtracer.ACCURATE，默认值是 Backtracer.ACCURATE（如果未指定）。精确类型的回溯器依赖于调试友好的二进制文件或调试信息，可以更好地生成回溯信息；而模糊回溯器会在堆栈上执行取证，猜测返回地址，这意味着你可能会得到错误的结果，但它可以在任何二进制文件上运行。

生成的回溯目前限制为 16 个堆栈帧，并且不能通过重新编译 Frida 来进行调整。

这个功能非常有用，因为它允许你在进行 Frida 脚本开发时，获取当前线程的调用堆栈信息。这种信息对于分析程序的执行路径、调试和逆向工程非常有帮助。通过选择不同的回溯器类型，你可以根据需求在精确性和可用性之间进行权衡。

```js
const f = Module.getExportByName('libcommonCrypto.dylib',
    'CCCryptorCreate');
Interceptor.attach(f, {
  onEnter(args) {
    console.log('CCCryptorCreate called from:\n' +
        Thread.backtrace(this.context, Backtracer.ACCURATE)
        .map(DebugSymbol.fromAddress).join('\n') + '\n');
  }
});
```

#### Thread.sleep(delay)

suspend execution of the current thread for delay seconds specified as a number. For example 0.05 to sleep for 50 ms.

暂停当前线程一段时间，单位为ms毫秒

### process

在 Frida 中，Process 模块提供了访问和操作目标进程的功能。它允许用户获取有关正在运行的进程的信息，执行进程级别的操作以及与目标进程进行交互。

以下是 Frida 的 Process 模块的一些功能和用

1. **获取进程列表：** 可以使用 Process.enumerateProcesses() 方法来获取**当前系统**上正在运行的进程列表，包括进程的名称、PID 等信息。
2. 返回附加进程的PID：`Process.id`
3. 检测是否附加到目标进程：Process.isDebuggerAttached()
4. **附加到进程：** 使用 Process.attach(pid) 方法可以将 Frida 附加到指定 PID 的进程，允许用户对该进程进行动态分析和修改
5. **分离进程：** 使用 detach() 方法可以将 Frida 从附加的进程中分离，结束 Frida 对该进程的监控和控制。
6. **检测进程状态：** 通过 isDebuggerAttached() 方法可以检查 Frida 是否已经附加到目标进程。
7. **获取进程模块信息：** 使用 enumerateModules() 方法可以获取目标进程加载的模块（库）信息，包括模块名称、基址、大小等。
8. **执行远程代码：** Process 模块允许用户在目标进程中执行远程代码，这对于注入特定的功能或修改目标进程非常有用。
9. **监视进程事件：** Frida 允许用户监听进程级别的事件，比如进程创建、终止等。

示例代码如下所示，展示了 Frida 中 Process 模块的一些常用操作：

```javascript
javascriptCopy code
// 获取进程列表
var processes = Process.enumerateProcesses();
console.log(JSON.stringify(processes));

// 附加到指定 PID 的进程
var targetProcess = 1234;  // 替换为你要附加的进程 PID
Process.attach(targetProcess);

// 获取模块信息
var modules = Process.enumerateModules();
console.log(JSON.stringify(modules));

// 执行远程代码
var result = Process.getModuleByName('libxyz.so').enumerateExports();
console.log(JSON.stringify(result));

// 分离进程
Process.detach();
```

Process 模块允许用户对目标进程进行广泛的操作和分析，但在使用过程中需要小心谨慎，确保操作不会对目标进程产生不良影响。`

#### Process.id

这是 Process的属性，返回number类型的进程id

#### Process.arch

返回 string ia32, x64, arm or arm64

#### Process.platform

返回string windows, darwin, linux or qnx

#### Process.pageSize

返回虚拟内存页的大小，单位为byte。可以用来获取当前系统的页面大小，这在一些内存操作或计算内存地址偏移时可能会很有用，特别是在与底层系统进行交互、分析内存布局或进行内存操作时。 。在不同的操作系统和架构上，页面大小可能会有所不同，通常是固定的。这个值通常是2的幂，常见的页面大小包括 4KB、8KB、16KB 等。

#### Process.pointerSize

返回指针的大小单位为bytes（其实就是告诉你计算机是多少位的）

#### Process.getCurrentThreadId()

这个函数**返回调用它的线程的 ID**。在线程级别进行操作时，例如监视特定线程的活动或者在特定线程上执行某些操作时，使用这个函数可以获取当前线程的 ID，以便进行相应的处理。

#### Process.enumerateThreads()

枚举所有的线程，返回对象object数组，每个对象含有以下方法：

- id: OS-specific id，线程ID
- state: string specifying either running, stopped, waiting, uninterruptible or halted`线程运行状态
- context: object with the keys pc and sp, which are **NativePointer** objects specifying EIP/RIP/PC and ESP/RSP/SP, respectively, for ia32/x64/arm. Other processor-specific keys are also available, e.g. eax, rax, r0, x0, etc.也是一个对象，其实就是一个含有各种线程使用的寄存器的对象！！`带有键pc和sp的对象，它们是分别为ia32/x64/arm指定EIP/RIP/PC和ESP/RSP/SP的NativePointer对象。也可以使用其他处理器特定的密钥，例如eax、rax、r0、x0等。

```js
function frida_Process() {
    Java.perform(function () {
       var enumerateThreads =  Process.enumerateThreads();
       for(var i = 0; i < enumerateThreads.length; i++) {
        console.log("");
        console.log("id:",enumerateThreads[i].id);
        console.log("state:",enumerateThreads[i].state);
        console.log("context:",JSON.stringify(enumerateThreads[i].context));
        }
    });
}
setImmediate(frida_Process,0);
```

![img](../%E7%AC%94%E8%AE%B0/frida%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0.assets/t015d7ed42cbf128976.png)

#### findModule

**Module** ：在Frida中，Module 指代的是一个已加载到内存中的程序库（库文件）或者可执行文件（例如应用程序）。每个模块都有其在内存中的基址（base address），即其加载到内存中的起始地址。Module 对象提供了许多有用的信息，例如模块的名称、路径、导出函数、导入函数等。使用 Frida，你可以监视和分析模块，拦截模块中的函数调用，甚至可以修改模块中的数据。

Process.findModuleByAddress(address), Process.getModuleByAddress(address), Process.findModuleByName(name), Process.getModuleByName(name) 这四个函数都能够用来寻找相应的module

当然Process.enumerateModules() 可以直接返回所有的module数组

```js
function frida_Process() {
    Java.perform(function () {
        var process_Obj_Module_Arr = Process.enumerateModules();
        for(var i = 0; i < process_Obj_Module_Arr.length; i++) {
            console.log("",process_Obj_Module_Arr[i].name);
        }
    });
}
setImmediate(frida_Process,0);
```

数组中存储N个叫Module的对象 ，使用下标的方式调用了`Module`对象的`name`属性，`name`是`so`模块的名称

#### findRange

**Range（范围）**：Range 则指的是内存中的一个区域，这个区域可以是连续的一段内存。在Frida中，Range 对象表示一段内存区域的起始地址和大小。它常用于诸如内存搜索、内存读写等操作中。使用 Range，你可以指定要操作的特定内存区域，并执行相应的操作，比如搜索特定模式的字节、读取或修改内存中的数据等。

Process.findRangeByAddress(address), getRangeByAddress(address):

##### `Process.enumerateRanges(protection|specifier) ：`

这个方法用于列举满足特定保护级别的内存范围。它接受一个保护级别的字符串，格式为 rwx，其中 rw- 表示“必须至少可读可写”。此外，也可以提供一个包含 protection 键的对象作为参数，该键的值与之前提到的保护级别字符串相同。如果你希望相邻具有相同保护级别的内存范围合并，可以设置 coalesce 键为 true（默认为 false，即保持范围分开）。

该方法返回一个对象数组，每个**range对象**包含以下属性：

- base: 以 NativePointer 类型表示的基址（内存范围的起始地址）
- size: 以字节为单位的大小
- protection: 保护级别字符串（如上所述）
- file: 当可用时，表示文件映射的详细信息对象，包含以下属性：
  - path: 字符串形式的完整文件系统路径
  - offset: 在磁盘上映射文件中的偏移量，以字节为单位
  - size: 在磁盘上映射文件中的大小，以字节为单位

```
这个方法允许你枚举满足指定保护级别的内存范围，并提供这些内存范围的基本信息，包括其地址、大小和保护级别。如果适用的话，还可以提供与文件映射相关的细节信息。这在进行内存分析和调试时可能会很有用。
```


#### Process.setExceptionHandler(callback)

设置一个建立在整个程序范围的异常处理回调，当目标进程抛出异常时（例如访问无效内存或执行非法指令时），Frida 允许你设置一个异常处理程序来捕获并处理这些异常。使用 Process.setExceptionHandler(callback)，你可以指定一个回调函数 callback，这个回调函数会在目标进程抛出异常时被调用。

该回调函数将接收一个 details 对象作为参数，这个对象包含有关异常的详细信息，例如异常类型、引发异常的地址、CPU 寄存器状态等。你可以在回调函数中分析这些信息，采取适当的措施来处理异常，例如记录日志、调整进程状态或者采取其他操作来处理异常情况。

这种异常处理机制在进行软件调试或进行安全分析时可能会非常有用，因为它允许你在目标进程发生异常时获取并处理异常信息。然而，在使用时需要谨慎，确保处理异常的操作不会进一步损害目标进程的稳定性或安全性。

### Module

模块（Module）是指一个包含了函数、变量和其他可执行代码的独立文件。模块可以被其他程序引入并使用，这样可以将代码组织成更小的可管理单元，提高了代码的可读性、复用性和可维护性。

1. **命名空间和作用域：** 模块创建了一个独立的命名空间，这意味着在不同的模块中可以定义相同名称的函数或变量而不会发生冲突。
2. `**模块化开发：** 模块化开发是一种分而治之的编程方式，将大型程序分解为小型、可独立开发和测试的模块。这样可以简化开发过程，并提高代码的可维护性。

这个 Module并不是自带的，需要我的首先使用 [Module.load()](https://frida.re/docs/javascript-api/#module-load) and [Process.enumerateModules()](https://frida.re/docs/javascript-api/#process-enumeratemodules) 等先得到。

Process.EnumererateModules()`方法返回了就是一个`Module`对象数组。

#### property

- name: 字符串形式的规范化模块名`
- base: base address as a [NativePointer]模块地址，其变量类型为NativePointer
- size: size in bytes
- path: full filesystem path as a string完整文件系统路径

#### methods


| 索引 | API                                                                                                             | 含义                                                         |
| ---- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| 1    | Module.load(moduleName)                                                                                         | 加载指定so文件，返回一个Module对象                           |
| 2    | enumerateImports()                                                                                              | 枚举所有Import库函数，返回对象数组，对象对应一个变量或者函数 |
| 3    | enumerateExports()                                                                                              | 枚举所有Export库函数，返回对象数组，对象对应一个变量或者函数 |
| 4    | enumerateSymbols()                                                                                              | 枚举所有Symbol库函数，返回Module数组对象                     |
| 5    | **Module.findExportByName**(moduleName\|null，exportName)、Module.getExportByName(moduleName\|null，exportName) | 寻找指定so中export库中的函数地址                             |
| 6    | **Module.findBaseAddress**(name)、**Module.getBaseAddress**(name)                                               | 返回so的基地址                                               |
| 7    | findExportByName（exportName）                                                                                  | 同 5                                                         |

##### Module.load()

```js
function frida_Module() {
    Java.perform(function () {
         //参数为so的名称 返回一个Module对象
         const hooks = Module.load('libhello.so');
         //输出
         console.log("模块名称:",hooks.name);
         console.log("模块地址:",hooks.base);
         console.log("大小:",hooks.size);
         console.log("文件系统路径",hooks.path);
    });
}
setImmediate(frida_Module,0);

输出如下：
模块名称: libhello.so
模块地址: 0xdf2d3000
大小: 24576
文件系统路径 /data/app/com.roysue.roysueapplication-7adQZoYIyp5t3G5Ef5wevQ==/lib/arm/libhello.so
```

##### Process.EnumererateModules()

```js
function frida_Module() {
    Java.perform(function () {

        var process_Obj_Module_Arr = Process.enumerateModules();
        for(var i = 0; i < process_Obj_Module_Arr.length; i++) {
            if(process_Obj_Module_Arr[i].path.indexOf("hello")!=-1)
            {
                console.log("模块名称:",process_Obj_Module_Arr[i].name);
                console.log("模块地址:",process_Obj_Module_Arr[i].base);
                console.log("大小:",process_Obj_Module_Arr[i].size);
                console.log("文件系统路径",process_Obj_Module_Arr[i].path);
            }
         }
    });
}
setImmediate(frida_Module,0);

输出如下：
模块名称: libhello.so
模块地址: 0xdf2d3000
大小: 24576
文件系统路径 /data/app/com.roysue.roysueapplication-7adQZoYIyp5t3G5Ef5wevQ==/lib/arm/libhello.so
```

##### enumerateImports():

enumerates imports of module, returning an array of objects containing the following properties:

- type: string specifying either function or variable
- name: import name as a string
- module: module name as a string
- address: absolute address as a [NativePointer](https://frida.re/docs/javascript-api/#nativepointer)
- slot: memory location where the import is stored, as a [NativePointer](https://frida.re/docs/javascript-api/#nativepointer)

```js
function frida_Module() {
    Java.perform(function () {
        const hooks = Module.load('libhello.so');
        var Imports = hooks.enumerateImports();
        for(var i = 0; i < Imports.length; i++) {
            //函数类型
            console.log("type:",Imports[i].type);
            //函数名称
            console.log("name:",Imports[i].name);
            //属于的模块
            console.log("module:",Imports[i].module);
            //函数地址
            console.log("address:",Imports[i].address);
         }
    });
}
setImmediate(frida_Module,0);

输出如下：
[Google Pixel::com.roysue.roysueapplication]-> type: function
name: __cxa_atexit
module: /system/lib/libc.so
address: 0xf58f4521
type: function
name: __cxa_finalize
module: /system/lib/libc.so
address: 0xf58f462d                                                                                                                                         
type: function
name: __stack_chk_fail
module: /system/lib/libc.so
address: 0xf58e2681
```

##### enumerateExports():

enumerates exports of module, returning an array of objects containing the following properties:

- type: string specifying either function or variable
- name: export name as a string
- address: absolute address as a [NativePointer](https://frida.re/docs/javascript-api/#nativepointer)

```js
function frida_Module() {
    Java.perform(function () {
        const hooks = Module.load('libhello.so');
        var Imports = hooks.enumerateImports();
        for(var i = 0; i < Imports.length; i++) {
            //函数类型
            console.log("type:",Imports[i].type);
            //函数名称
            console.log("name:",Imports[i].name);
            //属于的模块
            console.log("module:",Imports[i].module);
            //函数地址
            console.log("address:",Imports[i].address);
         }
    });
}
setImmediate(frida_Module,0);

输出如下：
[Google Pixel::com.roysue.roysueapplication]-> type: function
name: __cxa_atexit
module: /system/lib/libc.so
address: 0xf58f4521
type: function
name: __cxa_finalize
module: /system/lib/libc.so
address: 0xf58f462d                                                                                                                                         
type: function
name: __stack_chk_fail
module: /system/lib/libc.so
address: 0xf58e2681
```

##### enumerateSymbols():

enumerates symbols of module, returning an array of objects containing the following properties:

- isGlobal: boolean specifying whether symbol is globally visible`
- type: string specifying one of:`
- unknown
- section
- undefined (Mach-O)
- absolute (Mach-O)
- prebound-undefined (Mach-O)
- indirect (Mach-O)
- object (ELF)
- function (ELF)
- file (ELF)
- common (ELF)
- tls (ELF)
- section: if present, is an object containing
- string containing section index, segment name (if applicable) and section name – same format as r2’s section IDs
- protection: protection like in Process.enumerateRanges()
- name: symbol name as a string
- address: absolute address as a NativePointer
- size: if present, a number specifying the symbol’s size in bytes

```js
function frida_Module() {
    Java.perform(function () {
        const hooks = Module.load('libc.so');
        var Symbol = hooks.enumerateSymbols();
        for(var i = 0; i < Symbol.length; i++) {
            console.log("isGlobal:",Symbol[i].isGlobal);
            console.log("type:",Symbol[i].type);
            console.log("section:",JSON.stringify(Symbol[i].section));
            console.log("name:",Symbol[i].name);
            console.log("address:",Symbol[i].address);
         }
    });
}
setImmediate(frida_Module,0);

输出如下：
isGlobal: true
type: function
section: {"id":"13.text","protection":"r-x"}
name: _Unwind_GetRegionStart
address: 0xf591c798
isGlobal: true
type: function
section: {"id":"13.text","protection":"r-x"}
name: _Unwind_GetTextRelBase
address: 0xf591c7cc
```

findExportByName(exportName), getExportByName(exportName):

- returns the absolute address of the export named exportName. In the event that no such export could be found, the *find*-prefixed function returns *null* whilst the *get*-prefixed function throws an exception.

##### Module.findExportByName(moduleName|null, exportName)

##### Module.getExportByName(moduleName|null, exportName):

返回值直接就是：地址！！！如果module是null的话，可能非常花费时间！！

- returns the absolute address of the export named exportName in moduleName. If the module isn’t known you may pass null instead of its name, but this can be a costly search and should be avoided. In the event that no such module or export could be found, the *find*-prefixed function returns *null* whilst the *get*-prefixed function throws an exception.

```js
function frida_Module() {
    Java.perform(function () {
        Module.getExportByName('libhello.so', 'c_getStr')
        console.log("Java_com_roysue_roysueapplication_hellojni_getStr address:",Module.findExportByName('libhello.so', 'Java_com_roysue_roysueapplication_hellojni_getStr'));
        console.log("Java_com_roysue_roysueapplication_hellojni_getStr address:",Module.getExportByName('libhello.so', 'Java_com_roysue_roysueapplication_hellojni_getStr'));
    });
}
setImmediate(frida_Module,0);

输出如下：
Java_com_roysue_roysueapplication_hellojni_getStr address: 0xdf2d413d
Java_com_roysue_roysueapplication_hellojni_getStr address: 0xdf2d413d
```

##### Module.findBaseAddress(name)

```js
function frida_Module() {
    Java.perform(function () {
        var name = "libhello.so";
        console.log("so address:",Module.findBaseAddress(name));
        console.log("so address:",Module.getBaseAddress(name));
    });
}
setImmediate(frida_Module,0);

输出如下：
so address: 0xdf2d3000
so address: 0xdf2d3000
```

### ModuleMap

在 Frida 中，modulemap 是一个用于描述特定应用程序的模块信息的文件。它用于告诉 Frida 应用程序中模块的名称、地址和导出的符号信息，以便在运行时对其进行分析、挂钩或监视。

这个文件是可选的，但对于一些复杂的应用程序或库，提供一个 modulemap 文件可以让 Frida 更准确地定位和操作模块中的函数或数据。

在 Frida 的 modulemap 文件中，你可以指定模块的名称和模块中包含的函数等信息。例如：

```bash
plaintextCopy code
module my_app

  // 模块名称和基地址
  base: "0x12345678"
  memory: "r-x"

  // 导出的函数
  export * from libsystem_kernel.dylib
  export * from libobjc.A.dylib

  // 函数定义
  define(function, "0x87654321")
```

这个文件可以定义模块的名称、基地址、内存权限、导出的函数以及自定义的函数等信息。通过提供这些信息，Frida 可以更加精确地在运行时定位和操作应用程序中的模块，使得分析和修改更加方便和精准。

### Memory

Frida 的 Memory 模块是用于在运行时**操作内存**的强大工具。它允许用户在目标进程中读取和写入内存，执行内存分配和释放等操作。通过 Memory 模块，用户可以执行以下操作：

1. **读取和写入内存：** 用户可以使用 Memory 模块读取和写入目标进程的内存。这对于检索特定数据、修改变量值或者注入代码非常有用。
2. **分配和释放内存：** Frida 允许用户在目标进程中进行内存分配和释放。这在一些情况下非常有用，比如动态地分配内存用于注入 shellcode。
3. **模式搜索：** 用户可以在目标进程的内存中执行模式搜索，以便找到特定的数据模式或特征。这可以用于查找特定字符串、函数调用或者其他模式。
4. **操作内存块：** 用户可以复制、填充或修改内存块的内容。这对于批量修改内存或执行内存内容的转移很有用。

以下是 Frida Memory 模块常用的 API：

- readPointer(address)：读取给定内存地址的指针值。
- writePointer(address, value)：将指针值写入给定的内存地址。
- alloc(size)：在目标进程中分配指定大小的内存块。
- free(address)：释放目标进程中给定地址的内存。
- scan(pattern, options)：在目标进程内存中执行模式搜索。
- copy(destination, source, size)：从一个内存地址复制内容到另一个地址。
- patchCode(address, length, apply)：在目标进程中修改指定地址处的代码。

#### scan(pattern, options)

```js
function frida_Memory() {
    Java.perform(function () {
        //先获取so的module对象
        var module = Process.findModuleByName("libhello.so"); 
        //??是通配符
        var pattern = "03 49 ?? 50 20 44";
        //基址
        console.log("base:"+module.base)
        //从so的基址开始搜索，搜索大小为so文件的大小，搜指定条件03 49 ?? 50 20 44的数据
        var res = Memory.scan(module.base, module.size, pattern, {
            onMatch: function(address, size){
                //搜索成功
                console.log('搜索到 ' +pattern +" 地址是:"+ address.toString());  
            }, 
            onError: function(reason){
                //搜索失败
                console.log('搜索失败');
            },
            onComplete: function()
            {
                //搜索完毕
                console.log("搜索完毕")
            }
          });
    });
}
setImmediate(frida_Memory,0);
```

#### Memory.scanSync

```js
function frida_Memory() {
    Java.perform(function () {
        var module = Process.findModuleByName("libhello.so"); 
        var pattern = "03 49 ?? 50 20 44";
        var scanSync = Memory.scanSync(module.base, module.size, pattern);
        console.log("scanSync:"+JSON.stringify(scanSync));
    });
}
setImmediate(frida_Memory,0);

输出如下，可以看到地址搜索出来是一样的
scanSync:[{"address":"0xdf2d412a","size":6}]
```

```js

```

#### Memory.alloc

在目标进程中的堆上申请`size`大小的内存，并且会按照`Process.pageSize`对齐，返回一个`NativePointer`，并且申请的内存如果在`JavaScript`里面没有对这个内存的使用的时候会自动释放的。也就是说，如果你不想要这个内存被释放，你需要自己保存一份对这个内存块的引用。

```js
function frida_Memory() {
    Java.perform(function () {
        const r = Memory.alloc(10);
        console.log(hexdump(r, {
            offset: 0,
            length: 10,
            header: true,
            ansi: false
        }));
    });
}
setImmediate(frida_Memory,0);
```

![img](fridaAPI.assets/t01315da1bd55915455.png)

#### 在内存保存字符串

`Memory.allocUtf8String(str)` 分配utf字符串 `Memory.allocUtf16String（str）` 分配utf16字符串 `Memory.allocAnsiString（str）` 分配ansi字符串

#### 内存复制memory.copy

```js
function frida_Memory() {
    Java.perform(function () {
        //获取so模块的Module对象
        var module = Process.findModuleByName("libhello.so"); 
        //条件
        var pattern = "03 49 ?? 50 20 44";
        //搜字符串 只是为了将so的内存数据复制出来 方便演示~
        var scanSync = Memory.scanSync(module.base, module.size, pattern);
        //申请一个内存空间大小为10个字节
        const r = Memory.alloc(10);
        //复制以module.base地址开始的10个字节 那肯定会是7F 45 4C 46...因为一个ELF文件的Magic属性如此。
        Memory.copy(r,module.base,10);
        console.log(hexdump(r, {
            offset: 0,
            length: 10,
            header: true,
            ansi: false
        }));
    });
}
setImmediate(frida_Memory,0);


输出如下。
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
e8142070  7f 45 4c 46 01 01 01 00 00 00                    .ELF......
```

#### 写入内存Memory.WriteByteArray

将字节数组写入一个指定内存

```js
function frida_Memory() {   
    Java.perform(function () {
        //定义需要写入的字节数组 这个字节数组是字符串"roysue"的十六进制
        var arr = [ 0x72, 0x6F, 0x79, 0x73, 0x75, 0x65];
        //申请一个新的内存空间 返回指针 大小是arr.length
        const r = Memory.alloc(arr.length);
        //将arr数组写入R地址中
        Memory.writeByteArray(r,arr);
        //输出
        console.log(hexdump(r, {
            offset: 0,
            length: arr.length,
            header: true,
            ansi: false
        }));  
    });
}
setImmediate(frida_Memory,0);


输出如下。
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  72 6f 79 73 75 65                                roysue
```

#### d读取内存Memory.readByteArray

```js
function frida_Memory() {   
    Java.perform(function () {
        //定义需要写入的字节数组 这个字节数组是字符串"roysue"的十六进制
        var arr = [ 0x72, 0x6F, 0x79, 0x73, 0x75, 0x65];
        //申请一个新的内存空间 返回指针 大小是arr.length
        const r = Memory.alloc(arr.length);
        //将arr数组写入R地址中
        Memory.writeByteArray(r,arr);
        //读取r指针，长度是arr.length 也就是会打印上面一样的值
        var buffer = Memory.readByteArray(r, arr.length);
        //输出
        console.log("Memory.readByteArray:");
        console.log(hexdump(buffer, {
            offset: 0,
            length: arr.length,
            header: true,
            ansi: false
        }));
      });  
    });
}
setImmediate(frida_Memory,0);

输出如下。
[Google Pixel::com.roysue.roysueapplication]-> Memory.readByteArray:
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  72 6f 79 73 75 65                                roysue
```

### MemoryAccessMonitor

Frida 的 MemoryAccessMonitor 是一个功能强大的工具，用于监视目标进程中的内存访问操作。它允许用户监控和记录对特定内存区域的访问，包括读取和写入操作。

使用 MemoryAccessMonitor 可以进行以下操作：

1. **监控内存访问：** 你可以使用 MemoryAccessMonitor 来监视特定内存地址范围内的读取和写入操作，这对于跟踪对敏感数据或关键变量的访问非常有用。
2. **记录内存操作：** 一旦设置了内存访问监视器，它可以记录并报告目标进程中的所有访问操作，包括读取和写入。
3. **检测异常行为：** 通过监视内存访问，你可以检测到未经授权的内存访问，例如试图修改只读内存或者访问未分配的内存区域。

使用 Frida 的 MemoryAccessMonitor 需要编写 JavaScript 脚本并将其注入到目标进程中。以下是一个简单的示例，展示了如何使用 MemoryAccessMonitor 监视特定内存区域的访问：

```javascript
javascriptCopy code
// 创建内存访问监视器
var monitor = MemoryAccessMonitor.create(ptr('0x12345678'), 4);

// 监视读取操作
monitor.on('read', function (access, address) {
  console.log('Read access:', access + ' bytes at ' + address);
});

// 监视写入操作
monitor.on('write', function (access, address) {
  console.log('Write access:', access + ' bytes at ' + address);
});

// 启动监视器
monitor.enable();
```

`这个示例代码创建了一个 MemoryAccessMonitor 来监视地址 0x12345678 处的 4 个字节。它设置了读取和写入的监视器，一旦有读取或写入操作，就会在控制台中显示相应的信息。`

### ApiResolver

ApiResolver 是一个功能强大的工具，用于**解析目标进程**中的导出函数、符号、类和方法等。它允许用户根据特定的模式、名称或签名来查找和解析目标进程中的 API，无论是在 native 层还是 Java 层。

ApiResolver 模块主要用于以下用途：

1. **符号解析：** 在 native 层，ApiResolver 可以解析和查找动态链接库（DLL、SO 等）中的导出函数，以及其他模块中的符号信息。它能够根据特定的模式、名称或签名查找函数，并提供给用户使用。
2. **Java 方法解析：** 在 Java 层，ApiResolver 可以用于解析和查找目标应用程序中的 Java 类和方法。它可以根据特定的类名、方法名或签名查找 Java 方法，并允许用户进行操作。
3. **动态 Hooking：** ApiResolver 通常与 Frida 的 Interceptor 模块结合使用，允许用户根据解析的函数或方法进行挂钩（Hooking），并监视或修改其行为。

示例代码如下所示，展示了 Frida 中 ApiResolver 模块的一些常用操作：

```javascript
javascriptCopy code
// 解析 native 导出函数
var resolver = new ApiResolver('module_name');
var matches = resolver.enumerateMatches('symbol_pattern');
console.log(JSON.stringify(matches));

// 解析 Java 方法
var javaResolver = Java.use('target_class');
var methods = javaResolver.$methods;
console.log(JSON.stringify(methods));

// 结合 Interceptor 进行挂钩
var targetFunction = resolver.enumerateMatches('target_function')[0].address;
Interceptor.attach(targetFunction, {
  onEnter: function(args) {
    console.log('Function entered');
  },
  onLeave: function(retval) {
    console.log('Function exited');
  }
});
```

通过 ApiResolver，用户可以轻松地查找目标进程中的特定函数、方法或符号，然后使用 Frida 的其他功能来对其进行进一步操作，如监视、修改或挂钩。这对于分析应用程序、执行调试操作或注入特定行为非常有用。

#### new ApiResolver(type) ：

对于给定的type创建一个新的resolver，目前可以支持的type有：

- module: Resolves exported and imported functions of shared libraries currently loaded. Always available.
- objc: Resolves Objective-C methods of classes currently loaded. Available on macOS and iOS in processes that have the Objective-C runtime loaded. Use [ObjC.available](https://frida.re/docs/javascript-api/#objc-available) to check at runtime, or wrap your new ApiResolver('objc') call in a *try-catch*.

解析器会加载创建所需要的最小数据量，并且之后会根据接收到的quires来lazy-load其他数据，因此推荐对于同一批次的require使用相同的解析器对象，不同则重新创建一个。

#### enumerateMatches(query)

执行特定的string类型的query，并可以结合 /i来进行忽略大小写query，返回对象的数组，含有以下属性：

- name: name of the API that was found
- address: address as a [NativePointer](https://frida.re/docs/javascript-api/#nativepointer)

```js
const resolver = new ApiResolver('module');
// 'exports:*!open*'表示任意模块下的以open开头的函数api
const matches = resolver.enumerateMatches('exports:*!open*');
const first = matches[0];
/*
 * Where `first` is an object similar to:
 *
 * {
 *   name: '/usr/lib/libSystem.B.dylib!opendir$INODE64',
 *   address: ptr('0x7fff870135c9')
 * }
 */
```

### NativePointer

同等与C语言中的指针

在 Frida 中，NativePointer 是一个用于表示和操作 native 层内存地址的对象。它允许用户引用和操作目标进程中的内存地址，执行读取、写入和其他操作。

NativePointer 对象主要用于以下目的：

1. **表示内存地址：** NativePointer 可以表示目标进程中的内存地址，允许用户引用特定的内存位置。
2. **读取和写入内存：** 用户可以使用 NativePointer 对象读取和写入目标进程中的内存内容。这对于检索数据、修改变量值或执行内存操作非常有用。
3. **执行函数调用：** 用户可以使用 NativePointer 对象来执行对目标进程中特定函数的调用。这对于执行动态代码注入或执行 shellcode 等操作很有用。
4. **偏移和计算地址：** NativePointer 允许用户进行地址偏移和计算，以便访问内存中的特定区域。

示例代码如下所示，展示了 Frida 中 NativePointer 对象的一些常用操作：

```js
javascriptCopy code
// 获取内存地址
var address = Module.findExportByName('module_name', 'function_name');
var pointer = new NativePointer(address);
// 或者 

// 读取内存内容
var value = pointer.readU32();
console.log('Value at address:', value);

// 写入内存内容
pointer.writeByteArray([0x90, 0x90, 0x90]); // 写入三个 NOP 指令

// 计算偏移地址
var offsetPointer = pointer.add(0x10); // 在原地址基础上偏移 0x10

// 执行函数调用
var funcPointer = new NativePointer('0x12345678'); // 假设是目标函数地址
var func = new NativeFunction(funcPointer, 'void', ['int']);
func(42); // 执行目标函数并传入参数
```

NativePointer 对象是 Frida 中用于表示和操作内存地址的重要工具，它允许用户在目标进程中执行各种内存操作和函数调用。在使用时，需要小心谨慎，确保对目标进程的操作是安全和有效的。

各各种API：![img](fridaAPI.assets/t0135a7319c873d8d52.png)

![img](fridaAPI.assets/t01821e14d1331f0aef.png)

### NativeFunction

在 Frida 中，NativeFunction 是一个用于调用目标进程中 native 层函数的对象。它允许用户在运行时执行对目标进程中函数的调用，可以是动态链接库（DLL、SO 等）中的导出函数，也可以是其他可执行代码中的函数。

NativeFunction 对象主要用于以下目的：

1. **执行函数调用：** 用户可以使用 NativeFunction 对象来执行对目标进程中特定函数的调用。这允许用户执行动态代码注入、调用函数以修改进程行为等操作。
2. **传递参数：** NativeFunction 允许用户传递参数给目标函数，并指定参数的类型。这对于正确地调用函数并传递正确的参数至关重要。
3. **返回值处理：** 用户可以指定目标函数的返回值类型，并处理函数返回的结果。

示例代码如下所示，展示了 Frida 中 NativeFunction 对象的一些常用操作：

```js
javascriptCopy code
// 获取函数地址
var address = Module.findExportByName('module_name', 'function_name');

// 创建 NativeFunction 对象，参数：（1）IP地址 （2）返回类型 （3）参数类型
var func = new NativeFunction(address, 'int', ['int', 'pointer']);

// 调用函数并处理返回值
var result = func(42, Memory.alloc(4));
console.log('Function result:', result);
```

在这个示例中，NativeFunction 被创建用于调用特定函数，并指定了函数的参数类型和返回值类型。用户可以传递参数给函数，并处理函数的返回值。

使用 NativeFunction 时需要小心谨慎，确保传递的参数和返回值类型与目标函数的预期类型匹配，以避免对目标进程造成不良影响。

### ArrayBuffer

在 Frida 中，ArrayBuffer 是一个用于操作内存的对象，允许用户在脚本中创建和处理二进制数据。它提供了一种灵活的方式来处理和操作内存块，对于进行内存读取、写入以及数据处理十分有用。

ArrayBuffer 主要用于以下目的：

1. **创建内存缓冲区：** ArrayBuffer 允许用户创建指定大小的内存缓冲区，用于存储二进制数据。
2. **读取和写入数据：** 用户可以使用 ArrayBuffer 对象读取和写入内存中的数据。这对于从目标进程中读取数据或向其写入数据十分有用。
3. **操作二进制数据：** ArrayBuffer 提供了对二进制数据进行处理的功能，比如获取特定位置的字节、拷贝数据到指定位置等。

示例代码如下所示，展示了 Frida 中 ArrayBuffer 对象的一些常用操作：

```js
javascriptCopy code
// 创建 ArrayBuffer
var buffer = new ArrayBuffer(0x100); // 创建大小为 0x100 字节的 ArrayBuffer

// 获取 ArrayBuffer 的数据视图
var uint8View = new Uint8Array(buffer); // 使用 Uint8Array 视图操作 ArrayBuffer

// 读取和写入数据
uint8View[0] = 0x41; // 将第一个字节设为 ASCII 'A'

// 获取特定位置的字节
var byte = uint8View[0];

// 复制数据到指定位置
var srcBuffer = new ArrayBuffer(4);
var dstBuffer = new ArrayBuffer(4);
var srcView = new Uint8Array(srcBuffer);
var dstView = new Uint8Array(dstBuffer);
srcView[0] = 0x41; // 填充数据到源 ArrayBuffer
dstView.set(srcView); // 复制数据到目标 ArrayBuffer
```

通过 ArrayBuffer，用户可以在 Frida 脚本中创建内存缓冲区，并使用数据视图进行读取、写入和处理二进制数据。这对于在目标进程中操作内存和处理二进制数据非常有用。

### NativeCallback

`在 Frida 中，NativeCallback 是一个用于创建本地回调函数的对象。它允许用户在脚本中定义本地函数，并将其作为回调函数传递给目标进程中的函数或挂钩点，以便在特定条件下触发这些本地函数的执行。`

NativeCallback 对象的主要用途包括：

1. **创建本地回调函数：** 用户可以使用 NativeCallback 创建本地函数，用于作为回调函数在目标进程中执行。这些本地函数可以在特定条件下被触发，比如被挂钩的函数执行时。
2. **挂钩函数：** NativeCallback 可以作为 Frida 中 Interceptor 或 Stalker 模块的回调函数，用于在函数执行前后执行自定义的本地代码。
3. **处理参数和返回值：** 用户可以使用 NativeCallback 在回调函数中处理传入的参数并处理返回值。这对于修改函数的参数或返回值非常有用。

示例代码如下所示，展示了 Frida 中 NativeCallback 对象的一些常用操作：

```js
javascriptCopy code
// 创建本地回调函数
var callback = new NativeCallback(function (x, y) {
    console.log('Callback function called with arguments:', x, y);
    return x + y; // 对传入的参数求和并返回
}, 'int', ['int', 'int']);

// 使用 Interceptor 进行挂钩
Interceptor.attach(Module.findExportByName(null, 'target_function'), {
    onEnter: function (args) {
        var result = callback(args[0].toInt32(), args[1].toInt32());
        console.log('Result from callback:', result);
    }
});
```

`在这个示例中，NativeCallback 被用来创建一个本地函数，并且作为一个 Interceptor 的回调函数，当目标函数执行时被触发。该本地函数接收两个整数参数，对它们进行求和并返回。这种方法可以用于在目标函数执行前或执行后执行自定义的本地代码。`

### Interceptor

Interceptor 是 Frida 中一个重要的模块，用于在目标进程中拦截函数调用并执行自定义的操作。它允许用户监视和修改目标进程中的函数调用，以便进行调试、修改参数、获取返回值等操作。

Interceptor 的主要功能和用途包括：

1. **挂钩函数：** 用户可以使用 Interceptor 模块来挂钩（hook）目标进程中的函数，以便在函数执行前、执行后或替换函数的执行时执行自定义的代码。
2. **修改参数和返回值：** 通过拦截函数调用，用户可以访问和修改函数的参数、返回值，甚至修改函数的执行结果。
3. **调试和分析：** Interceptor 允许用户对函数进行监视，并输出函数参数、返回值或执行情况的相关信息，以便进行调试或分析。
4. **执行自定义代码：** 用户可以在函数执行前后执行自定义的本地 JavaScript 代码，以便触发特定的行为或实现特定的逻辑。

示例代码如下所示，展示了 Frida 中 Interceptor 模块的一些常用操作：

```js
javascriptCopy code
// 拦截目标函数并执行自定义操作
Interceptor.attach(Module.findExportByName(null, 'target_function'), {
    onEnter: function (args) {
        console.log('Entering target_function with args:', args[0], args[1]);

        // 修改参数值
        args[0] = ptr(123); // 修改第一个参数为 123
        args[1] = ptr(456); // 修改第二个参数为 456
    },
    onLeave: function (retval) {
        console.log('Leaving target_function with return value:', retval);
      
        // 修改返回值
        retval.replace(789); // 修改返回值为 789
    }
});
```

在这个示例中，Interceptor 被用于挂钩目标函数，并在函数执行前和执行后执行自定义的操作。在 onEnter 函数中，函数参数被输出并修改；在 onLeave 函数中，函数的返回值被输出并修改。这些操作允许用户在目标函数的执行过程中进行定制化的修改和监控。

Interceptor 主要用于 native 层函数的挂钩和监视，而 Java implementation 用于在目标应用程序的 Java 层修改方法的行为。两者针对的层级和实现方式有所不同。

#### Interceptor.attach

函数原型是`Interceptor.attach(target, callbacks)`:参数`target`是需要拦截的位置的函数地址，也就是填某个`so`层函数的地址即可对其拦截，`target`是一个`NativePointer`参数，用来指定你想要拦截的函数的地址，`NativePointer`我们也学过是一个指针。

`Interceptor.attach`函数有一些基本了解了~它还包含一些属性 ：


| 索引 | 属性          | 含义                                                                                                                                                                                                    |
| ---- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | returnAddress | 返回地址，类型是`NativePointer`                                                                                                                                                                         |
| 2    | context       | 上下文：具有键`pc`和`sp`的对象，它们是分别为`ia32/x64/arm`指定`EIP/RIP/PC`和`ESP/RSP/SP的NativePointer`对象。其他处理器特定的键也可用，例如`eax、rax、r0、x0`等。也可以通过分配给这些键来更新寄存器值。 |
| 3    | errno         | 当前`errno`值                                                                                                                                                                                           |
| 4    | lastError     | 当前操作系统错误值                                                                                                                                                                                      |
| 5    | threadId      | 操作系统线程ID                                                                                                                                                                                          |
| 6    | depth         | 相对于其他调用的调用深度                                                                                                                                                                                |

```js
Interceptor.attach(Module.findExportByName("libhello.so" , "Java_com_roysue_roysueapplication_hellojni_getSum"), {
            onEnter: function(args) {
                //输出
                console.log('Context information:');
                //输出上下文因其是一个Objection对象，需要它进行接送、转换才能正常看到值
                console.log('Context  : ' + JSON.stringify(this.context));
                //输出返回地址
                console.log('Return   : ' + this.returnAddress);
                //输出线程id
                console.log('ThreadId : ' + this.threadId);
                console.log('Depth    : ' + this.depth);
                console.log('Errornr  : ' + this.err);
            },
            onLeave:function(retval){
            }
        });
```

![img](fridaAPI.assets/t016ac097aac6fd0971.png)

### JAVA

无论是想对`so`层亦或java层进行拦截，都必须编写`Java.perform`

可以使用这个类下的API的前提：Java.available这个函数是用来检测 当前进程process有没有 JVM，例如Dalvik 或者 JRT，只有又相应的 JVM，我们才可以使用　ＪＡＶＡ这个。

Frida 的 Java 模块提供了一系列用于与 Java 层交互的 API，它允许你在目标应用程序的 Java 层执行各种操作，包括调用方法、访问字段、创建对象等。这对于对 Android 应用进行动态分析、修改和调试非常有用。

#### java.available

p判断当前进程时候加在了JavaVM、Dalvik或ART虚拟机

#### Java.androidVersion

显示android版本号

```js
function frida_Java() {
    Java.perform(function () {
        //作为判断用
        if(Java.available)
        {
            //注入的逻辑代码
            console.log("",Java.androidVersion);
        }else{
            //未能正常加载JAVA VM
            console.log("error");
        }
    });
}     
setImmediate(frida_Java,0);

输出如下。
9
因为我的系统版本是9版本~
```

#### java.cast()

> Java.cast(handle, klass)

Java.cast 是 Frida 中用于进行 Java 类型转换的函数，就是将指定变量或者数据强制转换成你所有需要的类型；创建一个 `JavaScript` 包装器，给定从 `Java.use（）` 返回的给定类`klas`的句柄的现有实例。此类包装器还具有用于获取其类的包装器的类属性，以及用于获取其类名的字符串表示的`$className`属性，**通常在拦截`so`层时会使用此函数将`jstring、jarray`等等转换之后查看其值**。

在 Frida 脚本中，Java.cast 的用法如下：

```js
var Activity = Java.use("android.app.Activity");
var activity = Java.cast(ptr("0x1234"), Activity); 
```

- object 是要转换的 Java 对象。
- JavaClass 是要将 object 转换为的 Java 类型。

#### 定义任意数组类型

提供了可以在js代码中定义java数组的`API`，**该数组可以用于传递给java API：**

```js
Java.perform(function () {
        //定义一个int数组、值是1003, 1005, 1007
        var intarr = Java.array('int', [ 1003, 1005, 1007 ]);
        //定义一个byte数组、值是0x48, 0x65, 0x69
        var bytearr = Java.array('byte', [ 0x48, 0x65, 0x69 ]);
        for(var i=0;i<bytearr.length;i++)
        {
            //输出每个byte元素
            console.log(bytearr[i])
        }
});
```

可以支持以下类型：

boolean、byte、char、short、int、long、float、double、void

#### java.registerClass 注册类

js脚本中使用到了Java.registerClass ，这是 Frida 中的一个函数，用于在运行时动态注册一个 Java 类。这个函数允许你在 JavaScript 代码中创建一个 Java 类，并为其指定一些特定的实现，比如实现接口、继承父类等， **返回一个包装器** 。

```javascript
var MyClass = Java.registerClass({
    name: 'com.example.MyClass', // 类的完整路径
    implements: ['java.lang.Runnable'], // 实现的接口，可选
    extends: 'java.lang.Object', // 继承的父类，可选
    methods: {
        myMethod: function() {
            // 自定义方法实现
        }
    }
});

// 举个例子
//获取目标进程的SomeBaseClass类
var SomeBaseClass = Java.use('com.example.SomeBaseClass');
//获取目标进程的X509TrustManager类
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');

var MyWeirdTrustManager = Java.registerClass({
  //注册一个类是进程中的MyWeirdTrustManager类
  name: 'com.example.MyWeirdTrustManager',
  //父类是SomeBaseClass类
  superClass: SomeBaseClass,
  //实现了MyWeirdTrustManager接口类
  implements: [X509TrustManager],
  //类中的属性
  fields: {
    description: 'java.lang.String',
    limit: 'int',
  },
  //定义的方法
  methods: {
    //类的构造函数
    $init: function () {
      console.log('Constructor called');
    },
    //X509TrustManager接口中方法之一，该方法作用是检查客户端的证书
    checkClientTrusted: function (chain, authType) {
      console.log('checkClientTrusted');
    },
    //该方法检查服务器的证书，不信任时。在这里通过自己实现该方法，可以使之信任我们指定的任何证书。在实现该方法时，也可以简单的不做任何处理，即一个空的函数体，由于不会抛出异常，它就会信任任何证书。
    checkServerTrusted: [{
      //返回值类型
      returnType: 'void',
      //参数列表
      argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String'],
      //实现方法
      implementation: function (chain, authType) {
         //输出
        console.log('checkServerTrusted A');
      }
    }, {
      returnType: 'java.util.List',
      argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String', 'java.lang.String'],
      implementation: function (chain, authType, host) {
        console.log('checkServerTrusted B');
        //返回null会信任所有证书
        return null;
      }
    }],
    //　返回受信任的X509证书数组。
    getAcceptedIssuers: function () {
      console.log('getAcceptedIssuers');
      return [];
    },
  }
});
```

TrustManager.$new() 是 Frida 中的语法，用于创建一个 Java 对象的实例。在 Frida 的 JavaScript API 中，$new 方法用于实例化 Java 类的对象。

#### Java.vm对象

`Java.vm`对象十分常用，比如想要拿到`JNI`层的`JNIEnv`对象，可以使用`getEnv()`；我们来看看具体的使用和基本小实例。

```js
function frida_Java() {   
    Java.perform(function () {
         //拦截getStr函数
         Interceptor.attach(Module.findExportByName("libhello.so" , "Java_com_roysue_roysueapplication_hellojni_getStr"), {
            onEnter: function(args) {
                console.log("getStr");
            },
            onLeave:function(retval){
                //它的返回值的是retval 在jni层getStr的返回值的jstring 
                //我们在这里做的事情就是替换掉结果
                //先获取一个Env对象
                var env = Java.vm.getEnv();
                //通过newStringUtf方法构建一个jstirng字符串
                var jstring = env.newStringUtf('roysue');
                //replace替换掉结果
                retval.replace(jstring);
                console.log("getSum方法返回值为:roysue")
            }
    });
}
setImmediate(frida_Java,0);
```

#### Java.$new()实例化对象

首先使用 Java.registerClass或者 Java.use得到相应的java类

> var OkHttpClient = Java.use("com.squareup.okhttp.OkHttpClient");

之后使用TrustManager.$new()即可调用java类的构造函数！！得到相应的实例对象

####`数组 [ ]

js中数组与java的数组是互通的，我们可以使用 var TrustManagers = [TrustManager.$new()];轻易的生成数组类型！！！

#### 函数覆写：

LoginActivity.a.overload('java.lang.String', 'java.lang.String').implementation = function(str, str2) {}

类.方法名.(overload(x,x).).implemention = function(){}

覆写方法中存在this对象，调用函数的实例化对象，我们可以说使用 this.function_name(x,x)调用原函数，从而实现逻辑的正确性。

#### JAVA.AndroidVersion 查看安卓版本

回我们正在运行的安卓版本

#### Java.enumerateLoadedClasses(callbacks)

枚举出已经加载的所有类，参数 callbacks为一个由 onMatch(name, handle)以及 onComplete()组成的object。

- 其中onMatch(name, handle)表示当类加载时以及可能会调用的handle函数，注意，官方说，这个 name可以传给 Java.use从而加载相应的类！！java.use返回 JavaScript wrapper ，即 js类句柄。第二个参数handle就是类的 **句柄**。
- onComplete()表示当所有的类都加载完毕应该做什么

```javascript
Java.perform(function () {
  Java.enumerateLoadedClasses({
    onMatch: function (className, classHandle) {
      console.log('Found class:', className);
    },
    onComplete: function () {
      console.log('Class enumeration complete');
    }
  });
});
```

![img](fridaAPI.assets/t01a8e923dd6208792f.png)

#### java.enumerateLoadedClassesSync()

enumerateLoadedClasses()函数的同步版本，该方法等于是先搜集完所有的类，之后返回一个数组！！！，里面包含了所有类的名字

#### Java.enumerateClassLoaders(callbacks)

该方法枚举出 JVM中所有的 **类加载器**，参数 callbacks,是一个object，包含：

- onMatch(loader): called for each class loader with loader, a wrapper for the specific java.lang.ClassLoader.loader参数是某个ClassLoader类的封装。
- onComplete(): called when all class loaders have been enumerated.

```javascript
Java.enumerateClassLoader(
    {
        onMatch:function(loader){
            console.log("",loader);
        },
        onComplete:function(){
            console.log("end");
        }
    }
)
```

![img](fridaAPI.assets/t01205fe527c316b83e.png)

在Frida中使用 Java.ClassFactory.get() 函数获取特定类加载器，并将其用于 Java.use() 以在指定的类加载器上使用类。

在Java中，类加载器负责加载类到Java虚拟机中。Frida的 Java.ClassFactory.get() 函数允许你获取一个特定的类加载器，然后将该类加载器传递给 Java.use() 方法，使得你可以在特定的类加载器上使用类。

下面是一个示例：

```
javascriptCopy code
var classLoader = Java.ClassFactory.get('com.example.CustomClassLoader');
var MyClass = Java.use('com.example.MyClass', { 'loader': classLoader });

```

`这段代码中，Java.ClassFactory.get() 获取了名为 com.example.CustomClassLoader 的自定义类加载器。然后，Java.use() 方法使用了 com.example.MyClass 这个类，但是指定了一个特定的类加载器 classLoader，以便在这个自定义的类加载器上使用 MyClass 类。`

#### handle 与wrapper

- **Wrapper（包装器）：** 在Frida中，Wrapper是指Frida为目标对象（如Java类或Objective-C类）创建的代理对象。当你使用 Java.use()、ObjC.classes 等函数时，Frida会为目标对象创建一个代理，使你能够通过Frida API直接与目标对象进行交互，例如调用方法、访问属性等。这个代理对象即是所谓的Wrapper。
- **Handle（句柄）：** 在Frida中，Handle通常是指代表对象的引用或标识符。在Java方面，使用 Java.use() 方法获得的对象引用即是类的句柄，允许你在Frida脚本中与Java类进行交互。Handle是一个代表目标对象的标识符，可以让你通过Frida API来操作目标对象。

其实最主要的，warpper是一个包装，得到的哇 wrapper是直接可以在js代码中使用的！！！！，你想想，本来一个java中的对象，你对其包装好就可以直接在js代码中使用，是不是很棒

#### Java.enumerateMethods(query)

枚举出所有匹配query的 method，query参数具体化为 "class!method"。

还可以支持以下后缀：

- `i: Case-insensitive matching.（大小写不敏感）`
- `s: Include method signatures, so e.g. "putInt" becomes "putInt(java.lang.String, int): void".（列出方法的详细信息）`
- `u: User-defined classes only, ignoring system classes.（忽略系统类的方法，只捕获用户类）`

```javascript
Java.perform(() => {
  const groups = Java.enumerateMethods('*youtube*!on*')
  console.log(JSON.stringify(groups, null, 2));
});
```

```json
[
  {
    "loader": "<instance: java.lang.ClassLoader, $className: dalvik.system.PathClassLoader>",
    "classes": [
      {
        "name": "com.google.android.apps.youtube.app.watch.nextgenwatch.ui.NextGenWatchLayout",
        "methods": [
          "onAttachedToWindow",
          "onDetachedFromWindow",
          "onFinishInflate",
          "onInterceptTouchEvent",
          "onLayout",
          "onMeasure",
          "onSizeChanged",
          "onTouchEvent",
          "onViewRemoved"
        ]
      },
      {
        "name": "com.google.android.apps.youtube.app.search.suggest.YouTubeSuggestionProvider",
        "methods": [
          "onCreate"
        ]
      },
      {
        "name": "com.google.android.libraries.youtube.common.ui.YouTubeButton",
        "methods": [
          "onInitializeAccessibilityNodeInfo"
        ]
      },
      …
    ]
  }
]
```

#### Java.scheduleOnMainThread(fn)

在主线程中调用fn函数。

#### Java.perform(fn)

该`API`极其重要，`Java.perform（fn）`主要用于当前线程附加到`Java VM`并且调用`fn`方法。我们来看看示例代码及其含义。

#### Java.use(className)

>  dynamically get a JavaScript wrapper for className that you can instantiate objects from by calling $new() on it to invoke a constructor. Call $dispose() on an instance to clean it up explicitly (or wait for the JavaScript object to get garbage-collected, or script to get unloaded). Static and non-static methods are available, and you can even replace a method implementation and throw an exception from it:

动态加载一个js对java类的封装，即 `javascript wrapper`，我们可以通过调用 $new来实例化对象，或者 $dispose来销毁对象，当然也可以等待`JavaScript`的垃圾回收机制 。当然这个封装wrapper还包含静态以及非静态方法，此外我们还可以更改他们的实现！！！，或者抛出异常！

```javascript
Java.perform(() => {
  const Activity = Java.use('android.app.Activity');
  const Exception = Java.use('java.lang.Exception');
  Activity.onResume.implementation = function () {
    throw Exception.$new('Oh noes!');
  };
});
```

当然上面 java.use方法来加载类使用的使app默认的类加载器，当然我们也可以定制类加载器：

Uses the app’s class loader by default, but you may customize this by assigning a different loader instance to Java.classFactory.loader.

Note that all method wrappers provide a clone(options) API to create a new method wrapper with custom **NativeFunction** options.

#### Java.openClassFile(filePath)

打开 .dex文件，返回一个js对象object，包含以下方法：

- load(): load the contained classes into the VM 加载dex文件中包含的类到 VM中
- getClassNames(): obtain an array of available class names.得到.dex文件中包含的所有类名字的数组

#### Java.choose(className, callbacks)

枚举出所有目前存在的 className的实例对象，本质是通过扫描 java 的 heap，callbacks是一个object包含以下函数：

- onMatch(instance): called with each live instance found with a ready-to-use instance just as if you would have called [Java.cast()](https://frida.re/docs/javascript-api/#java-cast) with a raw handle to this particular instance.

  This function may return the string stop to cancel the enumeration early.
- onComplete(): called when all instances have been enumerated

```js
Java.perform(function () {
    //查找android.view.View类在堆上的实例化对象
    Java.choose("android.view.View", {
        //枚举时调用
        onMatch:function(instance){
            //打印实例
            console.log(instance);
        },
        //枚举完成后调用
        onComplete:function() {
            console.log("end")
        }});
});

输出如下：
android.view.View{2292774 V.ED..... ......ID 0,1794-1080,1920 #1020030 android:id/navigationBarBackground}
android.view.View{d43549d V.ED..... ......ID 0,0-1080,63 #102002f android:id/statusBarBackground}
end
```

#### Java.retain(obj)

Java.retain(obj) 是 Frida 中的一个函数，它的作用是复制 JavaScript 对象 obj 的引用，以便在替换方法之外的地方使用。

在 Frida 脚本中，当你拦截某个方法并在替换方法中处理一个对象时，通常情况下，该对象的引用只在替换方法的上下文中有效。为了在替换方法之外的地方继续使用这个对象，你可以使用 Java.retain(obj) 来创建该对象的另一个引用，这个引用可以在替换方法之外的地方使用。

```javascript
Java.perform(() => {
  const Activity = Java.use('android.app.Activity');
  let lastActivity = null;
  Activity.onResume.implementation = function () {
    lastActivity = Java.retain(this);
    this.onResume();
  };
});
```

#### Java.cast(handle, klass)

这个函数的作用是基于给定的 handle（句柄）和类的引用 klass，创建一个 JavaScript 的包装器（wrapper）。这个句柄（handle）通常是之前使用 Java.use() 获取的对象实例，而 klass 则是该对象所属的类。

具体来说，这个函数的功能是为了让你能够在 Frida JavaScript 中使用一个已有的 Java 对象实例，并为这个实例创建一个新的 JavaScript 包装器，以便在 JavaScript 中对其进行操作和访问。这个新的包装器可以像普通 JavaScript 对象一样进行操作，同时也具有一些特殊属性，如 class 属性用于获取这个对象所属类的包装器，$className 属性用于获取这个对象所属类的类名字符串表示。

举例来说，假设你已经有了一个 Java 对象实例 myInstance，然后你可以使用 Java.cast() 来创建这个实例的 JavaScript 包装器：

```
javascriptCopy code
var MyClass = Java.use('com.example.MyClass');
var myInstance = // 获取到一个对象实例

var myWrapper = Java.cast(myInstance, MyClass);

```

这样，myWrapper 就是 myInstance 对象的一个 JavaScript 包装器，你可以像操作普通 JavaScript 对象一样操作它，同时也能够通过 class 属性获取类的包装器，以及通过 $className 属性获取类名字符串。

#### Java.array(type, elements)

创建一个java中的 数组对象

```java
const values = Java.array('int', [ 1003, 1005, 1007 ]);

const JString = Java.use('java.lang.String');
const str = JString.$new(Java.array('byte', [ 0x48, 0x65, 0x69 ]));
```

好处：得到的对象可以直接传给一些 java 的api参数中！！！

#### `ava.deoptimizeEverything()

强制虚拟机使用其解释器执行所有操作。在某些情况下，有必要防止优化绕过方法挂钩，并允许使用 ART 的 Instrumentation API 来跟踪运行时。

#### java.vm

可以理解成一个内置的对象object，其含有以下方法：

- perform(fn): ensures that the current thread is attached to the VM and calls fn. (This isn’t necessary in callbacks from Java.)确保当前先册灰姑娘被attach到了Vm，并调用fn方法
- getEnv(): gets a wrapper for the current thread’s JNIEnv. Throws an exception if the current thread is not attached to the VM.得到一个当前线程的 JNIEnv ,JNIEnv 是 Java Native Interface（JNI）的一部分，是 Java 虚拟机（JVM）与本地代码（C/C++等）交互的接口。 JNI 允许 Java 代码与本地代码进行交互，让 Java 能够调用本地（Native）方法，并在本地代码中调用 Java 方法。JNIEnv 是 JNI 中最重要的一个接口之一，它提供了一系列函数（方法）来实现 Java 代码与本地代码之间的通信和互操作。

  JNIEnv 接口允许本地代码（如C/C++代码）访问和操作 Java 对象、调用 Java 方法、获取 Java 类型、处理异常等。这个接口的函数允许本地代码与 Java 虚拟机进行交互，从而实现 Java 代码与本地代码的互通。
- tryGetEnv(): tries to get a wrapper for the current thread’s JNIEnv. Returns null if the current thread is not attached to the VM.

#### Java.classFactory

它是用于实现 Java.use() 等功能的默认类工厂，它使用应用程序的主要类加载器（class loader）。

在 Frida 中，Java.classFactory 是一个用于处理 Java 类的工厂函数。当你使用 Java.use() 方法时，Frida 内部会使用 Java.classFactory 创建类的实例，以便在 Frida 脚本中对这些类进行操作。

这也是一个内置object，其含有以下方法：

- get(classLoader): Gets the class factory instance for a given class loader. The default class factory used behind the scenes only interacts with the application’s main class loader. Other class loaders can be discovered through Java.enumerateClassLoaders() and interacted with through this API. 由 classLoader实例对象，返回 classLoader实例
- loader: read-only property providing a wrapper for the class loader currently being used. For the default class factory this is updated by the first call to [Java.perform()](https://frida.re/docs/javascript-api/#java-perform).
- cacheDir: string containing path to cache directory currently being used. For the default class factory this is updated by the first call to [Java.perform()](https://frida.re/docs/javascript-api/#java-perform).
- tempFileNaming: object secifying naming convention to use for temporary files. Defaults to { prefix: 'frida', suffix: 'dat' }.
- use(className): like [Java.use()](https://frida.re/docs/javascript-api/#java-use) but for a specific class loader.
- openClassFile(filePath): like [Java.openClassFile()](https://frida.re/docs/javascript-api/#java-openclassfile) but for a specific class loader.
- choose(className, callbacks): like [Java.choose()](https://frida.re/docs/javascript-api/#java-choose) but for a specific class loader.
- retain(obj): like [Java.retain()](https://frida.re/docs/javascript-api/#java-retain) but for a specific class loader.
- cast(handle, klass): like [Java.cast()](https://frida.re/docs/javascript-api/#java-cast) but for a specific class loader.
- array(type, elements): like [Java.array()](https://frida.re/docs/javascript-api/#java-array) but for a specific class loader.
- registerClass(spec): like [Java.registerClass()](https://frida.re/docs/javascript-api/#java-registerclass) but for a specific class loader.

### Others

#### Console

console.log(line), console.warn(line), console.error(line): 将内容 line 写入到 console of your Frida-based application ，即你应用程序对应的console！！！

- console.log(line): 用于将 line 参数中的内容输出到 Frida-based 应用程序的控制台。它通常用于打印一般的信息或日志，内容将会显示在控制台的标准输出（stdout）位置。
- console.warn(line): 类似于 console.log()，但它用于输出警告信息。警告信息可能表示某些情况下需要注意的内容。这些信息通常会显示在控制台的标准输出（stdout）位置，并以警告的方式标识。**换黄色**
- console.error(line): 用于输出错误信息。这个函数通常用于指示程序中出现的错误情况。输出的内容会显示在控制台的错误输出（stderr）位置，并以错误的方式标识。**红色**

这些输出函数的具体行为取决于 Frida 在**不同集成环境**中的使用方式。例如，在使用 frida-python 时，这些输出会发送到标准输出或标准错误流；在使用 frida-qml 时，这些输出可能会发送到 qDebug 中。

#### hexdump

hexdump(target[, options])
用于生成来自指定的 ArrayBuffer 或 NativePointer 的十六进制转储（hexdump），并且可以使用选项定制输出格式。打印内存中的地址的内容；

- target: 可以是一个 ArrayBuffer 或 NativePointer，代表了要生成十六进制转储的目标数据。ArrayBuffer 是 JavaScript 中表示二进制数据的一种类型，而 NativePointer 则是 Frida 中用于表示原生指针的类型。
- options（可选参数）: 用于自定义输出格式的选项。这些选项可以是一个对象，允许你指定输出格式的不同设置，例如显示的偏移量、每行显示的字节数、是否显示ASCII 码等。

这个函数的作用是将目标数据以十六进制的方式转储出来，以便进行分析或调试。它可以帮助你在开发或逆向工程中查看二进制数据的内容，并以可读的格式显示出来，包括十六进制表示和对应的 ASCII 字符。这对于分析二进制数据结构、调试内存内容等非常有用。通过选项，你可以调整输出的格式以满足你的需求。

```js
const libc = Module.findBaseAddress('libc.so');
console.log(hexdump(libc, {
  offset: 0,
  length: 64,
  header: true,
  ansi: true
}));

or

var libc = Module.findBaseAddress('libc.so');
console.log(hexdump(libc, {
  offset: 0,
  length: 64,
  header: true,
  ansi: true
}));
           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
00000000  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010  03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00  ..(.........4...
00000020  34 a8 04 00 00 00 00 05 34 00 20 00 08 00 28 00  4.......4. ...(.
00000030  1e 00 1d 00 06 00 00 00 34 00 00 00 34 00 00 00  ........4...4...
```

`![1700478683269](frida脚本学习.assets/1700478683269.png)`

#### Shorthand

- `int64(v): short-hand for [new Int64(v)](https://frida.re/docs/javascript-api/#int64)`
- `uint64(v): short-hand for [new UInt64(v)](https://frida.re/docs/javascript-api/#uint64)`
- `ptr(s): short-hand for [new NativePointer(s)](https://frida.re/docs/javascript-api/#nativepointer)`
- `NULL: short-hand for ptr("0")`

#### host与hook application通信

##### recv([type, ]callback):

- recv 用于请求在下一条从 Frida-based 应用程序接收到的消息时调用指定的回调函数 callback。
- 可以选择性地指定消息的类型 type，以便只接收其中 type 字段被设置为指定类型的消息。
- 这个函数仅会获取一条消息，所以如果需要接收下一条消息，需要再次调用 recv()。

##### send(message[, data]):

- send 用于将 JavaScript 对象 message 发送到 Frida-based 应用程序（该对象必须可以序列化为 JSON）。
- 如果你还有一些原始的二进制数据需要发送，例如使用 NativePointer#readByteArray 从内存中获取了一些二进制数据，那么可以通过可选参数 data 将这些数据发送出去。
- data 必须是一个 ArrayBuffer 或一个介于 0 和 255 之间的整数数组。这样做是为了使 Frida 能够处理原始的二进制数据。

send是在python层定义的on_message回调函数，jscode内所有的信息都被监控script.on('message', on_message)，当输出信息的时候on_message函数会拿到其数据再通过format转换， 其最重要的功能也是最核心的是能够直接将数据以json格式输出，当然数据是二进制的时候也依然是可以使用send，十分方便，我们来看代码1-2示例以及执行效果。

```python
# -*- coding: utf-8 -*-
import frida
import sys

def on_message(message, data):
    if message['type'] == 'send':
        print("[*] {0}".format(message['payload']))
    else:
        print(message)

jscode = """
    Java.perform(function () 
    {
        var jni_env = Java.vm.getEnv();
        console.log(jni_env);
        send(jni_env);
    });
 """

process = frida.get_usb_device().attach('com.roysue.roysueapplication')
script = process.create_script(jscode)
script.on('message', on_message)
script.load()
sys.stdin.read()

运行脚本效果如下：

roysue@ubuntu:~/Desktop/Chap09$ python Chap03.py 
[object Object]
[*] {'handle': '0xdf4f8000', 'vm': {}}
```

可以看出这里两种方式输出的不同的效果，console直接输出了[object Object]，无法输出其正常的内容，因为jni_env实际上是一个对象，但是使用send的时候会自动将对象转json格式输出。通过对比，我们就知道send的好处啦

这两个函数允许在 Frida-based 应用程序和 Frida 脚本之间进行双向通信。recv() 用于接收来自应用程序的消息并在收到消息时触发回调函数，而 send() 则用于向应用程序发送消息。这种通信机制在进行动态分析和修改时非常有用，可以让 Frida 脚本与目标应用程序之间进行交互。

##### rpc.export

rpc.exports 是一个空对象，你可以将其替换或插入，以便向你的应用程序暴露一个基于 RPC（远程过程调用）风格的 API。通过在 rpc.exports 对象中指定键值对，你可以定义方法名和对应的导出函数。这些导出的函数可以被外部调用，就像远程调用一样。

- **Key（键）**: 指定了远程调用方法的名称，即你想要暴露给应用程序的函数名。
- **Value（值）**: 对应的是你所导出的函数，这个函数可以是同步的也可以是异步的。如果这个函数是同步的，它可以直接返回一个值给调用者。如果是异步的，它可以返回一个 Promise 对象，允许在异步操作完成后返回结果给调用者。

通过这种方式，你可以在 Frida 脚本中定义一组函数，并将其作为远程 API 暴露给目标应用程序。目标应用程序可以调用这些函数，与 Frida 脚本进行交互，进行各种操作和数据传输。这种机制对于远程控制或与目标应用程序交互非常有用。

#### frida集成环境

Frida 是一个功能强大的框架，可以与多种环境集成，主要包括以下几种：

1. **frida-server 和 frida-client：** 这是 Frida 最基本的使用方式，它允许你在设备上注入 Frida 脚本，控制并监视本地或远程应用程序的执行。frida-server 在目标设备上运行，frida-client 则是与 frida-server 通信的工具。
2. **frida-python：** Frida 提供了 Python 绑定，允许你通过 Python 编写和运行 Frida 脚本。这种集成方式使得使用 Frida 的**脚本化和自动化变得更加方便**。
3. **frida-node：** Frida 也提供了对 Node.js 的支持，允许你通过 Node.js 编写和运行 Frida 脚本。这种集成方式对于 Node.js 生态系统的开发者非常友好。
4. **frida-repl：** Frida 提供了一个交互式的命令行工具，称为 Frida REPL（Read-Eval-Print Loop），允许你直接在命令行中执行 Frida 脚本和命令，用于快速的调试和探索。
5. **frida-gadget：** Frida Gadget 是一个内嵌到应用程序中的小型库，用于允许动态注入 Frida 脚本到本地应用程序中，以便于进行调试和分析。
6. #### **frida-qml：** Frida 提供了对 QML 的支持，允许你在 Qt Quick 应用程序中使用 Frida 进行调试。
7. **frida-core：** Frida Core 是 Frida 的核心库，它可以作为一个库嵌入到其他应用或环境中，以便与 Frida 进行集成。

每种集成环境都有其独特的特点和优势，可以根据具体的使用场景和需求选择适合的集成方式。通过这些集成方式，Frida 可以在不同的环境中进行动态注入和执行代码，从而实现对应用程序的监视、分析和修改。
