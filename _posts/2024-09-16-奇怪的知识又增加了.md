---

title: 奇怪的知识又增加了
date: 2024-09-16 11:00:00 +0800
categories: [Mixed Knowledge]
tags: [Mixed Knowledge]

---

## Typora配置

主要参考博客：https://blog.csdn.net/qq_39921135/article/details/136278309#:~:text=PicGo+gith

https://blog.musnow.top/posts/373497921/index.html#:~:text=%E8%AF%B4%E7%99%BD%E4%BA%86%E5%B0%B1%E6%98%AF%EF%BC%8C%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA



最主要的就是配置typora图床，我在网上看了很多免费的图床，但是感觉懒得搞了，不如自己的github仓库来的方便（就是访问的时候得挂代理这一点麻烦点），但是无所谓了，总感觉自己的才是最好的。

首先就是把图像保存的设置搞一下，这样每次在typora中插入图片就会自动上传到GitHub仓库并更换图片路径；

1、创建github仓库，并获取一个token

2、下载[picgo](https://github.com/Molunerfinn/PicGo/releases)软件, 并配置图床

3、简单配置一下picgo，安装一个 rename-file插件，注意：一定要用管理员启动picgo才能安装,配置为{y}-{m}-{hash}，还要这么搞![image-20241007002911777](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-4f785ffc2892f1c1caa2b1a1a724c039.png)

4、配置typora：![image-20241007003007276](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-d3e119adbc81169070c1086331367a82.png)



当然如图我们使用了`pig-go`这个技术，因此我们还需要进行相应的配置才行，我个人的配置文件如下：

```json
{
  "picBed": {
    "github": {
      "repo": "mikeaaaaaa/cloudimg",
      "token": "自己在github中生成",
      "path": "img/",
      "customUrl": "",
      "branch": "main"
    },
    "current": "github",
    "uploader": "github"
  },
  "picgoPlugins": {
    "picgo-plugin-super-prefix": true
  },
  "picgo-plugin-super-prefix": {
    "prefixFormat": "YYYY/MM/DD/",
    "fileFormat": "YYYYMMDD-HHmmss"
  }
}

```

看到我还学着网上使用了一个插件，这个插件需要使用nodejs的npm进行安装 `npm install picgo-plugin-super-prefix`；

当然还有最后一件事情，每次图片上传都会进行一次图片暂存，过一段时间我们最好将图片手动删除掉，路径如下：

>  `C:\Users\xxx\AppData\Roaming\Typora\typora-user-images`



## openapi-generator使用

由于902项目需要使用 openapi来生成部分代码，因此需要学习相关知识；

首先准备好`api.yml`文件，其次准备好 `config.yml`文件，这里仅仅展示一下`config.yml`文件：

```yml
useSpringBoot3: true          # 指定使用 Spring Boot 3 版本进行生成，确保生成的代码与 Spring Boot 3 的框架和特性兼容。

delegatePattern: true          # 启用委托模式 (Delegate Pattern)，生成的 API 实现会通过委托类来处理业务逻辑，使得控制器更轻量，关注点分离。

groupId: com.example           # Maven 项目的 groupId，标识生成项目的组织或公司，通常采用域名的反向形式。

artifactId: XA902-API          # Maven 项目的 artifactId，这是项目的名称，表示生成的 API 项目的唯一标识符。

artifactVersion: 1.0.0         # 项目的版本号，标识生成的 API 项目版本。

basePackage: com.example.xa902 # 指定基础包名，所有生成的代码都将位于该基础包名下。

apiPackage: com.example.xa902.api # 指定 API 接口所在的包名，API 接口是生成的服务端接口类，用于定义 HTTP 路由。

configPackage: com.example.xa902.config # 指定配置类所在的包名，所有生成的配置类将会放置在这个包名下。

invokerPackage: com.example.xa902.api # 指定调用相关类（例如 API 客户端）的包名。

modelPackage: com.example.xa902.model # 指定模型类所在的包名，所有生成的实体模型（如 DTO 类）将放置

```

最终生成项目目录结构如下：

```xml
XA902-API/
├── pom.xml                             # Maven 项目配置文件，包含依赖、插件、版本等信息
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── xa902/
│   │   │               ├── api/
│   │   │               │   ├── ApiDelegate.java        # 委托接口或类，处理 API 实现逻辑
│   │   │               │   ├── SomeApiController.java  # API 控制器类，定义路由和请求映射
│   │   │               │   └── ...                     # 其他 API 类
│   │   │               ├── config/
│   │   │               │   ├── SwaggerConfig.java      # Swagger 配置类，用于 API 文档生成
│   │   │               │   └── ...                     # 其他配置类
│   │   │               ├── model/
│   │   │               │   ├── SomeRequest.java        # 数据模型类，例如请求或响应的 DTO
│   │   │               │   └── SomeResponse.java
│   │   │               └── ...                         # 其他逻辑类
│   │   └── resources/
│   │       ├── application.properties                  # Spring Boot 配置文件
│   │       └── ...                                     # 其他资源文件
│   └── test/
│       └── java/                                       # 测试类目录

```

在API目录下，通常由一下类型文件：

1、API接口类文件：

```java
public interface ExampleApi {
    ResponseEntity<Void> createExample(ExampleRequest exampleRequest);
}
```

这是基于 OpenAPI 规范生成的接口，定义了 API 的各个操作方法。它包括一些方法签名，通常用作 HTTP 请求处理的定义，如 `GET`、`POST`、`PUT`、`DELETE` 等操作。这些方法与 OpenAPI 中描述的路径、请求参数、响应体等相关联。

2、APi控制器类（ApiController.java）

这个类通常会实现前述生成的 API 接口类，并且通过 `@RestController` 注解作为一个实际处理 HTTP 请求的控制器。它包含各个 API 方法的具体实现，比如如何处理传入的参数、如何调用服务层逻辑、如何构建响应等。**作用**：负责根据传入的 HTTP 请求，调用相关的业务逻辑，并返回适当的响应。它是 API 请求的实际入口点。

```java
@RestController
@RequestMapping("/api")
public class ExampleApiController implements ExampleApi {
    @Override
    public ResponseEntity<Void> createExample(ExampleRequest exampleRequest) {
        // 实现创建操作
        return new ResponseEntity<>(HttpStatus.CREATED);
    }
}
```



3、Api委托类（ApiDelegate.java）

如果启用了 `delegatePattern: true`，会生成一个委托接口，通常以 `Delegate` 后缀命名。这个类负责将实际的业务逻辑与控制器分离开。`ApiController` 将调用这个委托类来处理具体的业务逻辑，而控制器本身只专注于请求和响应的处理。**作用**：进一步解耦业务逻辑，使得控制器类更轻量。实际的业务逻辑实现会放在委托类中，从而实现逻辑分离和代码的可测试性。

```java
public interface ExampleApiDelegate {
    void createExample(ExampleRequest exampleRequest);
}
```



4、实现类（ApiDelegateTmpl.java）

这个实现类通常需要我们自己实现；

这是委托模式中的具体实现类，实现了 `ApiDelegate` 中的方法。它负责执行实际的业务逻辑，如调用数据库、第三方服务等。**作用**：具体执行业务逻辑，可以独立于控制器实现，以便于扩展和维护。

```java
@Service
public class ExampleApiDelegateImpl implements ExampleApiDelegate {
    @Override
    public void createExample(ExampleRequest exampleRequest) {
        // 实现具体的业务逻辑，如数据库操作
    }
}

```

在`model`目录下，主要包含与 API 交互的 **数据模型类**，通常是 **DTO（数据传输对象）**。这些类的作用是封装 API 请求和响应的数据结构，以便在应用程序内部传递和处理数据。

1、请求类（XXRequest.java）

**作用**：用于表示客户端发送给服务器的请求数据。请求类通常封装表单数据、JSON 请求体等，便于服务器接收并处理这些数据。

```java
public class UserRequest {
    private String username;
    private String email;
    // getters and setters
}
```



2、响应类（XXResponse.java）

**作用**：用于表示服务器返回给客户端的响应数据。响应类通常封装服务器处理请求后的结果，如操作是否成功、返回的对象或状态信息。

```java
public class UserResponse {
    private Long id;
    private String username;
    private String email;
    private String status;
    // getters and setters
}
```

3、实体类（Entity Classes）

在某些情况下，`model` 模块也可能包含与数据库表结构对应的实体类。这些类用来映射数据库表中的字段，并在业务逻辑中传递数据。

```java
public class Product {
    private Long id;
    private String name;
    private BigDecimal price;
    // getters and setters
}

```

这些类可以在不同层之间传递数据，并用于 CRUD 操作。

4、枚举类

**作用**：用于定义一些常量或预定义的值。例如，在某些 API 中，可能会有固定的状态字段，枚举类用来约束这些状态的取值。

```java
public enum Status {
    ACTIVE, INACTIVE, PENDING
}

```





















