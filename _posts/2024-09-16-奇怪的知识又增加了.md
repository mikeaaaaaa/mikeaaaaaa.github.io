---

title: 奇怪的知识又增加了
date: 2024-09-16 11:00:00 +0800
categories: [Mixed Knowledge]
tags: [Mixed Knowledge]
 
---

# 奇怪的知识

## Typora配置

### 图床

主要参考博客：https://blog.csdn.net/qq_39921135/article/details/136278309#:~:text=PicGo+gith

https://blog.musnow.top/posts/373497921/index.html#:~:text=%E8%AF%B4%E7%99%BD%E4%BA%86%E5%B0%B1%E6%98%AF%EF%BC%8C%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA



最主要的就是配置typora图床，我在网上看了很多免费的图床，但是感觉懒得搞了，不如自己的github仓库来的方便（就是访问的时候得挂代理这一点麻烦点），但是无所谓了，总感觉自己的才是最好的。

首先就是把图像保存的设置搞一下，这样每次在typora中插入图片就会自动上传到GitHub仓库并更换图片路径；

1、创建github仓库，并获取一个token

2、下载[picgo](https://github.com/Molunerfinn/PicGo/releases)软件, 并配置图床

3、简单配置一下picgo，安装一个 rename-file插件，注意：一定要用管理员启动picgo才能安装,配置为{y}-{m}-{hash}，还要这么搞![image-20241007002911777](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-4f785ffc2892f1c1caa2b1a1a724c039.png)

4、配置typora：![image-20241007003007276](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-d3e119adbc81169070c1086331367a82.png)



当然如图我们使用了`pig-go`这个技术，因此我们还需要进行相应的配置才行，我个人的配置文件如下：

```json
{
  "picBed": {
    "github": {
      "repo": "mikeaaaaaa/cloudimg",
      "token": "自己在github中生成",
      "path": "img/",
      "customUrl": "",
      "branch": "main"
    },
    "current": "github",
    "uploader": "github"
  },
  "picgoPlugins": {
    "picgo-plugin-super-prefix": true
  },
  "picgo-plugin-super-prefix": {
    "prefixFormat": "YYYY/MM/DD/",
    "fileFormat": "YYYYMMDD-HHmmss"
  }
}

```

看到我还学着网上使用了一个插件，这个插件需要使用nodejs的npm进行安装 `npm install picgo-plugin-super-prefix`；

当然还有最后一件事情，每次图片上传都会进行一次图片暂存，过一段时间我们最好将图片手动删除掉，路径如下：

>  `C:\Users\xxx\AppData\Roaming\Typora\typora-user-images`

### 自动标号

主题相关，个人比较喜欢的主题就是：https://github.com/liangjingkanji/DrakeTyporaTheme的`Dark julin`，只需要将所有文件都放置到theme文件夹中即可；还有就是自动增加标题：这个参照https://www.cnblogs.com/davad/p/15265927.html所说，只需要在theme文件夹中创建一个 `base.user.css`文件即可，内容为博主所说；

## openapi-generator使用

由于902项目需要使用 openapi来生成部分代码，因此需要学习相关知识；

首先准备好`api.yml`文件，其次准备好 `config.yml`文件，这里仅仅展示一下`config.yml`文件：

```yml
useSpringBoot3: true          # 指定使用 Spring Boot 3 版本进行生成，确保生成的代码与 Spring Boot 3 的框架和特性兼容。

delegatePattern: true          # 启用委托模式 (Delegate Pattern)，生成的 API 实现会通过委托类来处理业务逻辑，使得控制器更轻量，关注点分离。

groupId: com.example           # Maven 项目的 groupId，标识生成项目的组织或公司，通常采用域名的反向形式。

artifactId: XA902-API          # Maven 项目的 artifactId，这是项目的名称，表示生成的 API 项目的唯一标识符。

artifactVersion: 1.0.0         # 项目的版本号，标识生成的 API 项目版本。

basePackage: com.example.xa902 # 指定基础包名，所有生成的代码都将位于该基础包名下。

apiPackage: com.example.xa902.api # 指定 API 接口所在的包名，API 接口是生成的服务端接口类，用于定义 HTTP 路由。

configPackage: com.example.xa902.config # 指定配置类所在的包名，所有生成的配置类将会放置在这个包名下。

invokerPackage: com.example.xa902.api # 指定调用相关类（例如 API 客户端）的包名。

modelPackage: com.example.xa902.model # 指定模型类所在的包名，所有生成的实体模型（如 DTO 类）将放置

```

最终生成项目目录结构如下：

```xml
XA902-API/
├── pom.xml                             # Maven 项目配置文件，包含依赖、插件、版本等信息
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── xa902/
│   │   │               ├── api/
│   │   │               │   ├── ApiDelegate.java        # 委托接口或类，处理 API 实现逻辑
│   │   │               │   ├── SomeApiController.java  # API 控制器类，定义路由和请求映射
│   │   │               │   └── ...                     # 其他 API 类
│   │   │               ├── config/
│   │   │               │   ├── SwaggerConfig.java      # Swagger 配置类，用于 API 文档生成
│   │   │               │   └── ...                     # 其他配置类
│   │   │               ├── model/
│   │   │               │   ├── SomeRequest.java        # 数据模型类，例如请求或响应的 DTO
│   │   │               │   └── SomeResponse.java
│   │   │               └── ...                         # 其他逻辑类
│   │   └── resources/
│   │       ├── application.properties                  # Spring Boot 配置文件
│   │       └── ...                                     # 其他资源文件
│   └── test/
│       └── java/                                       # 测试类目录

```

在API目录下，通常由一下类型文件：

1、API接口类文件：

```java
public interface ExampleApi {
    ResponseEntity<Void> createExample(ExampleRequest exampleRequest);
}
```

这是基于 OpenAPI 规范生成的接口，定义了 API 的各个操作方法。它包括一些方法签名，通常用作 HTTP 请求处理的定义，如 `GET`、`POST`、`PUT`、`DELETE` 等操作。这些方法与 OpenAPI 中描述的路径、请求参数、响应体等相关联。

2、APi控制器类（ApiController.java）

这个类通常会实现前述生成的 API 接口类，并且通过 `@RestController` 注解作为一个实际处理 HTTP 请求的控制器。它包含各个 API 方法的具体实现，比如如何处理传入的参数、如何调用服务层逻辑、如何构建响应等。**作用**：负责根据传入的 HTTP 请求，调用相关的业务逻辑，并返回适当的响应。它是 API 请求的实际入口点。

```java
@RestController
@RequestMapping("/api")
public class ExampleApiController implements ExampleApi {
    @Override
    public ResponseEntity<Void> createExample(ExampleRequest exampleRequest) {
        // 实现创建操作
        return new ResponseEntity<>(HttpStatus.CREATED);
    }
}
```



3、Api委托类（ApiDelegate.java）

如果启用了 `delegatePattern: true`，会生成一个委托接口，通常以 `Delegate` 后缀命名。这个类负责将实际的业务逻辑与控制器分离开。`ApiController` 将调用这个委托类来处理具体的业务逻辑，而控制器本身只专注于请求和响应的处理。**作用**：进一步解耦业务逻辑，使得控制器类更轻量。实际的业务逻辑实现会放在委托类中，从而实现逻辑分离和代码的可测试性。

```java
public interface ExampleApiDelegate {
    void createExample(ExampleRequest exampleRequest);
}
```



4、实现类（ApiDelegateTmpl.java）

这个实现类通常需要我们自己实现；

这是委托模式中的具体实现类，实现了 `ApiDelegate` 中的方法。它负责执行实际的业务逻辑，如调用数据库、第三方服务等。**作用**：具体执行业务逻辑，可以独立于控制器实现，以便于扩展和维护。

```java
@Service
public class ExampleApiDelegateImpl implements ExampleApiDelegate {
    @Override
    public void createExample(ExampleRequest exampleRequest) {
        // 实现具体的业务逻辑，如数据库操作
    }
}

```

在`model`目录下，主要包含与 API 交互的 **数据模型类**，通常是 **DTO（数据传输对象）**。这些类的作用是封装 API 请求和响应的数据结构，以便在应用程序内部传递和处理数据。

1、请求类（XXRequest.java）

**作用**：用于表示客户端发送给服务器的请求数据。请求类通常封装表单数据、JSON 请求体等，便于服务器接收并处理这些数据。

```java
public class UserRequest {
    private String username;
    private String email;
    // getters and setters
}
```



2、响应类（XXResponse.java）

**作用**：用于表示服务器返回给客户端的响应数据。响应类通常封装服务器处理请求后的结果，如操作是否成功、返回的对象或状态信息。

```java
public class UserResponse {
    private Long id;
    private String username;
    private String email;
    private String status;
    // getters and setters
}
```

3、实体类（Entity Classes）

在某些情况下，`model` 模块也可能包含与数据库表结构对应的实体类。这些类用来映射数据库表中的字段，并在业务逻辑中传递数据。

```java
public class Product {
    private Long id;
    private String name;
    private BigDecimal price;
    // getters and setters
}

```

这些类可以在不同层之间传递数据，并用于 CRUD 操作。

4、枚举类

**作用**：用于定义一些常量或预定义的值。例如，在某些 API 中，可能会有固定的状态字段，枚举类用来约束这些状态的取值。

```java
public enum Status {
    ACTIVE, INACTIVE, PENDING
}

```







## ubuntu Docker安装

基本的安装其实没什么好讲的，就是按照一般的步骤执行即可：

https://www.cnblogs.com/carmi/p/17939025

但是我们安装完了还不算完事儿，因为默认的docker配置是从docker官方获取镜像，因此我们还得配置`mirror`，这里也有非常多的坑，又非常的多的公开的`docker`镜像网站其实都关闭了，我们要想使用还得配置我们自己的`mirror`，比较靠谱一点的就是去 华为云官方申请一个自己的免费`mirror`；

但是问题又来了，在`mirror`镜像中某些image还是找不到的，最后还得去docker官方去寻找，这就非常麻烦了，最后没办法，只能配置代理了；

由于Server没有UI，因此直接安装clash还是非常麻烦的，我选择的是使用`proxychain4`配置我的电脑主机作为流量代理，在命令行中使用 proxychains4 sudo docker pull 命令来获取images，但是问题又来了，直接使用是是用不了代理的；这涉及到docker的原理，我们在命令行中的一切docker命令其实都是与 一个称之为 `docker daemon`守护进程的一个东西，交互，并不是直接与 docker 官方进行交互，因此我们如果要配置代理，我们需要为这个`daemon`守护进程配置代理，配置的方法如下：

https://blog.csdn.net/qq_22903841/article/details/123106604

除了docker，containerd也是一样，也需要配置代理：

https://blog.csdn.net/u010589700/article/details/139958293

最后添加一个一键安装的脚本：

```bash
curl -fsSL https://get.docker.com | sudo sh -s -- --mirror Aliyun
sudo usermod -aG docker $USER
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m"
  },
  "storage-driver": "overlay2",
  "registry-mirrors": ["https://t9ab0rkd.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

## ubuntu DNS

首先我们了解一下ubuntu中常用的一些网络命令：

1. ip  a
2. nslookup baidu.com // 用来查看dns解析
3. curl -I www.baidu.com // 查看当前网络状况，只发送一个Head请求
4. curl -I -v www.baidu.com // 查看具体详细情况
5. route -n :查看网络路由情况



现在我们说明一下ubuntu中的网络问题；

首先DNS的配置是在 /etc/resolv.conf，我们在文件中加上一个`nameserver`字段即可配置DNS，但是不行，这样的生效只是一次性的，并不是永久的，我么你在这个文件的开头可以看到这样的几句话：

![image-20241110205037037](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-94a3ef3ba338ea2a6d58551acc3bd1b5.png)

写的以及非常清楚了，只是我们没看罢了，这个文件并不是我们管理的，而是一个叫做 `systemd-resolved`的服务所管理的；

因此我们只需要更改 这个服务的配置文件就行了，具体怎么改可以查；

但是，问题又来了，我配置完了发现还不行，配置完了使用 `resolvectl status`命令后发现确实有了全局的dns配置，但是我这张网卡的配置貌似并没有使用全局（可能是我没有重启网络服务），最后实在没办法了，只能使用 `netplan`方法来配置一个静态ip，这样不管是网关还是DNS都可以自定义！！！

具体方法如下：修改/ect/netplan/xxx.yaml文件即可：

![image-20241110210832931](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-3dbb2ef345d0cfc90a9bcbbc14016dda.png)

之后使用： netplan apply方法即可生效！！！

但是`wait`，看看上一张截图的最上方的文字！！！！，他说这个文件每次重启都会重置！！！！还是不行！！！

> 答案揭晓

最后在一片文章中找到了答案https://blog.csdn.net/qifei717/article/details/124974384

其实就是systemd-resolved的问题，并且不仅仅是我们改了文件，重启服务就行，我们还需要执行几条命令才可以：

![image-20241110211906142](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-5e57417fb1c99db418a27905fe10dbae.png)

```java
sudo mv /etc/resolv.conf  /etc/resolv.conf.bak
sudo ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf
```



### apt源更新失败

![image-20241111110356142](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-57df6814c3f686f92816185a1f400e24.png)

https://github.com/cli/cli/issues/8550

使用 `sudo hwclock -s`命令即可；

设置RTC硬件时钟为本地时区

时区问题？



### 奇怪的docker-compose

首先就是我们使用docker-compose创建容器后不要着急，有些容器还需要等一会儿才能完全启动起来！！！

还有一共由俩命令：docker-compose` 和 `docker compose

docker-compose：是一个独立的 Python 应用程序，需要单独安装，易于安装，适合早期 Docker 用户。可以在老版本 Docker 环境中运行。

docker compose：是 Docker CLI（命令行工具）的一部分，从 Docker 版本 **20.10.0+** 开始支持，无需单独安装，默认集成到 Docker CLI，性能更好，适合生产环境使用。

![image-20241112212636849](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-099c4e8ec679fec64c57df8892b2cc3c.png)



### github 搜索

其实最主要的还是根据官网的学习https://docs.github.com/zh

<img src="https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-ba8f09898666e55be70b2769acd1aece.png" alt="image-20241113212728843" style="zoom:67%;" />

对于平时的搜索，我们一般会根据 最匹配、最多 Star 来进行排序、选择相应的语言、选择仓库或者代码来进行筛选，如下图：

<img src="https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-f6ca529f628f5b411fdbe20869c9e44c.png" alt="image-20241113211046258" style="zoom: 50%;" />

会使用这些以及很棒了，但是还不够，还有更多高级的搜索方法；



数值筛选：

![image-20241113211615139](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-e2d1179a6002b5cea9604ea850af3160.png)

日期筛选：

![image-20241113211643162](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-14ecface452aa8f26655b860f799efd9.png)

按照仓库名称、说明description、自述文件readme内容搜索：

![image-20241113211837365](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-2a576419220911bb7bceb9cc224fce60.png)

### docker相关

最近在使用docker尝试配置一些高可用集群，过程中遇到了一些问题，就是现在的docker如果使用的是桥接 bridget网络，则在容器内是直接可以ping通主机的，也就是说可以直接使用主机的IP，这位我们的配置提供了极大的便利；

这样我们就可以轻松的在一个docker子网中通过主机的端口映射轻松的使用到其他docker子网中提供的服务；

但是这也是有条件的，当把端口映射到主机时，只有将ufw防火墙的相关接口打开，我们在其他docker子网中才能根据主机IP访问到响应的服务！！！ **记得关闭或者设置防火墙**
