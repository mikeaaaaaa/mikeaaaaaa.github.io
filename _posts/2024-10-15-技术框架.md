---

---

# 技术框架



## RabbitMQ

rabbitmq是一种实现了 **高级消息队列协议（AMQP）**的**开源消息队列服务软件**又可以称之为面向消息的中间件；

### 整体框架

整体框架图：

![Different Exchange Types in RabbitMQ | by Binod Mahto | Medium](https://miro.medium.com/v2/resize:fit:886/1*UWsV79zkqd5NEkzr6uP2CA.png)

想要搞懂`RabbitMQ`，我们只需要搞清其中的几个概念即可；

### 各个组件

#### Message

RabbitMQ中的消息通常由两个部分组成：

1. 消息头：消息的元数据，包含消息以外的额外信息，包括 消息的优先级、持久化标记、路由键（routingKey）、消息ID等
2. 消息体：实际的数据载荷，可以是文本、json、xml、二进制等数据；

声明周期如下：

1. 生产者创建消息，设置消息头、消息体。在发送消息时指定 交换机与路由键；
2. 到达交换机后，更具**交换机的种类**以及**路由键**和**绑定键**这三者去顶发往哪个队列
3. 消费者从队列中消费消息，在处理完消息后选择 “Acknowledge”消息，告诉RabbitMQ这条消息处理完毕。若未确定或者消费者处理失败，这条消息会被重新投递。

消息头可以存放的一些属性：

1. content_type：描述消息内容的MIME类型，如 `application/json`、`text/plain`等
2. delivery_mode: 表示消息的吃捷星，1表示非持久消息，2表示持久消息
3. priority:指定消息的优先级，高优先级的消息会被优先消费
4. message_id: 唯一表示消息的ID

#### Exchange

**Exchange（交换机）**是消息路由的核心组件，负责将来自生产者的消息分发到相应的队列（Queue）中。生产者将消息发送到交换机，交换机根据配置的路由规则决定消息应该发送到哪些队列。

我们首先得知道 Exchange 是需要与 Queue进行绑定的，一个交换机可以绑定多个队列，并且在绑定的时候可以指定绑定键（**binding-key**），绑定键在 直连交换机与主题交换机中起作用；

主要介绍三种常用的交换机：

1. Direct Exchange（直连交换机）

这种交换机会将消息路由到**路由键（Routing Key）**与绑定键（Binding Key）完全匹配的队列中。适用于需要精确匹配的场景。

1. Fanout Exchange （扇出交换机）

扇出交换机会将消息发送给所有与之绑定的队列，**忽略路由键**。适用于**广播消息**的场景。

1. Topic Exchange （主题交换机）

这种交换机会根据**路由键的模式**进行路由。它支持模糊匹配，用`.`分隔的路由键可以进行匹配操作，`*`匹配一个单词，`#`匹配零个或多个单词。



当然Exchange自身也会有各种属性：

name：交换机名字

type：交换机类型

Durable：交换机是否持久化到磁盘，即重启后还在不在

#### Queue

负责暂存来自交换机的消息，直到消费者（Consumer）处理这些消息。队列可以看作是消息的中转站，生产者将消息发送到交换机，交换机再将消息路由到队列中，而消费者则从队列中获取并处理消息。

消息进入到队列中后，会根据队列的配置决定消息的存储方式，持久化或者非持久化（注意消息具体是否持久化不仅要设置队列，还要求消息的持久化属性为2）；消费者订阅队列，从队列中接收消息，RabbitMQ支持多种消费模式，例如 消息先进先被消费、优先级消费（优先级高的消息先被消费）等；当然消息队列还能设置最大长度、为每个消息设置TTL等；

在RabbitMQ中，**消费者并不是主动拉取（pull）消息**，而是**服务器将消息推送（push）给消费者**。RabbitMQ通过消费者与队列的绑定关系，将消息自动从队列中推送给消费者。

#### Channel

**Channel（通道）*是生产者和消费者与RabbitMQ服务器进行通信的逻辑连接。它是在与RabbitMQ服务器建立的\**TCP连接**之上的虚拟连接。由于RabbitMQ使用了基于AMQP协议的消息队列机制，通道是客户端发送或接收消息的最基本API机制。

设置Channel的原因：由于每次都要重新建立TCP连接非常浪费资源，因此决定复用某个TCP连接，即在TCP连接之上抽象出一层 Channel，这样就可以在TCP连接之上建立多个通道；创建与销毁更加高效，更轻量；具有独立性，这样一个客户端就可以在一个TCP上执行并发操作（生产消息、消费消息）

```python
import pika

# 连接到RabbitMQ服务器
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 声明一个队列，确保消息队列存在
channel.queue_declare(queue='hello',durable=True)
# 声明一个交换机exchange，并设置类型
channel.exchange_declare(exchange='my_exchange', exchange_type='direct')
# 绑定队列与交换机
channel.queue_bind(exchange='my_exchange',queue='hello',routing_key='hello')

# 设置预取数量为1
channel.basic_qos(prefetch_count=1)

# 通过Channel发送消息
channel.basic_publish(exchange='my_exchange',
                      routing_key='hello',
                      body='Hello RabbitMQ!')
print(" [x] Sent 'Hello RabbitMQ!'")

# 定义回调函数来处理接收到的消息
def callback(ch, method, properties, body):
    print(f" [x] Received {body}")

# 通过Channel消费消息，自动确认
channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)

print(' [*] Waiting for messages. To exit press CTRL+C')
channel.start_consuming()

# 关闭连接
connection.close()

```

**注意：生产者在生产的时候可以设置 `exchange`参数为空 ， 这就意味着使用默认交换机进行路由，它是direct类型，此时会这样匹配：匹配queue队列名与routing-key完全相同的queue；**

意思是，我发送消息给 `routing_key`这个队列；







### spring AMQP



https://www.cnblogs.com/studyjobs/p/17500167.html

## Kafka

![Kafka Overview - IBM Automation - Event-driven Solution - Sharing knowledge](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-a87e9bc7cc0449b738232ac658865d92.png)







## SpringCloud

### Eureka

学习网站：https://blog.csdn.net/aasd23/article/details/127913922

实战：

https://blog.devgenius.io/spring-cloud-3-x-integrated-eureka-quick-start-demo-214550b4f668

<img src="https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-c9cd7b20b38bbe60927e1dc36f9418c0.png" alt="img" style="zoom: 67%;" />

1. eureka-server保存**服务名称**到**服务实例地址列表**的映射关系
2. order-service从实例列表中利用**负载均衡算法**选中一个实例地址，向该实例地址发起远程调用
3. user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳，当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除，order-service拉取服务时，就能将故障实例排除了

Eureka 主要由 两个模块组成：

（1）服务器：提供**服务注册** 和 **服务续约** 和 **服务下线** **服务发现** 等服务

 （2）客户端：Eureka Client 是一个 Java 客户端，可简化与 Eureka Server 的交互。该客户端还具有内置负载均衡器，使用循环负载算法。用于调用服务器服务接口；



#### Eureka服务器配置

Eureka 服务器是用于服务注册与发现的组件，所有微服务（Eureka 客户端）会向 Eureka 服务器进行注册，并通过它来发现其他服务。

`@EnableEurekaServer` 注解

```yml
server:
  port: 8761  # 指定 Eureka 服务器的端口

eureka:
  client:
    register-with-eureka: false  # 自己是 Eureka 服务器，不需要注册
    fetch-registry: false  # 不需要从其他 Eureka 服务器同步注册表

spring:
  application:
    name: eureka-server  # Eureka 服务器的名称

management:
  endpoints:
    web:
      exposure:
        include: "*"  # 暴露所有管理端点，用于监控

```

高可用版本配置：在生产环境中，通常会使用多个 Eureka 服务器来实现高可用（HA）。在这种情况下，每个 Eureka 服务器实例需要注册到其他 Eureka 服务器实例中，实现集群互联。

假设有两个 Eureka 服务器实例，分别运行在 8761 和 8762 端口，它们的配置如下：

```yml
server:
  port: 8761

eureka:
  instance:
    hostname: node1
  client:
    register-with-eureka: true  # 注册到其他 Eureka 服务器
    fetch-registry: true  # 获取注册表
    service-url:
      defaultZone: http://localhost:8762/eureka/  # Eureka 服务器 2 的地址

spring:
  application:
    name: eureka-server



====================================================================================================

server:
  # 在8762 端口上提供服务
  port: 8762

eureka:
  instance:
    # 表示服务节点，命名为node2（用于物理通信，决定了如何访问eureka服务）
    hostname: node2
    # 是否优先使用ip用于注册，false表示优先使用{hostname}注册
    prefer-ip-address: false
  client:
    # 决定了该 Eureka 实例是否从其他 Eureka 服务器中获取服务注册表，false表示不拉取，只提供自己的服务
    fetch-registry: true
    # 表示当前eureka服务是否要注册到其他eureka服务，true表示需要
    register-with-eureka: true
    # 将当前eureka服务注册到http://node1:8761/eureka上，形成高可用的集群架构
    service-url:
      defaultZone: http://node1:8761/eureka
spring:
  application:
    # 这是SpringBoot应用的名称，在整个微服务系统中，应用可以通过这个名称了解彼此(用于逻辑识别，其他服务通过这个名称进行服务发现)
    name: "eureka-server-ha"


# 这是 Spring Boot Actuator 的配置，用于暴露管理端点。* 表示将所有的管理
# 端点（如健康检查、环境信息、Beans 信息等）都暴露出来。这些管理端点对于监控
# Eureka 实例的运行状态是非常有用的。
management:
  endpoints:
    web:
      exposure:
        include: "*"
```



#### Eureka客户端配置

`@EnableEurekaClient`注解

```yml
server:
  port: 8080  # 客户端应用的端口

spring:
  application:
    name: eureka-client  # 客户端服务的名称

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  # 指定 Eureka 服务器的地址
    register-with-eureka: true  # 将该服务注册到 Eureka 服务器
    fetch-registry: true  # 从 Eureka 服务器中获取注册表，用于服务发现
```



#### Eureka 客户端API使用

最常用的办法就是，通过`Eureka`注册中心进行远程调用服务，最常用的方式就是使用 `Spring Cloud OpenFeign`，他提供了一种声明式的HTTP客户端，可以轻松调用注册在`Eureka`中的服务，而不需要手动编写复杂的`REST`模板代码：

```xml
<dependencies>
    <!-- Feign 依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
    
    <!-- Eureka 客户端依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
</dependencies>
```

使用：

`@EnableEurekaClient  // 启用 Eureka 客户端 `

`@EnableFeignClients  // 启用 Feign 客户端`

创建`Feign`客户端接口：

```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

// 使用 @FeignClient 注解声明调用的服务，"eureka-client" 是服务在 Eureka 中的名称
@FeignClient(name = "eureka-client")
public interface HelloServiceClient {
    
    // 这里定义远程调用的 REST 接口
    @GetMapping("/hello")
    String getHello();
}
```

在需要调用的地方，注入`Feign`客户端接口并调用方法：

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.beans.factory.annotation.Autowired;

@RestController
public class HelloController {

    // 注入 Feign 客户端
    @Autowired
    private HelloServiceClient helloServiceClient;

    @GetMapping("/get-remote-hello")
    public String getRemoteHello() {
        // 通过 Feign 客户端调用远程服务
        return helloServiceClient.getHello();
    }
}
```

#### 使用Ribbon进行负载均衡

### Spring-Boot-Admin

在 Spring Boot Admin 中，**管理端点（Management Endpoints）** 和 **Spring Boot Admin 服务器** 是密切相关的两个概念。

#### SpringBootAdmin Server

Spring Boot Admin 服务器的主要作用是：

- **集中监控多个 Spring Boot 应用**：Spring Boot Admin 服务器通过收集和展示 Spring Boot 应用暴露的管理端点数据，来监控这些应用的运行状况。
- **提供统一的管理界面**：Spring Boot Admin 服务器为多个应用提供一个统一的 Web 界面，用户可以通过这个界面查看各个应用的状态、健康状况、性能信息、日志等。
- **自动发现和注册**：使用服务注册和发现机制（如 Eureka）时，Spring Boot Admin 服务器可以自动发现和注册新的 Spring Boot 应用。

#### 管理端点

管理端点是由 SpringBootActuator提供的，能够为 Spring Boot Admin 服务器提供丰富的监控数据。这些端点允许用户监控和管理应用的内部状态。

需要以下两个依赖：一个用来**提供健康状况的接口**，一个用于**认证保护这些接口**

```xml
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-client</artifactId>
    <version>3.0.4</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

常见暴露的API如下：

+ **`/actuator/health`**：用于检查应用程序的**健康状态**。Spring Boot Admin 服务器通过调用这个端点，获取应用程序是否运行正常的信息，通常以绿（健康）、黄（部分异常）或红（不可用）等状态显示。

+ **`/actuator/metrics`**：提供应用的**性能指标**，如 CPU 使用率、内存使用情况、垃圾回收统计等。Spring Boot Admin 服务器通过这个端点展示应用的实时性能状态。

+ **`/actuator/loggers`**：允许**动态调整应用的日志级别**。Spring Boot Admin 服务器通过此端点，可以在控制台中实时查看和调整日志级别，帮助开发人员调试问题。

+ **`/actuator/info`**：展示一些定**制的应用信息**，比如应用的版本号、描述等。Spring Boot Admin 服务器通过这个端点展示应用的基本信息，便于了解应用的版本状态。

所以Server端，就负责定期轮询这些端点从这些API收集并展示这些信息；



#### 服务器配置

```java
server:
  port: 8081

# 配置Spring Boot 的管理端点
management:
  endpoint:
    health:
      # 是否显示详细的健康信息
      show-details: always
      enabled: true
    beans:
      # 提供有关应用中 Spring Beans 的详细信息
      enabled: true
  endpoints:
    web:
      exposure:
        # 配置哪些管理端点可以通过 HTTP 暴露出来
        include: "*"
    # 所有的管理端点默认会被启用，不需要为每个端点单独启用
    enabled-by-default: true
spring:
  application:
    name: admin-server
  security:
    user:
      name: admin
      password: admin
```



#### 被监控应用配置

```java
server:
  port: 8082
management:
  endpoint:
    health:
      show-details: always
      enabled: true
    beans:
      enabled: true
  endpoints:
    web:
      exposure:
        include: "*"
    enabled-by-default: true
spring:
  application:
    name: admin-client
    ## spring boot admin
  boot:
    admin:
      client:
        #server
        url: http://127.0.0.1:8081/
        username: admin
        password: admin
        #instance:
        #  prefer-ip: true
        #  service-url: ${your spring boot client url}
```

#### 配置绑定关系

##### 方法一：通过服务发现（Eureka）自动注册

配置一个简单的`Eureka`服务器：

```yml
# application.yml for Eureka server
server:
  port: 8761

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false

spring:
  application:
    name: eureka-server
```

配置Spring boot admin：服务器：

```yml
# application.yml for Spring Boot Admin server
server:
  port: 8081

spring:
  application:
    name: admin-server

  boot:
    admin:
      discovery:
        enabled: true  # 启用服务发现功能

  eureka:
    client:
      service-url:
        defaultZone: http://localhost:8761/eureka/  # 指定 Eureka 服务器地址
      register-with-eureka: true  # 将 Spring Boot Admin 服务器注册到 Eureka
      fetch-registry: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
```

配置被监控的SpringBoot应用：

```yml
# application.yml for monitored Spring Boot application
server:
  port: 8080

spring:
  application:
    name: monitored-app  # 被监控的应用名称

  eureka:
    client:
      service-url:
        defaultZone: http://localhost:8761/eureka/  # Eureka 服务器地址
      register-with-eureka: true  # 将应用注册到 Eureka
      fetch-registry: true

management:
  endpoints:
    web:
      exposure:
        include: "health,metrics,info,loggers"
  endpoint:
    health:
      show-details: always
```



配置完毕以后，Spring Boot Admin 服务器会**自动从 Eureka 获取已注册的应用**，并**通过 Actuator 管理端点来监控这些应用**。

##### 方法二：通过静态配置手动指定应用

```yml
server:
  port: 8081

# 配置Spring Boot 的管理端点
management:
  endpoint:
    health:
      # 是否显示详细的健康信息
      show-details: always
      enabled: true
    beans:
      # 提供有关应用中 Spring Beans 的详细信息
      enabled: true
  endpoints:
    web:
      exposure:
        # 配置哪些管理端点可以通过 HTTP 暴露出来
        include: "*"
    # 所有的管理端点默认会被启用，不需要为每个端点单独启用
    enabled-by-default: true
spring:
  application:
    name: admin-server
  security:
    user:
      name: admin
      password: admin

```

被监控应用：配置服务器地址

```yml
server:
  port: 8082
management:
  endpoint:
    health:
      show-details: always
      enabled: true
    beans:
      enabled: true
  endpoints:
    web:
      exposure:
        include: "*"
    enabled-by-default: true
spring:
  security:
    user:
      name: admin
      password: admin
  application:
    name: admin-client
    ## spring boot admin
  boot:
    admin:
      client:
        #server
        url: http://127.0.0.1:8081/
        username: admin
        password: admin
        #instance:
        #  prefer-ip: true
        #  service-url: ${your spring boot client url}
```



### API Gateway

https://blog.csdn.net/u012060033/article/details/132018122

https://javatechonline.com/implement-api-gateway-spring-boot-microservices/

![image-20240316161655332](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-d9a35138642e3c2dd695bf6d1f11c531.png)

#### 网关介绍

APi网关是一个服务器，是系统的唯一入口；API网关的唯一要点就是所有的客户端、消费端都需要通过统一的网关接入微服务，在网关层处理所有的非业务功能，通常，网关提供REST、HTTP访问的API。

总结其担任的主要作用：

+ 反向代理
+ 路由和负载均衡
+ 身份认证和权限控制
+ 对请求的限流
+ 黑白名单

#### Spring Cloud Gateway

Spring Cloud Gateway 是 Spring Cloud 的新一代API网关，基于WebFlux框架实现，它旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。
Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix ZUUL，具有更好的性能、更强的扩展性、以及更丰富的功能特性，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如:安全，监控/埋点，限流等。

网关本身也是一个微服务，也需要注册进一个服务注册中心！！！

![image-20240316162148933](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-b342fd0b1ca5a8873c5e4888813fb603.png)



#### 特性

1、动态路由

可以使用简单的声明式配置来定义路由规则，包括目标 URL、请求方法和条件等。

2、过滤器

可以定义全局过滤器，适用于所有路由的请求。可以为每个路由单独配置过滤器，允许对请求和响应进行操作。

3、负载均衡

**集成 Ribbon**：内置对 Ribbon 的支持，可以在多个服务实例之间进行负载均衡。

**服务发现**：与 Eureka 等服务注册中心集成，动态获取服务实例。

4、请求转发与响应修改

**请求转发**：能够将请求转发到后端服务，并支持修改请求头和请求体。

**响应修改**：支持修改后端服务的响应，包括响应头和响应体的处理。

5、限流和熔断

限流：通过配置对API进行限流，放置过载

熔断：支持熔断机制，在服务不可用时快速返回错误响应

6、安全性

**集成SpringBootSecurity**：支持吃Oauth2、Basic Auth等认证方式，并且可以配置CORS策略，处理跨域请求的问题

7、监控与管理

集成**Spring Boot Actuator**：提供监控和管理共嗯那个

通过管理端点查看当前路由和过滤器的状态

8、服务发现

集成**Spring boot Eureka**

#### 工作流程

![image-20240316162611930](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-6b710f9b0b2e65cf96f827ce06236ebf.png)

1、Gateway作为一个反向代理服务器，负责接收和处理所有的API请求

2、Gateway会根据路由规则匹配请求，这些路由规则可以基于请求的路径、方法、头信息等条件进行匹配；

3、路由匹配成功后，Gateway会执行与该路由相关的过滤器，包括修改请求、记录日志、限流等操作

4、接收响应，并可以对响应进行处理



```xml
 <dependencies>
        <!--gateway-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--服务注册发现consul discovery,网关也要注册进服务注册中心统一管控-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-consul-discovery</artifactId>
        </dependency>
        <!-- 指标监控健康检查的actuator,网关是响应式编程删除掉spring-boot-starter-web dependency-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

```



#### 重要组件

##### Route路由

路由是指将客户端亲求转发到后端服务的规则和配置，它决定了请求应该被转发到哪个服务以及如何处理请求；

路由通常在`application.yml`中定义，每一个路由由几个关键部分组成：

+ ID：路由的唯一标识
+ URL：*该路由转发的目标URI*，可以指直接的**url**或者**服务名**
+ Predicates：用于匹配请求的条件，确定是否使用该路由（谓词集合，谓词能让我们在Http请求的任何内容上进行匹配）
+ Filters：对请求和响应的处理逻辑，可以对请求进行修改或添加额外的处理步骤（过滤器集合，在发送下游请求之前，或者之后修改请求和响应）

示例：

```yml
spring:
  cloud:
    gateway:
      routes:
        - id: service1
          uri: lb://service1  # 使用负载均衡的服务名,使用 lb:// 前缀来表示通过负载均衡访问服务注册在 Eureka 中的服务
          predicates:
            - Path=/service1/**  # 匹配以 /service1/ 开头的路径
          filters:
            - StripPrefix=1  # 去掉请求路径的前缀
        - id: service2
          uri: http://localhost:8082  # 直接的 URL
          predicates:
            - Path=/service2/**  # 匹配以 /service2/ 开头的路径
```



##### Predicate谓词

**路由选择**：如果请求满足某个路由的所有 Predicate 条件，则该路由会被选中并进行处理。

| 名称       | 说明                          | 示例                                                         |
| ---------- | ----------------------------- | ------------------------------------------------------------ |
| After      | 某个时间点之后的请求          | - After=2023-08-01T14:31:20.123-07:00[Asia/Shanghai]         |
| Before     | 某个时间点之前的请求          | - Before=2023-08-01T14:31:20.123+08:00[Asia/Shanghai]        |
| Between    | 某个时间点之中的请求          | - Between=2023-08-01T14:31:20.123+08:00[Asia/Shanghai],2023-08-05T14:31:20.123+08:00[Asia/Shanghai] |
| Cookie     | 请求必须包含某些 cookie       | - Cookie=test                                                |
| Header     | 请求必须包含某些 header       | - Header=asd,cas                                             |
| Host       | 请求必须包含某个 host（域名） | - Host=baidu.com,jd.com                                      |
| Method     | 请求必须是指定方式            | - Method=GET,POST                                            |
| Path       | 请求路径必须符合指定规则      | - Path=/user/{params},/card/**                               |
| Query      | 请求参数必须包含指定参数      | - Query=name,jack                                            |
| RemoteAddr | 请求者的 IP 必须是指定范围    | - RemoteAddr=192.168.1.1/24                                  |
| Weight     | 权重处理                      | - Weight=50                                                  |



![image-20241016131816639](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-a8b987c6a98cc861040a4a0f36634cf8.png)

##### Filter过滤器

过滤器主要分为**请求过滤器**和**响应过滤器**：

常用内置过滤器：

![image-20241016132506651](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-e3ce4cd11b522713871345ebc6ec5f8b.png)

#### 集成Eureka

集成Eureka后，就可以实现动态路由了，我们在路由了url中就可以使用服务名了，并且可以使用lb开头实现负载均衡：

```yml
spring:
  application:
    name: cloud-gateway
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
    gateway:
      routes:
        #路由的ID，没有固定规则但要求唯一，建议配合服务名
        - id: config_route
  #匹配后提供服务的路由地址, 这里lb之后，跟的是要调用的服务名称
          uri: lb://nacos-provider-8002
  # 断言，路径相匹配的条件
          predicates:
            - Path=/routeconfig/rest/**
```





### Spring Cloud Config



配置中心的主要思想是将配置集中管理起来。它允许我们在一个地方管理不同环境和不同集群的配置信息。当配置发生变化时，配置中心能够实时地将更新推送到应用程序，从而实现动态更新，无需手动逐个修改每个实例的配置。

配置中心就像一个 中央仓库，负责管理和分发配置信息，允许在一个地方管理不同集群的配置信息，当配置发生变化时，配置中心能够把更新信息推送到应用程序，从而实现**动态更新**，

<img src="https://miro.medium.com/v2/resize:fit:1400/1*SckDaXxM3o9nds3FZMZIzQ.png" alt="Spring Cloud Config: Externalizing the Configurations From Your  Microservice | Cloud Native Daily" style="zoom:67%;" />



同样，和之前集中SpringCloud服务一样，由服务端和客户端组成。

Servier端是一个独立的配置中心，支持多种存储配置信息的形式，目前主要有 jdbc、value、native、svn、git，其中默认是 git。



#### server with git

服务器需要的依赖：

```xml
spring-boot-starter-security
spring-cloud-config-server
```

add `@EnableConfigServer`;



创建要给github repository 来存储我们的配置：

首先我们得了解一下github如何区分每一个配置文件：

+ {application}：这个是spring.applicaiton.name定义的名字
+ {profile}：这个是 spring.profile.active定义的环境
+ {label}：这个通常是config服务器端设置的版本好

定义规则可以有以下几种：

![image-20241016144439729](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-1b73946aee97323fc4ba9f76eacec519.png)



之后我们配置我们的config servier的yml文件：

```yml
server:
  port: 8888
spring:
  application:
    name: config-server
  security:
    basic:
      enabled: true
    user:
      name: configuser
      password: configPass$1234
  cloud:
    config:
      server:
        git:
          uri: https://github.com/anji4246/app-config		 
          force-pull: true # pull the latest code from GIT in case the local repo has some issues and couldn't able to update the repo
          skipSslValidation: true # Git Server SSL validation can be disabled
          timeout: 10 #HTTP connection timeout (in seconds)
          username: <git username>
          password: <git password>
encrypt:
  key: <your security key go over here>
```





### Apollo

Apollo是携程开源的配置管理系统，提供了和Spring Config 同样的集中化配置管理服务：

**集中管理配置**：所有的配置都存储在 Apollo 的服务器上，开发者可以通过一个统一的界面来管理这些配置。
**实时推送**：当配置发生变化时，Apollo 可以实时通知应用程序并更新其配置，而无需重新启动应用程序。
**版本控制**：Apollo记录每一次配置的变更，可以随时回滚到之前的版本。
**环境隔离**：支持不同环境（如开发、测试、生产）的配置隔离管理。
**通俗说法**：
**集中管理**：所有的设置都放在小管家那里，你只需要去找他修改，不用去每个房间（应用程序）里逐个改。
**实时更新**：当你告诉小管家修改某个设置后，他会立刻通知到每个房间（应用程序），大家都会马上知道变化。
**版本控制**：小管家会记录每次的设置修改情况，如果发现新设置不好，可以回到以前的老版本。
**环境区分**：如果你有多个不同的家（比如开发环境、测试环境、生产环境），小管家可以帮你分别管理不同的设置，不会搞混。

![55e736d12f2eb938e919ed1b2e15f133e4dd6f65](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-1b6887c02d93dd7f82fb053014af17b8.jpeg)

### 	Nacos

相对于`Spring Eureka`来说，`Nacos`更加强大，其不仅仅支持服务发现服务，其同时还支持 集中式的配置管理等，其功能如下：

1. 服务发现和服务健康监测
2. 动态配置服务
3. 动态DNS服务
4. 服务及其元数据管理



### Spring Consul

今天又突然了解到一个技术，”Spring Consul“，好像功能和Nacos差不多，也是提供 服务发现和 分布式配置管理的。

- **服务发现**：两者均支持健康检查和注册，但Nacos支持DNS与RPC服务发现机制，而Consul更侧重于使用DNS和HTTP接口进行服务发现，且Consul提供了强大的多数据中心支持，无需额外配置即可实现跨数据中心的服务发现。
- **配置管理**：Nacos提供动态配置服务，允许在运行时更改配置并实时推送给客户端；Consul也具备动态配置功能，但它更加强调KV存储的一致性，适合需要强一致性的场景。
- **健康检查机制**：Nacos采用健康检查机制来监控服务实例的状态，而Consul同样具备健康检查能力，但Consul在多数据中心同步状态方面有更严格的一致性保证。
- **安全性和权限控制**：Consul内置了较为完善的安全模型，支持TLS加密、ACL访问控制列表，而Nacos也支持SSL/TLS加密及鉴权，但在社区版本中，Nacos的安全特性可能需要更多的手动配置。

所以学一下吧；

#### spring-cloud-consul-starter-discovery

用于服务发现

#### spring-cloud-consul-starter-config

用于统一配置

为了使用统一配置，我们还需要引入一个额外的依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
```

`bootstrap`是什么呢，而且我们需要另外创建一个`bootstrap.yml`文件：

+ applicaiton.yml是用户级的资源配置项；
+ bootstrap.yml是系统级的，优先级更加高；

Spring Cloud会创建一个“`Bootstrap Context`”，作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。

 Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。 Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。**application.yml文件改为bootstrap.yml,这是很关键的或者两者共存。**因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。

### SpringBoot Ribbon

Spring Ribbon 主要基于 Netflix Ribbon实现的一套客户端负载均衡（**load balance**）的框架。

#### 与Nginx区别

既然是负载均衡，那它与 `Nginx`有什么区别呢：

+ 使用场景不同，`Nginx`主要使用在前端服务器，在前端向后端发送请求的时候，使用其做负载均衡。
+ 而`RIbbon`使用场景主要是 服务端内做负载均衡，比如订单后端服务 要调用 支付后端服务，压根不仅过页面，**而支付的后端服务器是集群，这时候订单服务就需要做负载均衡**

#### 负载均衡分类

集中式LB：即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方；
进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

#### 原理

原理也是非常简单，依赖于一个 `Eureka Server`服务器，（1）先从`Eureka Server`服务器中获取一个服务注册列表；（2）根据用户制定策略选择负载较少的Server；

注：Eureka自动携带对Ribbon的依赖，也就是会自动引入；

#### 使用

1. 配置具体的负载均衡算法：定义核心组件 `IRule`：负责具体的负载均衡选择
2. 给具体的例如 `RestTemplate`、`webClientBuilder`添加注解
3. 在调用服务时**一定是通过服务名调用**



突然看到Ribbon好像已经不再更新维护了，好像都在使用`LoadBalancer`了

### Spring-cloud-bootstrap

首先介绍 **Spring-cloud**中的 `bootstrap`文件：

bootstrap的中文翻译是“引导程序”的意思。Spring中的ApplicationContext是会有父子关系的。Spring Cloud初始化的ApplicationContext叫bootstrap ApplicationContext，之后会创建一些子的ApplicationContext。这个bootstrap ApplicationContext如果在初始化的过程中是可以接收一些外部属性控制的，那么对应的属性需要配置在bootstrap.yml或bootstrap.properties文件中。默认会在Classpath的根路径或config路径下寻找它们。ApplicationContext是有父子关系的，那依托于ApplicationContext的Environment也相当于间接的有了父子关系，所以定义在bootstrap.yml文件中的属性值也可以被我们自己定义的bean使用。只是它里面的值会被我们定义在application.yml中的相同属性的值覆盖掉。bootstrap ApplicationContext寻找的外部属性文件的名字不一定是bootstrap，它可以通过系统属性spring.cloud.bootstrap.name进行指定，比如通过系统属性spring.cloud.bootstrap.name指定bootstrap属性文件的名称是application，即会在Classpath根目录或config目录下寻找application.yml或application.properties文件。也可以通过系统属性spring.cloud.bootstrap.location指定bootstrap文件的位置，它们的用法就类似于Spring Boot中指定配置文件的spring.config.name和spring.config.location`。

如果在bootstrap.yml中指定了spring.profiles.active=dev，则bootstrap ApplicationContext寻找配置文件时还会寻找bootstrap-dev.yml文件。



我们在`bootstrap.yml`文件中 主要是配置 `配置服务`，包含地址、文件名等；



### Spring Cloud Loadbalancer

Spring官方提供了两种客户端都可以使用loadbalancer：

**RestTemplate**：Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。默认情况下，RestTemplate默认依赖jdk的HTTP连接工具。
**WebClient**：从Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行Http请求的客户端工具。它的响应式编程的基于Reactor的。WebClient中提供了标准Http请求方式对应的get、post、put、delete等方法，可以用来发起相应的请求



Spring 注册中新会自动引入了[ribbon](https://so.csdn.net/so/search?q=ribbon&spm=1001.2101.3001.7020)，需要移除ribbon的包，如果不移除，也可以在yml中配置不使用ribbon。

默认情况下，如果同时拥有RibbonLoadBalancerClient和BlockingLoadBalancerClient，为了保持向后兼容性，将使用RibbonLoadBalancerClient。要覆盖它，可以设置spring.cloud.loadbalancer.ribbon.enabled属性为false。



用法和`Ribbon`几乎相同，都依靠一个注释就行（服务发起方定义负载均衡的好处！！！）



`LoadBalancer`默认只有两个算法：轮询算法和 随机算法，如果我们切换到随机算法，我们可以通过以下配置：

```yml
spring:
  application:
    name: my-client
  cloud:
    loadbalancer:
      services:
        my-service: # 为my-service服务定制负载均衡算法
          loadbalancer: 
            algorithm: random

```

当然，除了通过配置文件来配置，我们也可以通过配置类来设置：

```java
@Configuration
@LoadBalancerClient(
        //下面的value值大小写一定要和consul里面的名字一样,configuration：指定负载均衡的自定义配置类，这里指向 RestTemplateConfig.class，即当前类
        value = "cloud-payment-service",configuration = RestTemplateConfig.class) // 用于定义服务的负载均衡配置
public class RestTemplateConfig
{
    @Bean
    @LoadBalanced //使用@LoadBalanced注解赋予RestTemplate负载均衡的能力
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment,
                                                            LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); // 获取当前服务的名称。这是用于后续负载均衡器的配置

        return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name); // 从工厂中获取与服务名称相关的实例列表，允许负载均衡器在调用时延迟解析服务实例
    }
}

```



### OpenFeign

 Feign是一个声明性web服务客户端。它使编写web服务客户端变得更容易。使用Feign创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC注释的支持，以及对使用Spring Web中默认使用的HttpMessageConverter的支持。Spring Cloud集成了Eureka、Spring Cloud CircuitBreaker以及Spring Cloud LoadBalancer，以便在使用Feign时提供负载平衡的http客户端。

openfeign是一个声明式的Web服务客户端，我们只需要创建一个Rest接口并在该接口上添加注解`@FeignClint`即可使用，OpenFeign基本上就是当前微服务之间调用的事实标准（可见其已经慢慢成为一种调用服务的标准）

依然需要在启动类上添加 `EnableFeignClients`；

之后写一个 `interface`，并且在接口上打上 `@FeignClient`：

```java
@FeignClient("stores")
public interface StoreClient {
    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    List<Store> getStores();

    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    Page<Store> getStores(Pageable pageable);

    @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")
    Store update(@PathVariable("storeId") Long storeId, Store store);

    @RequestMapping(method = RequestMethod.DELETE, value = "/stores/{storeId:\\d+}")
    void delete(@PathVariable Long storeId);
}
```



使用 `OpenFeign`有什么好处呢？

使用SpringCloud LoadBalancer+RestTemplate时，利用RestTemplate对http请求的封装处理形成了一套模版化的调用方法。

但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。

 所以，OpenFeign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。 在OpenFeign的实现下，我们只需创建一个接口并使用注解的方式来配置它(在一个微服务接口上面标注一个**@FeignClient**注解即可)，即可完成对服务提供方的接口绑定，统一对外暴露可以被调用的接口方法，大大简化和降低了调用客户端的开发量，也即由服务提供者给出调用接口清单，消费者直接通过OpenFeign调用即可。

依赖：

```xml
<!--openfeign新加的坐标-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<!-- 引入自己定义的api通用包 -->
<dependency>
    <groupId>com.zm.cloud</groupId>
    <artifactId>cloud-api-commons</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

**上面那个API通用包非常重要！！！，这样就避免了每一个微服务都要写相同的Feign接口，并且这个接口咋写可以交给服务提供方！！！！！**

具体流程：

1. 路由到目标服务：Feign会根据我们在注解上填的微服务名称去注册中心（consul）找有没有这个微服务，然后找到这个微服务下的具体示例列表，因为Feign本身就有负载均衡能力，默认还是轮询的方式进行调度。
2. 选择具体的端点：选择完目标示例之后，Feign会根据你定义的路径（/pay/add）来拼凑完整的URL，比如说选择了8001，那么URL就是：http://localhost:8001/pay/add；
3. 发送请求：URL拿到后，Feign就使用HTTP客户端发送请求到服务提供者，然后就是具体的处理请求了，至此整个服务流程完成

#### 高级用法

`openfeign`的默认时间就是60秒，超过60秒就会导致FeignClient返回报错：

如此配置就好：

```yml
spring:
    application:
      name: cloud-consumer-openfeign-order
    ####Spring Cloud Consul for Service Discovery
    cloud:
      consul:
        host: localhost
        port: 8500
        discovery:
          prefer-ip-address: true #优先使用服务ip进行注册
          service-name: ${spring.application.name}
      openfeign:
        client:
          config:
            default:
             #连接超时时间
             connectTimeout: 3000
             #读取超时时间
             readTimeout: 3000
```



`OpenFeign`也是支持重试机制的，但是默认关闭，我们需要通过创建 组件的方式，来开启这个功能：

```java
@Configuration
public class FeignConfig {
    @Bean
    public Retryer myRetryer(){
        //return Retryer.NEVER_RETRY; //Feign默认配置是不走重试策略的
        //最大请求次数为（1+2）次，初始时间间隔为100ms，重试最大间隔时间为1秒
        return new Retryer.Default(100,1,3);
    }
}
```



`HttpClient`修改，OpenFeign中http client，如果不做特殊配置，OpenFeign默认使用JDK自带HttpURLConnection发送HTTP请求，由于默认HttpURLConnection没有连接池、性能和效率比较低，如果采用默认，性能上不是最强大的，所以需要换掉推荐使用阿帕奇的HC5

我们需要先关闭 `OpenFeign`的重试机制，然后添加 `HC5`依赖：

```java
<!-- httpclient5-->
<dependency>
    <groupId>org.apache.httpcomponents.client5</groupId>
    <artifactId>httpclient5</artifactId>
    <version>5.3</version>
</dependency>
<!-- feign-hc5-->
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-hc5</artifactId>
    <version>13.1</version>
</dependency>
```

配置如下：

```yml
server:
  port: 80
spring:
    application:
      name: cloud-consumer-openfeign-order
    ####Spring Cloud Consul for Service Discovery
    cloud:
      consul:
        host: localhost
        port: 8500
        discovery:
          prefer-ip-address: true #优先使用服务ip进行注册
          service-name: ${spring.application.name}
      openfeign:
        client:
          config:
#            default:
#             connectTimeout: 3000            #连接超时时间
#             readTimeout: 3000             #读取超时时间
            cloud-payment-service:
             connectTimeout: 5000
             readTimeout: 5000
        httpclient:
          hc5:
            enabled: true

```



后面还有 请求、相应压缩功能、日志打印功能等等，这些都可以配置！！！！





















































































### 依赖项



### Bug

为什么 `Spring-cloud-consul-discovery`导入不进来？

答：因为我的spring-cloud依赖管理导入错了，必须加上type=pom以及，scope=import：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-dependencies</artifactId>
    <version>${spring.cloud.version}</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
```

还有就是应该导入 `starter`，但是我把`starter`给丢了，然后我一直想通过配置文件来进行组件配置，当然不行啊！！！！

