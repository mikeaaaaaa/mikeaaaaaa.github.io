---

---

# 技术框架



## RabbitMQ

rabbitmq是一种实现了 **高级消息队列协议（AMQP）**的**开源消息队列服务软件**又可以称之为面向消息的中间件；

### 整体框架

整体框架图：

![Different Exchange Types in RabbitMQ | by Binod Mahto | Medium](https://miro.medium.com/v2/resize:fit:886/1*UWsV79zkqd5NEkzr6uP2CA.png)

想要搞懂`RabbitMQ`，我们只需要搞清其中的几个概念即可；

### 各个组件

#### Message

RabbitMQ中的消息通常由两个部分组成：

1. 消息头：消息的元数据，包含消息以外的额外信息，包括 消息的优先级、持久化标记、路由键（routingKey）、消息ID等
2. 消息体：实际的数据载荷，可以是文本、json、xml、二进制等数据；

声明周期如下：

1. 生产者创建消息，设置消息头、消息体。在发送消息时指定 交换机与路由键；
2. 到达交换机后，更具**交换机的种类**以及**路由键**和**绑定键**这三者去顶发往哪个队列
3. 消费者从队列中消费消息，在处理完消息后选择 “Acknowledge”消息，告诉RabbitMQ这条消息处理完毕。若未确定或者消费者处理失败，这条消息会被重新投递。

消息头可以存放的一些属性：

1. content_type：描述消息内容的MIME类型，如 `application/json`、`text/plain`等
2. delivery_mode: 表示消息的吃捷星，1表示非持久消息，2表示持久消息
3. priority:指定消息的优先级，高优先级的消息会被优先消费
4. message_id: 唯一表示消息的ID

#### Exchange

**Exchange（交换机）**是消息路由的核心组件，负责将来自生产者的消息分发到相应的队列（Queue）中。生产者将消息发送到交换机，交换机根据配置的路由规则决定消息应该发送到哪些队列。

我们首先得知道 Exchange 是需要与 Queue进行绑定的，一个交换机可以绑定多个队列，并且在绑定的时候可以指定绑定键（**binding-key**），绑定键在 直连交换机与主题交换机中起作用；

主要介绍三种常用的交换机：

1. Direct Exchange（直连交换机）

这种交换机会将消息路由到**路由键（Routing Key）**与绑定键（Binding Key）完全匹配的队列中。适用于需要精确匹配的场景。

1. Fanout Exchange （扇出交换机）

扇出交换机会将消息发送给所有与之绑定的队列，**忽略路由键**。适用于**广播消息**的场景。

1. Topic Exchange （主题交换机）

这种交换机会根据**路由键的模式**进行路由。它支持模糊匹配，用`.`分隔的路由键可以进行匹配操作，`*`匹配一个单词，`#`匹配零个或多个单词。



当然Exchange自身也会有各种属性：

name：交换机名字

type：交换机类型

Durable：交换机是否持久化到磁盘，即重启后还在不在

#### Queue

负责暂存来自交换机的消息，直到消费者（Consumer）处理这些消息。队列可以看作是消息的中转站，生产者将消息发送到交换机，交换机再将消息路由到队列中，而消费者则从队列中获取并处理消息。

消息进入到队列中后，会根据队列的配置决定消息的存储方式，持久化或者非持久化（注意消息具体是否持久化不仅要设置队列，还要求消息的持久化属性为2）；消费者订阅队列，从队列中接收消息，RabbitMQ支持多种消费模式，例如 消息先进先被消费、优先级消费（优先级高的消息先被消费）等；当然消息队列还能设置最大长度、为每个消息设置TTL等；

在RabbitMQ中，**消费者并不是主动拉取（pull）消息**，而是**服务器将消息推送（push）给消费者**。RabbitMQ通过消费者与队列的绑定关系，将消息自动从队列中推送给消费者。

#### Channel

**Channel（通道）*是生产者和消费者与RabbitMQ服务器进行通信的逻辑连接。它是在与RabbitMQ服务器建立的\**TCP连接**之上的虚拟连接。由于RabbitMQ使用了基于AMQP协议的消息队列机制，通道是客户端发送或接收消息的最基本API机制。

设置Channel的原因：由于每次都要重新建立TCP连接非常浪费资源，因此决定复用某个TCP连接，即在TCP连接之上抽象出一层 Channel，这样就可以在TCP连接之上建立多个通道；创建与销毁更加高效，更轻量；具有独立性，这样一个客户端就可以在一个TCP上执行并发操作（生产消息、消费消息）

```python
import pika

# 连接到RabbitMQ服务器
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 声明一个队列，确保消息队列存在
channel.queue_declare(queue='hello',durable=True)
# 声明一个交换机exchange，并设置类型
channel.exchange_declare(exchange='my_exchange', exchange_type='direct')
# 绑定队列与交换机
channel.queue_bind(exchange='my_exchange',queue='hello',routing_key='hello')

# 设置预取数量为1
channel.basic_qos(prefetch_count=1)

# 通过Channel发送消息
channel.basic_publish(exchange='my_exchange',
                      routing_key='hello',
                      body='Hello RabbitMQ!')
print(" [x] Sent 'Hello RabbitMQ!'")

# 定义回调函数来处理接收到的消息
def callback(ch, method, properties, body):
    print(f" [x] Received {body}")

# 通过Channel消费消息，自动确认
channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)

print(' [*] Waiting for messages. To exit press CTRL+C')
channel.start_consuming()

# 关闭连接
connection.close()

```

**注意：生产者在生产的时候可以设置 `exchange`参数为空 ， 这就意味着使用默认交换机进行路由，它是direct类型，此时会这样匹配：匹配queue队列名与routing-key完全相同的queue；**

意思是，我发送消息给 `routing_key`这个队列；







### spring AMQP



https://www.cnblogs.com/studyjobs/p/17500167.html

## Kafka

![Kafka Overview - IBM Automation - Event-driven Solution - Sharing knowledge](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-a87e9bc7cc0449b738232ac658865d92.png)







## SpringCloud

### Eureka

学习网站：https://blog.csdn.net/aasd23/article/details/127913922

实战：

https://blog.devgenius.io/spring-cloud-3-x-integrated-eureka-quick-start-demo-214550b4f668

<img src="https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-c9cd7b20b38bbe60927e1dc36f9418c0.png" alt="img" style="zoom: 67%;" />

1. eureka-server保存**服务名称**到**服务实例地址列表**的映射关系
2. order-service从实例列表中利用**负载均衡算法**选中一个实例地址，向该实例地址发起远程调用
3. user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳，当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除，order-service拉取服务时，就能将故障实例排除了

Eureka 主要由 两个模块组成：

（1）服务器：提供**服务注册** 和 **服务续约** 和 **服务下线** **服务发现** 等服务

 （2）客户端：Eureka Client 是一个 Java 客户端，可简化与 Eureka Server 的交互。该客户端还具有内置负载均衡器，使用循环负载算法。用于调用服务器服务接口；



#### Eureka服务器配置

Eureka 服务器是用于服务注册与发现的组件，所有微服务（Eureka 客户端）会向 Eureka 服务器进行注册，并通过它来发现其他服务。

`@EnableEurekaServer` 注解

```yml
server:
  port: 8761  # 指定 Eureka 服务器的端口

eureka:
  client:
    register-with-eureka: false  # 自己是 Eureka 服务器，不需要注册
    fetch-registry: false  # 不需要从其他 Eureka 服务器同步注册表

spring:
  application:
    name: eureka-server  # Eureka 服务器的名称

management:
  endpoints:
    web:
      exposure:
        include: "*"  # 暴露所有管理端点，用于监控

```

高可用版本配置：在生产环境中，通常会使用多个 Eureka 服务器来实现高可用（HA）。在这种情况下，每个 Eureka 服务器实例需要注册到其他 Eureka 服务器实例中，实现集群互联。

假设有两个 Eureka 服务器实例，分别运行在 8761 和 8762 端口，它们的配置如下：

```yml
server:
  port: 8761

eureka:
  instance:
    hostname: node1
  client:
    register-with-eureka: true  # 注册到其他 Eureka 服务器
    fetch-registry: true  # 获取注册表
    service-url:
      defaultZone: http://localhost:8762/eureka/  # Eureka 服务器 2 的地址

spring:
  application:
    name: eureka-server



====================================================================================================

server:
  # 在8762 端口上提供服务
  port: 8762

eureka:
  instance:
    # 表示服务节点，命名为node2（用于物理通信，决定了如何访问eureka服务）
    hostname: node2
    # 是否优先使用ip用于注册，false表示优先使用{hostname}注册
    prefer-ip-address: false
  client:
    # 决定了该 Eureka 实例是否从其他 Eureka 服务器中获取服务注册表，false表示不拉取，只提供自己的服务
    fetch-registry: true
    # 表示当前eureka服务是否要注册到其他eureka服务，true表示需要
    register-with-eureka: true
    # 将当前eureka服务注册到http://node1:8761/eureka上，形成高可用的集群架构
    service-url:
      defaultZone: http://node1:8761/eureka
spring:
  application:
    # 这是SpringBoot应用的名称，在整个微服务系统中，应用可以通过这个名称了解彼此(用于逻辑识别，其他服务通过这个名称进行服务发现)
    name: "eureka-server-ha"


# 这是 Spring Boot Actuator 的配置，用于暴露管理端点。* 表示将所有的管理
# 端点（如健康检查、环境信息、Beans 信息等）都暴露出来。这些管理端点对于监控
# Eureka 实例的运行状态是非常有用的。
management:
  endpoints:
    web:
      exposure:
        include: "*"
```



#### Eureka客户端配置

`@EnableEurekaClient`注解

```yml
server:
  port: 8080  # 客户端应用的端口

spring:
  application:
    name: eureka-client  # 客户端服务的名称

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  # 指定 Eureka 服务器的地址
    register-with-eureka: true  # 将该服务注册到 Eureka 服务器
    fetch-registry: true  # 从 Eureka 服务器中获取注册表，用于服务发现
```



#### Eureka 客户端API使用

最常用的办法就是，通过`Eureka`注册中心进行远程调用服务，最常用的方式就是使用 `Spring Cloud OpenFeign`，他提供了一种声明式的HTTP客户端，可以轻松调用注册在`Eureka`中的服务，而不需要手动编写复杂的`REST`模板代码：

```xml
<dependencies>
    <!-- Feign 依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
    
    <!-- Eureka 客户端依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
</dependencies>
```

使用：

`@EnableEurekaClient  // 启用 Eureka 客户端 `

`@EnableFeignClients  // 启用 Feign 客户端`

创建`Feign`客户端接口：

```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

// 使用 @FeignClient 注解声明调用的服务，"eureka-client" 是服务在 Eureka 中的名称
@FeignClient(name = "eureka-client")
public interface HelloServiceClient {
    
    // 这里定义远程调用的 REST 接口
    @GetMapping("/hello")
    String getHello();
}
```

在需要调用的地方，注入`Feign`客户端接口并调用方法：

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.beans.factory.annotation.Autowired;

@RestController
public class HelloController {

    // 注入 Feign 客户端
    @Autowired
    private HelloServiceClient helloServiceClient;

    @GetMapping("/get-remote-hello")
    public String getRemoteHello() {
        // 通过 Feign 客户端调用远程服务
        return helloServiceClient.getHello();
    }
}
```

#### 使用Ribbon进行负载均衡

### Spring-Boot-Admin

在 Spring Boot Admin 中，**管理端点（Management Endpoints）** 和 **Spring Boot Admin 服务器** 是密切相关的两个概念。

#### SpringBootAdmin Server

Spring Boot Admin 服务器的主要作用是：

- **集中监控多个 Spring Boot 应用**：Spring Boot Admin 服务器通过收集和展示 Spring Boot 应用暴露的管理端点数据，来监控这些应用的运行状况。
- **提供统一的管理界面**：Spring Boot Admin 服务器为多个应用提供一个统一的 Web 界面，用户可以通过这个界面查看各个应用的状态、健康状况、性能信息、日志等。
- **自动发现和注册**：使用服务注册和发现机制（如 Eureka）时，Spring Boot Admin 服务器可以自动发现和注册新的 Spring Boot 应用。

#### 管理端点

管理端点是由 SpringBootActuator提供的，能够为 Spring Boot Admin 服务器提供丰富的监控数据。这些端点允许用户监控和管理应用的内部状态。

需要以下两个依赖：一个用来**提供健康状况的接口**，一个用于**认证保护这些接口**

```xml
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-client</artifactId>
    <version>3.0.4</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

常见暴露的API如下：

+ **`/actuator/health`**：用于检查应用程序的**健康状态**。Spring Boot Admin 服务器通过调用这个端点，获取应用程序是否运行正常的信息，通常以绿（健康）、黄（部分异常）或红（不可用）等状态显示。

+ **`/actuator/metrics`**：提供应用的**性能指标**，如 CPU 使用率、内存使用情况、垃圾回收统计等。Spring Boot Admin 服务器通过这个端点展示应用的实时性能状态。

+ **`/actuator/loggers`**：允许**动态调整应用的日志级别**。Spring Boot Admin 服务器通过此端点，可以在控制台中实时查看和调整日志级别，帮助开发人员调试问题。

+ **`/actuator/info`**：展示一些定**制的应用信息**，比如应用的版本号、描述等。Spring Boot Admin 服务器通过这个端点展示应用的基本信息，便于了解应用的版本状态。

所以Server端，就负责定期轮询这些端点从这些API收集并展示这些信息；



#### 服务器配置

```java
server:
  port: 8081

# 配置Spring Boot 的管理端点
management:
  endpoint:
    health:
      # 是否显示详细的健康信息
      show-details: always
      enabled: true
    beans:
      # 提供有关应用中 Spring Beans 的详细信息
      enabled: true
  endpoints:
    web:
      exposure:
        # 配置哪些管理端点可以通过 HTTP 暴露出来
        include: "*"
    # 所有的管理端点默认会被启用，不需要为每个端点单独启用
    enabled-by-default: true
spring:
  application:
    name: admin-server
  security:
    user:
      name: admin
      password: admin
```



#### 被监控应用配置

```java
server:
  port: 8082
management:
  endpoint:
    health:
      show-details: always
      enabled: true
    beans:
      enabled: true
  endpoints:
    web:
      exposure:
        include: "*"
    enabled-by-default: true
spring:
  application:
    name: admin-client
    ## spring boot admin
  boot:
    admin:
      client:
        #server
        url: http://127.0.0.1:8081/
        username: admin
        password: admin
        #instance:
        #  prefer-ip: true
        #  service-url: ${your spring boot client url}
```

#### 配置绑定关系

##### 方法一：通过服务发现（Eureka）自动注册

配置一个简单的`Eureka`服务器：

```yml
# application.yml for Eureka server
server:
  port: 8761

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false

spring:
  application:
    name: eureka-server
```

配置Spring boot admin：服务器：

```yml
# application.yml for Spring Boot Admin server
server:
  port: 8081

spring:
  application:
    name: admin-server

  boot:
    admin:
      discovery:
        enabled: true  # 启用服务发现功能

  eureka:
    client:
      service-url:
        defaultZone: http://localhost:8761/eureka/  # 指定 Eureka 服务器地址
      register-with-eureka: true  # 将 Spring Boot Admin 服务器注册到 Eureka
      fetch-registry: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
```

配置被监控的SpringBoot应用：

```yml
# application.yml for monitored Spring Boot application
server:
  port: 8080

spring:
  application:
    name: monitored-app  # 被监控的应用名称

  eureka:
    client:
      service-url:
        defaultZone: http://localhost:8761/eureka/  # Eureka 服务器地址
      register-with-eureka: true  # 将应用注册到 Eureka
      fetch-registry: true

management:
  endpoints:
    web:
      exposure:
        include: "health,metrics,info,loggers"
  endpoint:
    health:
      show-details: always
```



配置完毕以后，Spring Boot Admin 服务器会**自动从 Eureka 获取已注册的应用**，并**通过 Actuator 管理端点来监控这些应用**。

##### 方法二：通过静态配置手动指定应用

```yml
server:
  port: 8081

# 配置Spring Boot 的管理端点
management:
  endpoint:
    health:
      # 是否显示详细的健康信息
      show-details: always
      enabled: true
    beans:
      # 提供有关应用中 Spring Beans 的详细信息
      enabled: true
  endpoints:
    web:
      exposure:
        # 配置哪些管理端点可以通过 HTTP 暴露出来
        include: "*"
    # 所有的管理端点默认会被启用，不需要为每个端点单独启用
    enabled-by-default: true
spring:
  application:
    name: admin-server
  security:
    user:
      name: admin
      password: admin

```

被监控应用：配置服务器地址

```yml
server:
  port: 8082
management:
  endpoint:
    health:
      show-details: always
      enabled: true
    beans:
      enabled: true
  endpoints:
    web:
      exposure:
        include: "*"
    enabled-by-default: true
spring:
  security:
    user:
      name: admin
      password: admin
  application:
    name: admin-client
    ## spring boot admin
  boot:
    admin:
      client:
        #server
        url: http://127.0.0.1:8081/
        username: admin
        password: admin
        #instance:
        #  prefer-ip: true
        #  service-url: ${your spring boot client url}
```



### API Gateway

https://blog.csdn.net/u012060033/article/details/132018122

https://javatechonline.com/implement-api-gateway-spring-boot-microservices/

![image-20240316161655332](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-d9a35138642e3c2dd695bf6d1f11c531.png)

#### 网关介绍

APi网关是一个服务器，是系统的唯一入口；API网关的唯一要点就是所有的客户端、消费端都需要通过统一的网关接入微服务，在网关层处理所有的非业务功能，通常，网关提供REST、HTTP访问的API。

总结其担任的主要作用：

+ 反向代理
+ 路由和负载均衡
+ 身份认证和权限控制
+ 对请求的限流
+ 黑白名单

#### Spring Cloud Gateway

Spring Cloud Gateway 是 Spring Cloud 的新一代API网关，基于WebFlux框架实现，它旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。
本质上网关就是部署在微服务最前沿的防火墙和代理器，隐藏微服务节点的IP和端口信息，从而加强安全防护。

网关本身也是一个微服务，也需要注册进一个服务注册中心！！！

![image-20240316162148933](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-b342fd0b1ca5a8873c5e4888813fb603.png)



#### 特性

1、动态路由

可以使用简单的声明式配置来定义路由规则，包括目标 URL、请求方法和条件等。

2、过滤器

可以定义全局过滤器，适用于所有路由的请求。可以为每个路由单独配置过滤器，允许对请求和响应进行操作。

3、负载均衡

**集成 Ribbon**：内置对 Ribbon 的支持，可以在多个服务实例之间进行负载均衡。

**服务发现**：与 Eureka 等服务注册中心集成，动态获取服务实例。

4、请求转发与响应修改

**请求转发**：能够将请求转发到后端服务，并支持修改请求头和请求体。

**响应修改**：支持修改后端服务的响应，包括响应头和响应体的处理。

5、限流和熔断

限流：通过配置对API进行限流，放置过载

熔断：支持熔断机制，在服务不可用时快速返回错误响应

6、安全性

**集成SpringBootSecurity**：支持吃Oauth2、Basic Auth等认证方式，并且可以配置CORS策略，处理跨域请求的问题

7、监控与管理

集成**Spring Boot Actuator**：提供监控和管理共嗯那个

通过管理端点查看当前路由和过滤器的状态

8、服务发现

集成**Spring boot Eureka**

#### 工作流程

![image-20240316162611930](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-6b710f9b0b2e65cf96f827ce06236ebf.png)

1、Gateway作为一个反向代理服务器，负责接收和处理所有的API请求

2、Gateway会根据路由规则匹配请求，这些路由规则可以基于请求的路径、方法、头信息等条件进行匹配；

3、路由匹配成功后，Gateway会执行与该路由相关的过滤器，包括修改请求、记录日志、限流等操作

4、接收响应，并可以对响应进行处理



```xml
 <dependencies>
        <!--gateway-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--服务注册发现consul discovery,网关也要注册进服务注册中心统一管控-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-consul-discovery</artifactId>
        </dependency>
        <!-- 指标监控健康检查的actuator,网关是响应式编程删除掉spring-boot-starter-web dependency-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

```



#### 重要组件

##### Route路由

路由是指将客户端亲求转发到后端服务的规则和配置，它决定了请求应该被转发到哪个服务以及如何处理请求；

路由通常在`application.yml`中定义，每一个路由由几个关键部分组成：

+ ID：路由的唯一标识
+ URL：*该路由转发的目标URI*，可以指直接的**url**或者**服务名**
+ Predicates：用于匹配请求的条件，确定是否使用该路由（谓词集合，谓词能让我们在Http请求的任何内容上进行匹配）
+ Filters：对请求和响应的处理逻辑，可以对请求进行修改或添加额外的处理步骤（过滤器集合，在发送下游请求之前，或者之后修改请求和响应）

示例：

```yml
spring:
  cloud:
    gateway:
      routes:
        - id: service1
          uri: lb://service1  # 使用负载均衡的服务名,使用 lb:// 前缀来表示通过负载均衡访问服务注册在 Eureka 中的服务
          predicates:
            - Path=/service1/**  # 匹配以 /service1/ 开头的路径
          filters:
            - StripPrefix=1  # 去掉请求路径的前缀
        - id: service2
          uri: http://localhost:8082  # 直接的 URL
          predicates:
            - Path=/service2/**  # 匹配以 /service2/ 开头的路径
```



##### Predicate谓词

**路由选择**：如果请求满足某个路由的所有 Predicate 条件，则该路由会被选中并进行处理。

| 名称       | 说明                          | 示例                                                         |
| ---------- | ----------------------------- | ------------------------------------------------------------ |
| After      | 某个时间点之后的请求          | - After=2023-08-01T14:31:20.123-07:00[Asia/Shanghai]         |
| Before     | 某个时间点之前的请求          | - Before=2023-08-01T14:31:20.123+08:00[Asia/Shanghai]        |
| Between    | 某个时间点之中的请求          | - Between=2023-08-01T14:31:20.123+08:00[Asia/Shanghai],2023-08-05T14:31:20.123+08:00[Asia/Shanghai] |
| Cookie     | 请求必须包含某些 cookie       | - Cookie=test                                                |
| Header     | 请求必须包含某些 header       | - Header=asd,cas                                             |
| Host       | 请求必须包含某个 host（域名） | - Host=baidu.com,jd.com                                      |
| Method     | 请求必须是指定方式            | - Method=GET,POST                                            |
| Path       | 请求路径必须符合指定规则      | - Path=/user/{params},/card/**                               |
| Query      | 请求参数必须包含指定参数      | - Query=name,jack                                            |
| RemoteAddr | 请求者的 IP 必须是指定范围    | - RemoteAddr=192.168.1.1/24                                  |
| Weight     | 权重处理                      | - Weight=50                                                  |



![image-20241016131816639](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-a8b987c6a98cc861040a4a0f36634cf8.png)

##### Filter过滤器

过滤器主要分为**请求过滤器**和**响应过滤器**：

常用内置过滤器：

![image-20241016132506651](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-e3ce4cd11b522713871345ebc6ec5f8b.png)

#### 集成Eureka

集成Eureka后，就可以实现动态路由了，我们在路由了url中就可以使用服务名了，并且可以使用lb开头实现负载均衡：

```yml
spring:
  application:
    name: cloud-gateway
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
    gateway:
      routes:
        #路由的ID，没有固定规则但要求唯一，建议配合服务名
        - id: config_route
  #匹配后提供服务的路由地址, 这里lb之后，跟的是要调用的服务名称
          uri: lb://nacos-provider-8002
  # 断言，路径相匹配的条件
          predicates:
            - Path=/routeconfig/rest/**
```





### Spring Cloud Config



配置中心的主要思想是将配置集中管理起来。它允许我们在一个地方管理不同环境和不同集群的配置信息。当配置发生变化时，配置中心能够实时地将更新推送到应用程序，从而实现动态更新，无需手动逐个修改每个实例的配置。

配置中心就像一个 中央仓库，负责管理和分发配置信息，允许在一个地方管理不同集群的配置信息，当配置发生变化时，配置中心能够把更新信息推送到应用程序，从而实现**动态更新**，

<img src="https://miro.medium.com/v2/resize:fit:1400/1*SckDaXxM3o9nds3FZMZIzQ.png" alt="Spring Cloud Config: Externalizing the Configurations From Your  Microservice | Cloud Native Daily" style="zoom:67%;" />



同样，和之前集中SpringCloud服务一样，由服务端和客户端组成。

Servier端是一个独立的配置中心，支持多种存储配置信息的形式，目前主要有 jdbc、value、native、svn、git，其中默认是 git。



#### server with git

服务器需要的依赖：

```xml
spring-boot-starter-security
spring-cloud-config-server
```

add `@EnableConfigServer`;



创建要给github repository 来存储我们的配置：

首先我们得了解一下github如何区分每一个配置文件：

+ {application}：这个是spring.applicaiton.name定义的名字
+ {profile}：这个是 spring.profile.active定义的环境
+ {label}：这个通常是config服务器端设置的版本好

定义规则可以有以下几种：

![image-20241016144439729](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-1b73946aee97323fc4ba9f76eacec519.png)



之后我们配置我们的config servier的yml文件：

```yml
server:
  port: 8888
spring:
  application:
    name: config-server
  security:
    basic:
      enabled: true
    user:
      name: configuser
      password: configPass$1234
  cloud:
    config:
      server:
        git:
          uri: https://github.com/anji4246/app-config		 
          force-pull: true # pull the latest code from GIT in case the local repo has some issues and couldn't able to update the repo
          skipSslValidation: true # Git Server SSL validation can be disabled
          timeout: 10 #HTTP connection timeout (in seconds)
          username: <git username>
          password: <git password>
encrypt:
  key: <your security key go over here>
```





### Apollo

Apollo是携程开源的配置管理系统，提供了和Spring Config 同样的集中化配置管理服务：

**集中管理配置**：所有的配置都存储在 Apollo 的服务器上，开发者可以通过一个统一的界面来管理这些配置。
**实时推送**：当配置发生变化时，Apollo 可以实时通知应用程序并更新其配置，而无需重新启动应用程序。
**版本控制**：Apollo记录每一次配置的变更，可以随时回滚到之前的版本。
**环境隔离**：支持不同环境（如开发、测试、生产）的配置隔离管理。
**通俗说法**：
**集中管理**：所有的设置都放在小管家那里，你只需要去找他修改，不用去每个房间（应用程序）里逐个改。
**实时更新**：当你告诉小管家修改某个设置后，他会立刻通知到每个房间（应用程序），大家都会马上知道变化。
**版本控制**：小管家会记录每次的设置修改情况，如果发现新设置不好，可以回到以前的老版本。
**环境区分**：如果你有多个不同的家（比如开发环境、测试环境、生产环境），小管家可以帮你分别管理不同的设置，不会搞混。

![55e736d12f2eb938e919ed1b2e15f133e4dd6f65](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-1b6887c02d93dd7f82fb053014af17b8.jpeg)

### 	Nacos

相对于`Spring Eureka`来说，`Nacos`更加强大，其不仅仅支持服务发现服务，其同时还支持 集中式的配置管理等，其功能如下：

1. 服务发现和服务健康监测
2. 动态配置服务
3. 动态DNS服务
4. 服务及其元数据管理



### Spring Consul

今天又突然了解到一个技术，”Spring Consul“，好像功能和Nacos差不多，也是提供 服务发现和 分布式配置管理的。

- **服务发现**：两者均支持健康检查和注册，但Nacos支持DNS与RPC服务发现机制，而Consul更侧重于使用DNS和HTTP接口进行服务发现，且Consul提供了强大的多数据中心支持，无需额外配置即可实现跨数据中心的服务发现。
- **配置管理**：Nacos提供动态配置服务，允许在运行时更改配置并实时推送给客户端；Consul也具备动态配置功能，但它更加强调KV存储的一致性，适合需要强一致性的场景。
- **健康检查机制**：Nacos采用健康检查机制来监控服务实例的状态，而Consul同样具备健康检查能力，但Consul在多数据中心同步状态方面有更严格的一致性保证。
- **安全性和权限控制**：Consul内置了较为完善的安全模型，支持TLS加密、ACL访问控制列表，而Nacos也支持SSL/TLS加密及鉴权，但在社区版本中，Nacos的安全特性可能需要更多的手动配置。

所以学一下吧；

#### spring-cloud-consul-starter-discovery

用于服务发现

#### spring-cloud-consul-starter-config

用于统一配置

为了使用统一配置，我们还需要引入一个额外的依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
```

`bootstrap`是什么呢，而且我们需要另外创建一个`bootstrap.yml`文件：

+ applicaiton.yml是用户级的资源配置项；
+ bootstrap.yml是系统级的，优先级更加高；

Spring Cloud会创建一个“`Bootstrap Context`”，作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。

 Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。 Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。**application.yml文件改为bootstrap.yml,这是很关键的或者两者共存。**因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。

### SpringBoot Ribbon

Spring Ribbon 主要基于 Netflix Ribbon实现的一套客户端负载均衡（**load balance**）的框架。

#### 与Nginx区别

既然是负载均衡，那它与 `Nginx`有什么区别呢：

+ 使用场景不同，`Nginx`主要使用在前端服务器，在前端向后端发送请求的时候，使用其做负载均衡。
+ 而`RIbbon`使用场景主要是 服务端内做负载均衡，比如订单后端服务 要调用 支付后端服务，压根不仅过页面，**而支付的后端服务器是集群，这时候订单服务就需要做负载均衡**

#### 负载均衡分类

集中式LB：即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方；
进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

#### 原理

原理也是非常简单，依赖于一个 `Eureka Server`服务器，（1）先从`Eureka Server`服务器中获取一个服务注册列表；（2）根据用户制定策略选择负载较少的Server；

注：Eureka自动携带对Ribbon的依赖，也就是会自动引入；

#### 使用

1. 配置具体的负载均衡算法：定义核心组件 `IRule`：负责具体的负载均衡选择
2. 给具体的例如 `RestTemplate`、`webClientBuilder`添加注解
3. 在调用服务时**一定是通过服务名调用**



突然看到Ribbon好像已经不再更新维护了，好像都在使用`LoadBalancer`了

### Spring-cloud-bootstrap

首先介绍 **Spring-cloud**中的 `bootstrap`文件：

bootstrap的中文翻译是“引导程序”的意思。Spring中的ApplicationContext是会有父子关系的。Spring Cloud初始化的ApplicationContext叫bootstrap ApplicationContext，之后会创建一些子的ApplicationContext。这个bootstrap ApplicationContext如果在初始化的过程中是可以接收一些外部属性控制的，那么对应的属性需要配置在bootstrap.yml或bootstrap.properties文件中。默认会在Classpath的根路径或config路径下寻找它们。ApplicationContext是有父子关系的，那依托于ApplicationContext的Environment也相当于间接的有了父子关系，所以定义在bootstrap.yml文件中的属性值也可以被我们自己定义的bean使用。只是它里面的值会被我们定义在application.yml中的相同属性的值覆盖掉。bootstrap ApplicationContext寻找的外部属性文件的名字不一定是bootstrap，它可以通过系统属性spring.cloud.bootstrap.name进行指定，比如通过系统属性spring.cloud.bootstrap.name指定bootstrap属性文件的名称是application，即会在Classpath根目录或config目录下寻找application.yml或application.properties文件。也可以通过系统属性spring.cloud.bootstrap.location指定bootstrap文件的位置，它们的用法就类似于Spring Boot中指定配置文件的spring.config.name和spring.config.location`。

如果在bootstrap.yml中指定了spring.profiles.active=dev，则bootstrap ApplicationContext寻找配置文件时还会寻找bootstrap-dev.yml文件。



我们在`bootstrap.yml`文件中 主要是配置 `配置服务`，包含地址、文件名等；



### Spring Cloud Loadbalancer

Spring官方提供了两种客户端都可以使用loadbalancer：

**RestTemplate**：Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。默认情况下，RestTemplate默认依赖jdk的HTTP连接工具。
**WebClient**：从Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行Http请求的客户端工具。它的响应式编程的基于Reactor的。WebClient中提供了标准Http请求方式对应的get、post、put、delete等方法，可以用来发起相应的请求



Spring 注册中新会自动引入了[ribbon](https://so.csdn.net/so/search?q=ribbon&spm=1001.2101.3001.7020)，需要移除ribbon的包，如果不移除，也可以在yml中配置不使用ribbon。

默认情况下，如果同时拥有RibbonLoadBalancerClient和BlockingLoadBalancerClient，为了保持向后兼容性，将使用RibbonLoadBalancerClient。要覆盖它，可以设置spring.cloud.loadbalancer.ribbon.enabled属性为false。



用法和`Ribbon`几乎相同，都依靠一个注释就行（服务发起方定义负载均衡的好处！！！）



`LoadBalancer`默认只有两个算法：轮询算法和 随机算法，如果我们切换到随机算法，我们可以通过以下配置：

```yml
spring:
  application:
    name: my-client
  cloud:
    loadbalancer:
      services:
        my-service: # 为my-service服务定制负载均衡算法
          loadbalancer: 
            algorithm: random

```

当然，除了通过配置文件来配置，我们也可以通过配置类来设置：

```java
@Configuration
@LoadBalancerClient(
        //下面的value值大小写一定要和consul里面的名字一样,configuration：指定负载均衡的自定义配置类，这里指向 RestTemplateConfig.class，即当前类
        value = "cloud-payment-service",configuration = RestTemplateConfig.class) // 用于定义服务的负载均衡配置
public class RestTemplateConfig
{
    @Bean
    @LoadBalanced //使用@LoadBalanced注解赋予RestTemplate负载均衡的能力
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment,
                                                            LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); // 获取当前服务的名称。这是用于后续负载均衡器的配置

        return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name); // 从工厂中获取与服务名称相关的实例列表，允许负载均衡器在调用时延迟解析服务实例
    }
}

```



### OpenFeign

 Feign是一个声明性web服务客户端。它使编写web服务客户端变得更容易。使用Feign创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC注释的支持，以及对使用Spring Web中默认使用的HttpMessageConverter的支持。Spring Cloud集成了Eureka、Spring Cloud CircuitBreaker以及Spring Cloud LoadBalancer，以便在使用Feign时提供负载平衡的http客户端。

openfeign是一个声明式的Web服务客户端，我们只需要创建一个Rest接口并在该接口上添加注解`@FeignClint`即可使用，OpenFeign基本上就是当前微服务之间调用的事实标准（可见其已经慢慢成为一种调用服务的标准）

依然需要在启动类上添加 `EnableFeignClients`；

之后写一个 `interface`，并且在接口上打上 `@FeignClient`：

```java
@FeignClient("stores")
public interface StoreClient {
    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    List<Store> getStores();

    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    Page<Store> getStores(Pageable pageable);

    @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")
    Store update(@PathVariable("storeId") Long storeId, Store store);

    @RequestMapping(method = RequestMethod.DELETE, value = "/stores/{storeId:\\d+}")
    void delete(@PathVariable Long storeId);
}
```



使用 `OpenFeign`有什么好处呢？

使用SpringCloud LoadBalancer+RestTemplate时，利用RestTemplate对http请求的封装处理形成了一套模版化的调用方法。

但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。

 所以，OpenFeign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。 在OpenFeign的实现下，我们只需创建一个接口并使用注解的方式来配置它(在一个微服务接口上面标注一个**@FeignClient**注解即可)，即可完成对服务提供方的接口绑定，统一对外暴露可以被调用的接口方法，大大简化和降低了调用客户端的开发量，也即由服务提供者给出调用接口清单，消费者直接通过OpenFeign调用即可。

依赖：

```xml
<!--openfeign新加的坐标-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<!-- 引入自己定义的api通用包 -->
<dependency>
    <groupId>com.zm.cloud</groupId>
    <artifactId>cloud-api-commons</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

**上面那个API通用包非常重要！！！，这样就避免了每一个微服务都要写相同的Feign接口，并且这个接口咋写可以交给服务提供方！！！！！**

具体流程：

1. 路由到目标服务：Feign会根据我们在注解上填的微服务名称去注册中心（consul）找有没有这个微服务，然后找到这个微服务下的具体示例列表，因为Feign本身就有负载均衡能力，默认还是轮询的方式进行调度。
2. 选择具体的端点：选择完目标示例之后，Feign会根据你定义的路径（/pay/add）来拼凑完整的URL，比如说选择了8001，那么URL就是：http://localhost:8001/pay/add；
3. 发送请求：URL拿到后，Feign就使用HTTP客户端发送请求到服务提供者，然后就是具体的处理请求了，至此整个服务流程完成

#### 高级用法

`openfeign`的默认时间就是60秒，超过60秒就会导致FeignClient返回报错：

如此配置就好：

```yml
spring:
    application:
      name: cloud-consumer-openfeign-order
    ####Spring Cloud Consul for Service Discovery
    cloud:
      consul:
        host: localhost
        port: 8500
        discovery:
          prefer-ip-address: true #优先使用服务ip进行注册
          service-name: ${spring.application.name}
      openfeign:
        client:
          config:
            default:
             #连接超时时间
             connectTimeout: 3000
             #读取超时时间
             readTimeout: 3000
```



`OpenFeign`也是支持重试机制的，但是默认关闭，我们需要通过创建 组件的方式，来开启这个功能：

```java
@Configuration
public class FeignConfig {
    @Bean
    public Retryer myRetryer(){
        //return Retryer.NEVER_RETRY; //Feign默认配置是不走重试策略的
        //最大请求次数为（1+2）次，初始时间间隔为100ms，重试最大间隔时间为1秒
        return new Retryer.Default(100,1,3);
    }
}
```



`HttpClient`修改，OpenFeign中http client，如果不做特殊配置，OpenFeign默认使用JDK自带HttpURLConnection发送HTTP请求，由于默认HttpURLConnection没有连接池、性能和效率比较低，如果采用默认，性能上不是最强大的，所以需要换掉推荐使用阿帕奇的HC5

我们需要先关闭 `OpenFeign`的重试机制，然后添加 `HC5`依赖：

```java
<!-- httpclient5-->
<dependency>
    <groupId>org.apache.httpcomponents.client5</groupId>
    <artifactId>httpclient5</artifactId>
    <version>5.3</version>
</dependency>
<!-- feign-hc5-->
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-hc5</artifactId>
    <version>13.1</version>
</dependency>
```

配置如下：

```yml
server:
  port: 80
spring:
    application:
      name: cloud-consumer-openfeign-order
    ####Spring Cloud Consul for Service Discovery
    cloud:
      consul:
        host: localhost
        port: 8500
        discovery:
          prefer-ip-address: true #优先使用服务ip进行注册
          service-name: ${spring.application.name}
      openfeign:
        client:
          config:
#            default:
#             connectTimeout: 3000            #连接超时时间
#             readTimeout: 3000             #读取超时时间
            cloud-payment-service:
             connectTimeout: 5000
             readTimeout: 5000
        httpclient:
          hc5:
            enabled: true

```



后面还有 请求、相应压缩功能、日志打印功能等等，这些都可以配置！！！！



### 异步处理

#### 介绍

在SpringBoot中使用异步处理非常简单，使用 `@Async`注解标记方法即可。

在Spring Boot中，使用`@Async`注解进行异步编程是一种非常实用的特性，它可以帮助我们提升应用的响应速度，尤其是在执行一些耗时操作（如大[文件处理](https://so.csdn.net/so/search?q=文件处理&spm=1001.2101.3001.7020)、网络请求、数据库批量操作等）时。异步方法可以在后台线程中执行，而不需要阻塞主线程，从而提高了应用的并发能力和用户体验。

#### 原理

当一个方法被@Async标记时，Spring会通过其内部的TaskExecutor（任务执行器，默认是SimpleAsyncTaskExecutor或者基于ThreadPoolTaskExecutor的变体）来异步执行这个方法。这意味着调用该方法后，控制权会立即返回给调用者，而实际的方法逻辑会在另外的线程中并行执行。

默认的任务执行器为 `SimpleAsyncExecutor`，其有以下特点：

1. **非线程池模型**：与常见的线程池（如ThreadPoolTaskExecutor）不同，SimpleAsyncTaskExecutor每次执行一个任务时都会创建一个新的线程。这意味着对于每个异步方法调用，它都会生成一个新的线程来执行该任务，执行完后，这个线程不会被复用，而是会被JVM的线程管理机制回收。
2. **适用场景**：由于其不复用线程的特性，SimpleAsyncTaskExecutor特别适合用于那些执行次数不多、且对线程创建开销不敏感的轻量级异步任务。如果任务执行频繁且持续时间短，频繁创建和销毁线程可能会导致性能问题和资源浪费。
3. **无限制**：它没有核心线程数、最大线程数、队列等概念，因此不会受到线程池大小或队列容量的限制。这对于某些特定场景可能是有利的，例如当不确定任务的数量或不想受限于固定大小的线程池时。

因此，虽然默认的 `SimpleAsyncExecutor`简单易用，但在大多数生产环境中，出于性能和资源管理的考虑，**推荐使用基于线程池的执行器来替代它**，除非你能确定应用的负载和场景适合使用这种非池化的线程创建方式。

#### 使用

1、在启动类上添加 @EnableAsync注解

2、自定义线程池，配置 `TaskExecutor`

```java
@Configuration
@EnableAsync
public class ThreadPoolTaskConfig {
	private static final int corePoolSize = 10;   // 核心线程数（默认线程数）
	private static final int maxPoolSize = 100;   // 最大线程数
	private static final int keepAliveTime = 10;  // 允许线程空闲时间（单位：默认为秒）
	private static final int queueCapacity = 200; // 缓冲队列数
	private static final String threadNamePrefix = "Async-Service-"; // 线程池名前缀
	@Bean("taskExecutor") // bean的名称，默认为首字母小写的方法名
	public ThreadPoolTaskExecutor getAsyncExecutor(){
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		executor.setCorePoolSize(corePoolSize);   
		executor.setMaxPoolSize(maxPoolSize);
		executor.setQueueCapacity(queueCapacity);
		executor.setKeepAliveSeconds(keepAliveTime);
		executor.setThreadNamePrefix(threadNamePrefix);
		
		// 线程池对拒绝任务的处理策略
        /* 当线程的任务缓存队列已满并且线程池中的线程数量已经达到了最大连接数，如果还有任务来就会采取拒绝策略，
         * 通常有四种策略：
         *ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出异常：RejectedExcutionException异常
         *ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常
         *ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
         *ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用execute()方法，直到成功。
         *ThreadPoolExecutor. 扩展重试3次，如果3次都不充公在移除。
         *jmeter 压力测试 1s=500
        * */
		executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
		// 初始化
		executor.initialize();
		return executor;
	}
}
```

3、在需要异步的方法上添加@Async注解；

```java
@Service
public class testAsyncService {
	Logger log = LoggerFactory.getLogger(testAsyncService.class);
 
	// 发送提醒短信 1
	@Async("taskExecutor") // 给线程池命名了就得加上注解里面的属性，没有就不需要
	public void service1() throws InterruptedException {
		log.info("--------start-service1------------");
		Thread.sleep(5000); // 模拟耗时
	    log.info("--------end-service1------------");
	}
	
	// 发送提醒短信 2
	@Async("taskExecutor")
	public void service2() throws InterruptedException {
		log.info("--------start-service2------------");
		Thread.sleep(2000); // 模拟耗时
	    log.info("--------end-service2------------");
	}
}

```

对于有返回值的异步任务1、需要使用Future对象封装返回值2、方法体内部通过封装`AsyncResult`对象来构造返回值，举例如下：

```java
// 异步方法
 @Async
 public Future<String> asyncMethodWithReturnType() {
     System.out.println("Execute method asynchronously - "
       + Thread.currentThread().getName());
     try {
         Thread.sleep(5000);
         return new AsyncResult<String>("hello world !!!!"); // 返回
     } catch (InterruptedException e) {
	  	 return null;
     }
 }
```

#### 异常处理

https://www.cnblogs.com/jpfss/p/10272085.html

#### 注意事项

1、异步方法不可以是static方法

2、异步类必须使用@Component注解扫描成组件

3、配置类添加@EnableAsync注解

4、在Async方法上添加注解@Transactional没用，必须得在调用者方法上标注 @Transactional

5、Async方法的调用者不能与被调用者在同一个类中

6、**事务管理**：在异步方法想要实现事务，推荐将每一个异步方法调用的子方法单独配置@Async注解

## Mybatis

### tk-mybatis

其实就和spring-data-jpa非常类似，继承 JPARepository即可！！！

tk-mybatis是对底层的sql进行了封装，不需要考虑sql怎么写，只需要按照逻辑思维，遵循`tkMybatis`的语法即可实现数据库的操作。

我们创建的mapper接口类都需要继承 `tk.mybatis.mapper.common.Mapper<T>`,泛型是对应的数据库`Entity`类；

```java
public interface HouseMapper extends Mapper<House> {
}
```

下面我们依次介绍一下增删改查：

#### 插入

insert方法：

继承的接口为我们提供的insert方法，表示往表中插入一条数据，表有多少个字段，自动生成的sql语句就有多少个字段；

insertSelective方法：

实体类参数中不为 null 的字段就会被考虑，在 tkmybatis 生成的 insert sql 语句中只会包含这些不为 null 的字段，**好处**：未提交的值可以使用数据库设置的默认值了；

#### 查询

select方法：

接收实体参数，实体参数中有哪些字段不为null，就会被作为select语句中的条件字段，而且字段之间的关系是`and`；

selectOne方法：

与 select 方法一样，只是返回结果只能为空或者一个，如果有多个，则抛出异常。

selectCount方法：

查询满足条件的记录有多少条

selectByprimaryKey方法：

根据主键进行查询，参数为主键的类型

existsWithPrimaryKey：

根据主键查询某条记录是否存在

 **Mapper.select(record)**	根据实体中的属性值进行查询，查询条件使用等号

 **Mapper.selectAll()**	查询全部结果

 **Mapper.selectByExample(example)**	根据Example条件进行查询

 **Mapper.selectByPrimaryKey(key)**	根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号 

**Mapper.selectCount(record)**	根据实体中的属性查询总数，查询条件使用等号

 **Mapper.selectCountByExample(example)**	

根据Example条件进行查询总数

 **Mapper.selectOne(record)**	 根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号。 但是如果存在某个属性为int，则会初始化为0。可能影响到实际使用



#### 修改



修改 **Mapper.updateByExample(record,example)**	根据Example条件更新实体`record`包含的全部属性，null值会被更新

 **Mapper.updateByExampleSelective(record,example)**	根据Example条件更新实体`record`包含的不是null的属性值

 **Mapper.updateByPrimaryKey(record)**	根据主键更新实体全部字段，null值会被更新

 **Mapper.updateByPrimaryKeySelective(record)**	根据主键更新属性不为null的值（record主键不允许为空）

#### 删除

 **Mapper.delete(record);**	根据实体属性作为条件进行删除，查询条件使用等号 

**Mapper.deleteByExample(example)**	根据Example条件删除数据

 **Mapper.deleteByPrimaryKey(key)**	根据主键字段进行删除，方法参数必须包含完整的主键属性

#### 常用

一般不推荐使用Example来实现复杂的查询，这里的复杂是指，既有or也有and，如果不复杂的话建议使用`Example`，因为某些查询比较通用，但是个别字段就是得用模糊查询，这很烦，所以下面的代码就很好用：

具体见链接：https://juejin.cn/post/7163563706897399844

```java
public class BrandService{
    @Autowired
    private BrandMapper brandMapper;
    
    public Example createExample(Brand brand){
        Example example = new Example(Brand.class);
        Example.Criteria criteria = example.createCriteria();
        if(brand != null){
            if(!StringUtils.isEmpty(brand.getName())){
                criteria.andLike("name", "%" + brand.getName()+ "%");
            }
            if(!StringUtils.isEmpty(brand.getLetter())){
                criteria.andEqualTo("letter",brand.getLetter());
            }
        }
        return example;
    }
    @Override
    List<Brand> findList(Brand brand){
        Example example = createExample(brand);
        return brandMapper.selectByExample(example);
    }
    
    @Override
    public List<Brand> findAll(){
        return brandMapper.findAll();
    } 
    @Override
    public Brand findById(Integer id){
        return brandMapper.selectByPrimarykey(id);
    }
}
```



### Mybatis-generator

**MyBatis Generator** 主要用于自动生成基础的 MyBatis 映射代码(包含xml文件以及Bean Java类)，适合快速开发初始数据访问层。

往往我们在数据库上使用最常用的其实就是  对于单表的CRUD操作，非常浪费时间，只需简单配置即可实现快速的单表CRUD操作；

使用也非常简单，使用方法见：

https://blog.csdn.net/qq_63754844/article/details/136590316?spm=1001.2014.3001.5502，里面有提到用法

### MyBatis Plus

Mybatis Plus和tk-Mybatis一样，也是一款Mybatis拓展库，他们的目标都是简化Mybatis的使用，目前来说Mybatis-plus使用更加广泛。其功能包含了上述两个技术；

![image-20241102215549023](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-96448ccbbe06e2f5c2118198329740c6.png)

#### 使用

首先引入数据表：

```sql
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '姓名',
  `age` int(11) NULL DEFAULT NULL COMMENT '年龄',
  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `version` int(10) NULL DEFAULT 1 COMMENT '乐观锁',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `deleted` int(1) NULL DEFAULT 0 COMMENT '逻辑删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1511997312817717256 CHARACTER SET = latin1 COLLATE = latin1_swedish_ci ROW_FORMAT = Dynamic;
-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, '赵2222', 18, '156451612@168.com', 4, NULL, '2022-04-08 20:02:42', 1);
INSERT INTO `user` VALUES (2, '？？？？', 20, 'test2@baomidou.com', 1, NULL, NULL, 0);
INSERT INTO `user` VALUES (3, 'Tom', 28, 'test3@baomidou.com', 1, NULL, NULL, 0);
INSERT INTO `user` VALUES (4, 'Sandy', 21, 'test4@baomidou.com', 1, NULL, NULL, 0);
INSERT INTO `user` VALUES (5, 'Billie', 24, 'test5@baomidou.com', 1, NULL, NULL, 0);

SET FOREIGN_KEY_CHECKS = 1;
```

#### 常用注解

![image-20241103163244292](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-fa257b6e4ef2cccf23c46d67ead8b902.png)

#### 常用配置

## 容器打包



### Github Actions

https://blog.csdn.net/qq_36697163/article/details/140383476

Github Actions 是Github的自动化平台，它支持各种语言和框架，我们仅仅需要通过编写Yaml文件，就可以定义在代码库中发生特定事件（比如Push、Tag等）时触发的工作流程，从而帮助用户实现自动化的CI/CD。

 Runner 主机是执行 GitHub Actions 的核心。Github Actions提供了默认的两种Runner：（1）托管Runner：Github提供的Runner，无需自己维护 （2）自托管Runner：在自己服务器上运行的Runner，可以根据自己的需要定制；因为自托管 Runner 允许用户在自己的服务器上运行工作流程，提供更多的灵活性和控制。因此我们选择自托管 Runner。



## 依赖项

### hutool-all

Hutool是一个小而全的**Java工具类**库，通过**静态方法**封装，降低**相关API的学习成本**，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。

官方文档：https://hutool.cn/docs/#/core/%E5%85%8B%E9%9A%86/%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%85%8B%E9%9A%86%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%8B%E9%9A%86%E7%B1%BB

### Jackson与FastJson

当前程序员最喜欢的两个Json库分别是Jackson与FascJson。Jackson是全球范围内最为流行的JSON库，但`Fastjson`背靠大树阿里，在中国积累了不少“忠粉”，流行程度也不容小觑，甚至大有中国最流行的JSON库之趋势。

看网上说是 FastJson要更加快点，下面就我关心的点进行介绍：

（1）扩展性方面

`Jackson`的拓展性明显要比FastJson高很多，各种需要都能满足例如：null值的处理、空字符串的处理、bool值的处理、字段缺失处理、默认值处理、权限访问处理....

并且通过Module模块的拓展，还能支持 xml、Propertiers、Yaml等数据格式！！！

相比较而言，Fastjson在扩展性这方面就显得**弱很多**。毕竟它代码中有很多写死的实现，天生决定了扩展性会受到限制。当然这和它最初定位是使用在阿里系内使然，所以有很多写死的（比如判断阿里虚拟机名称）代码在里面，所以可扩展性方面并不是它关注的首要重点。

![image-20241103180157422](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-294255379590ffe812a4d02664ad10d2.png)



对于在SpringBoot项目中来说，默认是使用`Jackson`进行序列与反序列化，当我们引入Spring-boot--starter-web的时候，会默认自动引入`Jackson`依赖：

![image-20241103180759036](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-39fca51e470d01dc1b9957df86ce554c.png)

![image-20241103181439259](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-11-26a91ba6334556682e9f497f218a3ac7.png)

在这里我们简要介绍一下Jackson相关的一些注解吧：



@JsonProperty：此注解用于属性，作用是把该属性的名称序列化另外一个名称；序列化与反序列化

@JsonIgnore：最用用于属性上，表示在序列化的时候忽略该属性；序列化与反序列化

@JsonInclude：控制在序列化时是否包含属性，通常用于忽略null值；序列化使用

@JsonFormat：指定日期和时间格式化方式；序列化与反序列化

@JsonCreator：自定义发序列过程

@JsonValue：自定义序列化值

，，，，，，

### 生成API文档

目前我已经遇到过好几种自动生成API文档的依赖了，它们分别是：knife4j-spring-boot-starter`、`springdoc-openapi-starter-webmvc-ui` 和 `springdoc-openapi-hateoas

#### Knife4j

```java
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
</dependency>
```

使用配置：

```java
@Bean
public Docket docket1() {
    ApiInfo apiInfo = new ApiInfoBuilder()
            .title("苍穹外卖项目接口文档")
            .version("2.0")
            .description("苍穹外卖项目接口文档")
            .build();
    return  new Docket(DocumentationType.SWAGGER_2)
            .groupName("管理端接口")
            .apiInfo(apiInfo)
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.sky.controller.admin"))
            .paths(PathSelectors.any())
            .build();
}


/**
 * 通过knife4j生成接口文档
 * @return
 */
@Bean
public Docket docket2() {
    ApiInfo apiInfo = new ApiInfoBuilder()
            .title("苍穹外卖项目接口文档")
            .version("2.0")
            .description("苍穹外卖项目接口文档")
            .build();
    return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo)
            .groupName("用户端接口")
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.sky.controller.user"))
            .paths(PathSelectors.any())
            .build();

}
```

#### springdoc-openapi-hateoas

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-hateoas</artifactId>
    <version>${openapi.version}</version>
</dependency>
```

配置使用：

```java
@Configuration
@OpenAPIDefinition(info = @Info(title = "Spring Boot Minio Example", version = "1.0"))
public class OpenApiConfiguration implements OperationCustomizer {

    @Override
    public Operation customize(Operation operation, HandlerMethod handlerMethod) {
        Parameter parameterHeader = new Parameter()
                .in(ParameterIn.QUERY.toString())
                .description("Enter media type: json or hal. (Default: json, hal = \"application/hal+json\" with link)")
                .required(false)
                .name("mediaType")
                .example("hal")
                .schema(new StringSchema()
                        .addEnumItem("hal")
                        .addEnumItem("json")
                        .addEnumItem("xml")
                        ._default("json"));

        operation.addParametersItem(parameterHeader);
        return operation;
    }
}
```



#### springdoc-openapi-starter-webmvc-ui



```java
<!-- Swagger3 调用方式 http://你的主机IP地址:5555/swagger-ui/index.html -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
</dependency>
```



```java
@Bean
public OpenAPI docsOpenApi()
{
    return new OpenAPI()
            .info(new Info().title("cloud2024")
                    .description("通用设计rest")
                    .version("v1.0"))
            .externalDocs(new ExternalDocumentation()
                    .description("www.zm.com")
                    .url("https://yiyan.baidu.com/"));
}
```

#### commons-lang3

Apache的commons-lang3库和hutool一样，是一个非常流行的工具库，拓展Java的能力，包括 字符串、数组、以及数值操作，反射和并发；

+ **StringUtils**：用于处理一组null安全检查的字符串处理操作，其补充并继承了String类的功能。
+ **ArrayUtils**：实现了一组处理或检查数组的实用方法。
+ **NumberUtils**：提供了强大数值相关的实用方法，用于处理和操作数值类型。
+ **SystemUtils**：有时需要从不同属性文件、java平台或操作的变量获取动态信息。SystemUtils 类提供简便方法予以实现。
+ ConstructUtils
+ FieldUtils
+ MethodUtils

## CI/CD

### mvn命令

首先我们了解一下 `mvn`命令，`mvn` 命令 后面一般接 `goal`或者 `phrase`，如果是goal的话，那就是单独仅仅执行这个 goal包含的代码；如果是 `phrase`的话，那就是链式顺序执行指定phrase为止所有的`phrase`；

并且mvn 命令能同时接收多个 goal或者phrase参数，例如： `mvn clean install`

也可以跳过链式phrase中的某一步骤：例如 `mvn clean package -Dskip Tests jlib:build`，这个表示先清理、再跳过Test步骤进行打包，之后执行 `jlib`插件的`build`目标；

`mvn compile`命令呢，则会解析项目的 `pom.xml`文件，了解项目结构和依赖关系，并下载必须要的依赖到maven本地仓库，之后编译项目的源码，编译后的类文件通常放置在 `targert/class`目录下；如果项目有**多模块module**，那么这些模块也会被一次编译；

**jlib**是一个开源的工具，用于构建Docker镜像：

Jib会自动处理以下任务：

- **基础镜像选择**：根据配置选择合适的Java基础镜像。
- **依赖管理**：将项目的所有依赖项打包到Docker镜像中。
- **应用打包**：将编译后的类文件和资源文件打包到Docker镜像中。
- **多层优化**：Jib会智能地将构建结果分割成多个层，以便于缓存和重用，从而加快后续构建的速度。
- **镜像推送**：如果配置了镜像仓库，Jib会将构建好的Docker镜像推送到指定的镜像仓库。

像jlib这种的在`mvn`项目中我们称之为 插件，Maven插件提供了一些具体的构建任务，这些任务称之为插件目标即`goal`，每个插件可以有多个目标，每目标执行特定的功能；为了执行目标`goal`，我们需要在pom文件中使用 `executions`元素，这个元素用于配置插件在特地的生命周期的开始阶段执行特定的目标，如下：

```xml
<executions>
    <execution>
        <phase>package</phase>
        <goals>
            <goal>build</goal>
        </goals>
    </execution>
</executions>
```

而如果我们相对插件进行配置的话，就得使用`plugins`元素，定义插件的组ID、artifactID、版本号以及`executions`元素，还有`configuration`元素，这个元素适用于定义插件的配置参数，下main是一个完成的插件配置：

```xml
<project>
  ...
  <build>
    <plugins>
      <plugin>
        <groupId>com.google.cloud.tools</groupId>
        <artifactId>jib-maven-plugin</artifactId>
        <version>3.3.0</version>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>build</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <from>
            <image>openjdk:11-jre-slim</image>
          </from>
          <to>
            <image>my-repo/my-app:latest</image>
          </to>
          <container>
            <mainClass>com.example.MyApplication</mainClass>
            <ports>
              <port>8080</port>
            </ports>
          </container>
        </configuration>
      </plugin>
    </plugins>
  </build>
  ...
</project>
```

​	

`mvn`还能指定 配置文件profile，例如：`mvn clean install -Pdev`，表示激活名为`dev`的配置文件。





