---
title: Android-网络
date: 2023-12-20 11:00:00 +0800
categories: [抓包]
tags: [抓包,Network]
---
## android网络相关知识

### 理解https协议：

![img](/assets/image/2024-08-07-Android网络/v2-b51e0fa2400e879cdbc40a44cf75ae56_1440w.webp)

具体过程： 

![img](/assets/image/2024-08-07-Android网络/20200609101405612.gif)

 加密部分：

HTTPS 是会对 `HTTP Header`  + `HTTP Body` 整个加密的 

Header信息：

![图片](/assets/image/2024-08-07-Android网络/219468857cfb92c3259500c50127809677acf1.png) 

使用`wireshark`抓包：

![图片](/assets/image/2024-08-07-Android网络/c2d1ad58957c0d25d0e332b31fc42800724fd3.png) 

具体`TLS`协议：

TLS 在实现上分为握手协议和记录协议两层：

- `TLS 握手协议` 就是我们说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- `TLS 记录协议`负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

握手协议（四次握手）：

参考https://www.51cto.com/article/639455.html

![img](/assets/image/2024-08-07-Android网络/7462cba50570e10cf870aa37942cb0b6.png)

其中每一个「框」都是一个记录(record)，记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。

 使用wireshark抓包：

![img](/assets/image/2024-08-07-Android网络/8479801f4e5fa9b6e2281b63e715549f.png) 

对上图进一步解释：![img](/assets/image/2024-08-07-Android网络/fffec196ca1d8597a971562def321124.png) 

关于第三次握手：

客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。 

至此，客户端和服务端双方都共享了 `三个随机数`，分别是 `Client Random、Server Random、pre-master`。

于是，**双方根据已经得到的三个随机数，生成会话密钥(Master Secret)**，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。

关于 `change cipher spec`，他仅仅是一个指示，告诉服务端开始使用加密方式发送消息。 ！！！

可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。 

记录协议：

参考https://www.51cto.com/article/716295.html

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：

![图片](/assets/image/2024-08-07-Android网络/e2e0afe05e89a8ee23e94476c8a99a1fc6bd3c.png) 



- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
- 接下来，经过压缩的片段会被加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的加密报文数据。

记录协议完成后，**最终的加密报文数据将传递到传输控制协议 (TCP) 层进行传输**。（==*从上到下的一个过程*==）



### Android网络常用框架

参考https://cloud.tencent.com/developer/article/2215539

![Android网络框架选择（Volley、OkHttp、Retrofit）_封装](/assets/image/2024-08-07-Android网络/332fd0a1916fa9d271b62899d7866f8e.webp) 

#### 1、Retrofit

Retrofit 是 Square 公司出品的 HTTP 请求库, 同时是 Square 是最早开源项目之一, Retrofit 是目前 Android 最流行的 Http Client 库之一

官网地址 [Retrofit](https://cloud.tencent.com/developer/tools/blog-entry?target=http%3A%2F%2Fsquare.github.io%2Fretrofit%2F)

github [https://github.com/square/retrofit](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fretrofit)

#### 2、okhttp

OkHttp 是 Square 公司出品的 HTTP 另一个请求库, Google 不推荐人们使用 HttpClient, 可是 HttpURLConnection 实在是太难用了, 因此很多人使用了 OkHttp 来解决这问题, 据说 Android4.4 的源码中可以看到 HttpURLConnection 已经替换成 OkHttp 实现

他与HttpClient的相似之处在于都可将网络看作一个Client，并通过Client执行一个封装的request再从执行的结果Response中获取数据。

不同的是，OkHttp中Client并非直接execute而是newCall返回一个Call对象，在Call对象中我们可以使用同步的方式处理或者异步的方式处理，并且可以控制这条请求的开关call.cancel()

![android 框架 网络状态 android常用网络框架_Retrofit_03](/assets/image/2024-08-07-Android网络/19165053_650960edb020885315.gif) 

官网地址 [http://square.github.io/okhttp/](https://cloud.tencent.com/developer/tools/blog-entry?target=http%3A%2F%2Fsquare.github.io%2Fokhttp%2F)

github [https://github.com/square/okhttp](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fokhttp)

一般使用：https://github.com/zhu6201976/OkHttp3Test/blob/main/app/src/main/java/com/tesla/okhttp3test/MainActivity.java



#### 3、vollery

vollery 是谷歌官方开发团队在 2013 年 Google I/O 大会推出的一个新的网络通信框架, 这个框架把 AsyncHttpClient 和 Universal-Image-Loader 的优点集于了一身,既可以像AsyncHttpClient 一样非常简单地进行 HTTP 通信,也可以像 Universal-Image-Loader 一样轻松加载网络上的图片。

github [https://github.com/google/volley](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Fvolley)

Volley停止了更新

三者对比分析：

参考链接https://blog.51cto.com/u_11176305/3797272



### Builder设计模式

参考链接https://blog.51cto.com/u_15954040/6166402

为一个Bean构建成员变量或者构建参数，常用的方法有`使用构造函数`、`使用JavaBean的set()方法`。

`Builder`采用简洁明了的使用方式，灵活多变的链式调用，使得多个参数的Bean的构建变得十分简洁。

实例：

```java
package tech.liujintao.leetcode;

public class Student {

    private final String name;
    private final int id;
    private final int age;
    private final int height;

    private Student(StudentBuilder studentBuilder) {
        this.name=studentBuilder.name;
        this.id =studentBuilder.id;
        this.age = studentBuilder.age;
        this.height = studentBuilder.height;
    }

    public static class StudentBuilder
    {
        private String name;
        private int id;
        private int age;
        private int height;

        public StudentBuilder(String name,int id)
        {
            this.name = name;
            this.id = id;
        }

        public StudentBuilder age(int age)
        {
            this.age=age;
            return this;
        }

        public StudentBuilder height(int height)
        {
            this.height = height;
            return this;
        }

        public Student build()
        {
            return new Student(this);
        }
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }

    public int getAge() {
        return age;
    }

    public int getHeight() {
        return height;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", age=" + age +
                ", height=" + height +
                '}';
    }

    public static void main(String[] args) {
        Student student = new StudentBuilder("codingway",111).age(18).height(2).build();
        System.out.println(student.toString());
    }
}
```

首先将Student类中的成员变量都声明为private final，并且将构造函数也声明为private，这样子就保证了无法通过Student的构造函数在构建Student Bean，并且成员变量也无法被修改，对外只提供getter方法用于或者成员变量。

随后构造一个StudentBuilder类，StudentBuilder类是一个静态类 ，其构造函数可以设置为Student必须的属性，例如id和name，其他可选的变量放到方法中，例如age和height,每个方法返回StudentBuilder本身。

Student对象只有一个构造函数，其参数就是StudentBuilder，于是所有成员变量地设置由StudentBuilder接管了，而StudentBuilder控制了哪些成员变量必须赋值，哪些是可选的，最后通过build方法构造Student Bean。使用者一目了然，链式调用更加清晰。

### okhttp框架

#### 介绍：

`okhttp`因其稳定、开源、简单易用被众多的app开发人员所使用。okhttp中的execute和enqueue分别为发出同步和异步请求，通过对okhttp发起请求的整个流程进行简单分析就可以快速得到合适的hook点完成对app网络请求的抓包和溯源。但是，为了防止被快速逆向分析，部分app针对okhttp的代码进行了混淆，请以课程中的被混淆了的okhttp框架的apk为例，提出针对混淆了的okhttp框架，进行抓包和溯源的通用解决方案。 

理解okhttp框架（请求流程）：https://juejin.cn/post/7133035728212066318

https://www.jianshu.com/p/3a8d9d0cccb5：这篇讲的非常好！！！

https://www.jianshu.com/p/5061860545ef：从另一个角度讲解okhttp

![1701156626535](/assets/image/2024-08-07-Android网络/1701156626535.png)

#### 主要使用类：

+ OkHttpClient类 

  + **主要职责**就是让用户配置一些请求参数（如interceptor、connectTimeout等等），采用建造者模式通过Builder类去配置OkHttpClient的成员变量，最后调用build方法创建出OkHttpClient实例。 下面是一些主要成员变量
    + dispatcher: Dispatcher，用于调度网络请求的分发器
    + interceptors: `MutableList<Interceptor>`，拦截器集合
    + networkInterceptors: `MutableList<Interceptor>`，用户自定义的网络拦截器
    + connectionPool: ConnectionPool，连接池
    + protocols: `List<Protocol>`，支持的Http协议版本，即HTTP/1.1、HTTP/2等
    + cache: Cache，缓存配置，默认是没有
    + cookieJar: CookieJar，cookie配置
    + callTimeout: Int，请求超时，默认是0
    + connectTimeout: Int，连接超时，默认10秒
    + readTimeout: Int，读取超时，默认10秒
    + writeTimeout: Int，写入超时，默认10秒
    + pingInterval: Int，发送ping指令间隔，与WebSocket有关，为了保持长连接
    + retryOnConnectionFailure: Boolean，连接失败是否重连
    + followRedirects: Boolean，是否重定向
    + ollowSslRedirects: Boolean，是否从HTTP重定向到HTTPS
    + hostnameVerifier: HostnameVerifier，域名校验
    + eventListenerFactory: EventListener.Factory，Call的生命周期监听器

+ Request类

  + **主要职责**与OkHttpClient类相似，也是用来配置请求参数的，通过Builder类去配置以下的参数： 
    + url: HttpUrl，请求url
    + method: String，请求方法，如果没有指定的话会默认配置GET
    + headers: Headers，请求头
    + body: RequestBody，请求体
    + tags: Map<Class<*>, Any>，请求标签

+ RealCall类

  + 在OkHttpClient对象调用newCall方法创建Call的时候实际上就会进入到RealCall类中： 
  + 构建Call的工作是由RealCall去做的，RealCall是连接应用和网络层的桥梁，通过调用RealCall的同步请求execute方法或异步请求enqueue方法发起请求最后拿到Response 
    + newCall （）
    + execute() 
    + getResponseWithInterceptorChain() 
    + enqueue(responseCallback: Callback)

+ Async类

  + 是定义在RealCall类中的一个内部类，AsyncCall实现了Runnable接口，里面主要是executeOn方法和重写了run方法 
  + 线程池，并调用这个线程池执行请求 

+ Dispatcher类

  + 无论是同步请求还是异步请求，都会进入到分发器Dispatcher中做相应的处理 
  + Dispatcher的**主要职责**就是用来调度Call对象的，内部维护了一个线程池和一些同步/异步请求队列，用于存放和调度Call 

   

==不管是同步请求还是异步请求，最终都会调用的一个方法，得到网络请求响应结果Response，就是getResponseWithInterceptorChain()方法。== 



#### 	理解 **拦截器链**：	

https://juejin.cn/post/7133412826722336805

简单介绍：拦截器链是整个OkHttp框架的核心所在，用户发起的请求经过拦截器链的层层拦截获取Response，Response根据拦截器链原路返回最终到达用户手上，整个拦截器链的实现使用了**责任链设计模式**，其中的每个拦截器只需要关心自己的职责而不需要对上一个或下一个拦截器负责。拦截器链具体是怎么实现的，是如何工作的，本文将对此进行详细分析。![拦截器流程图.png](/assets/image/2024-08-07-Android网络/03785a6af00148e591f81391af3615dc-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 



每个链，都有一个 `process`函数，用于处理 `resquest`并返回 `response`

各个拦截器解释：

+ 应用拦截器：这是用户自定义的Interceptor，在初始化OkHttpClient的时候进行配置（也可以不配置），在拦截器链中的处理优先级最高，可以用于添加自定义header、自定义log配置、参数加密等；
+ RetryAndFollowUpInterceptor：失败重试和重定向拦截器，这个拦截器的主要职责就是当请求失败的时候自动重试，并根据需要进行网络重定向；
+ BridgeInterceptor：桥接拦截器，是连接应用层和网络层的桥梁，负责将用户的请求包装成服务端所需的请求，例如往请求头添加Content-Type、Content-Length、Host等等，并将服务端返回的响应转换成用户所需的响应，例如移除响应头中的Content-Encoding、Content-Length等等。如果响应用了gzip压缩过，则会对响应进行解压；
+ CacheInterceptor：缓存拦截器，主要负责处理缓存中的请求和将服务器返回的Response写入缓存，如果命中强制缓存的话会直接返回Response而不会走后续的拦截器发起网络请求；
+ ConnectInterceptor：连接拦截器，主要负责真正和服务器建立起连接；
+ networkInterceptors：用户自定义的网络拦截器，本质上跟第一个拦截器一样，这个拦截器通常用于监控网络层的数据传输，可以按需配置；
+ CallServerInterceptor：请求拦截器，在这个拦截器中真正发起了网络请求，并对服务器返回的Response进行解析，由于这是拦截器链中的最后一个拦截器，这里最终拿到Response之后就会直接将Response沿着拦截器链往回传送。



CallServerInterceptor

**主要处理数据流的发送和接收** 

我自己看源码，感觉是在exchange 对应的 `Exchange`类中调用的这个方法；

之后有追踪到 `ExchangeCodec接口`的 `codec`实例对象。

#### okhttp 使用frida Hook

https://blog.csdn.net/H176Nhx7/article/details/120857519

#### 自定义一个拦截器

自定义一个拦截器，并添加到okhttp框架的拦截器链中。如Yang神的实现（*https://bbs.pediy.com/thread-252129.htm*） Yang神的进阶：https://cloud.tencent.com/developer/article/1669631

App不可能发送一次请求就创建一个client客户端，往往是全局一个client， 

Frida有spawn和attach两种启动方式，接下来使用Spawn模式和Attach模式分别测试，attach模式下，Frida会附加到当前的目标进程中，即需要App处于启动状态，这也意味着只能从当前时机往后Hook，而spawn模式下，Frida会自行启动并注入进目标App，Hook的时机非常早，好处在于不会错过App中相对较早(比如App启动时产生的参数),缺点是假如想要Hook的时机点偏后，则会带来大量干扰信息，严重甚至会导致server崩溃。 

App全局只有一个client，因此它在App启动的较早时机被创建，如果采用attach模式Hook OkhttpClient，大概率会一无所获。六月天想看樱花——你来晚了。 

代码分析：

实现自定义的 `Interceptor`：



```js

```

Java层面的拦截器逻辑在Frida中编写多少有些不自在，有隔靴搔痒之感。 

Frida提供了如下API用于将DEX加载进内存，从而使用DEX中的方法和类，因为DEX是外来之物，因此称为天外飞仙。 

> Java.openClassFile(dexPath).load(); 

接下来我们取出App中的DEX，如果有多DEX，则用JADX查看想要使用的类在哪一个DEX中，最后push到手机，最后调用。 

这样就可以使用现有的dex文件（需要注意的是，无法加载JAR包） ：

```js
function hook_okhttp3() {
    Java.perform(function () {

        Java.openClassFile("/data/local/tmp/classes.dex").load();
        var MyInterceptor = Java.use("com.r0ysue.learnokhttp.MyInterceptor");

        var MyInterceptorObj = MyInterceptor.$new();
        var Builder = Java.use("okhttp3.OkHttpClient$Builder");
        console.log(Builder);
        Builder.build.implementation = function () {
            this.interceptors().add(MyInterceptorObj);
            return this.build();
        };


        console.log("hook_okhttp3...");
    });
}

hook_okhttp3();
```

可以发现整体代码量大减，这是因为原先创建拦截器类的逻辑被写在了dex中。 

#### hook RealCall类的enqueue和execute方法 

hook RealCall类的enqueue和execute方法，获取到返回的response对象。然后逐步解析出请求和响应的内容。（如*https://github.com/siyujie/OkHttpLogger-Frida*） 

#### 寻找okhttp特征

*https://github.com/siyujie/okhttp_find* 

关于这个库的使用方法：https://blog.csdn.net/qq_36535153/article/details/124073812

该`github`上的方法如下:

1. 先去所有可能属于okhttp框架层的类中找到OkHttpClient$Builder内部类。该类的特征为有四个List类型的成员变量，其中两个有final修饰符，两个的列表类型为接口类型 
2. 一旦找到满足这个条件的类，就可以通过getEnclosingClass方法获取该类的外部类，也就定位到了关键类OkHttpClient。 
3. 接着就以OkHttpClient和OkHttpClient$Builder为起点，根据成员变量的类型或是成员方法的参数和返回值类型不断定位到后续要用到的类、方法和变量。 

 https://blog.csdn.net/baidu_41678158/article/details/128513408

==即使被混淆，还是可以通过打印出的调用堆栈与正常的堆栈对比，定位到关键类和方法==

 **如何做到不依赖函数名实现混淆okhttp的抓包** ？

hook一个只有一个方法的类，这样只要hook那个方法就不会错。而这个方法又是okhttp请求链中的关键一环。Okhttp中正好有多个这样的待选类，都是Interceptor接口的实现类。它只有一个intercept方法 。

通过hook NativeCrypto类的SSL_write方法，得到一下调用栈： 

：可以看到最后一个Interceptor为CallServerInterceptor，混淆后的类名为okhttp3.internal.b.b 



#### 数据加密处理

这是一种新的数据处理方法

有的APP为了防止抓取，在返回的内容上做了层加密，所以从Charles上看到的内容是乱码。这种情况下也只能反编译APP，研究其加密解密算法进行解密。难度极大 

目前在网络请求类里添加拦截器，然后在拦截器中处理request请求和response响应数据的加密和解密操作 

在request请求数据阶段，如果是get请求加密url数据，如果是post请求则加密url数据和requestBody数据，以及response响应数据

### certificate pinning证书绑定

https://labs.nettitude.com/tutorials/tls-certificate-pinning-101/

pin（固定） 什么：

+ certificate
+ public key
+ hash值

在哪里pin（固定）

+ 服务器证书
+ 中间证书
+ 整个证书链

#### where to pin？

+ leaf certificate
  + 几乎100%这是你的证书，及时CA泄露
  + 由于某种原因证书无效，则程序将被阻塞，直到推送正确的证书
  + 匀允许自签名证书，从易于维护的角度来看，这可能是一件好事 
+ root certificate
  + 则表示你信任根证书颁发机构以及他们信任的任何中介机构不会错误颁发证书 
  + 如果 CA 受到威胁，游戏就结束了
+ Intermediate certificate:
  + 相信中间证书颁发机构不会错误地为您的服务器颁发证书 

#### pin what

+ 证书
  + 通常证书是最容易固定的
  + 在运行时，您检索网站或服务器的证书，您将检索到的证书与应用程序中嵌入的证书进行比较
  + 如果站点/服务定期轮换其证书，那么您的应用程序将需要定期更新
+ 公钥
  + 更灵活
  + 由于从证书中提取公钥需要额外的步骤，因此有点棘手 
  + 与证书一样，程序会检查提取的公钥及其嵌入的公钥副本
+ hash值
  + 允许您**匿名化证书**或公钥 
    + 如果您的应用程序担心在反编译和逆向工程期间泄漏信息，这可能很重要
  + 容易计算，很多库都提供
  + 提供备用身份，以防主要身份遭到泄露 



#### How to pin：

建议将证书、其公钥或其安全散列**嵌入到应用程序**中，并配备强大的**混淆**和**篡改检测**机制 

常见的`pin`方法：

1. *通过创建一个扩展`X509TrustManager` 的*新类并在`*checkServerTrusted*`方法中实现定制证书检查，之后实例化`SSLContext`
2. 通过创建一个空的`KeyStore`，向其中添加相关证书，然后：
   1. 使用此`*KeyStore*`初始化`*TrustManagerFactory*`；
   2. 使用此`*TrustManagerFactory*`初始化`*SSLContext*`



通过方法2：我们可以这样绕过：

1. 重载*TrustManagerFactory*的*init*方法；（会导致*TrustManagerFactory*会使用系统的默认密钥进行初始化存储 – 即系统信任的证书和 CA 
2. 将其调用记录到标准输出；
3. *使用null*作为参数调用原始方法。

**常用的类：** 

- *X509TrustManager*
- *checkServerTrusted*
- *SSLContext*
- *X509Certificate*
- *TrustManager*
- *TrustManagerFactory*
- *CertificateFactory*
- *CertPathValidator*
- *PKIXParameters*
- *CertPath*
- *KeyStore*

当然由于 ==code obfuscation== 代码混淆，我们通常无法直接通过搜索`类名`，来得到这些类，



## Pinning Bypass证书绑定绕过

[参考文章链接](https://bbs.kanxue.com/thread-278142.htm)

### app端验证

#### 1. 公钥校验

##### 源码分析

- 证书公钥校验的代码 一般来说是使用同的网络请求框架，大多都是Okhttp3
- 主要使用CertificatePinner类配合OkHttpClient

```java
private void doRequest(){
       new Thread(){
           @Override
           public void run() {
                final  String CA_PUBLIC_KEY = "sha256/kO7OP94daK9P8+X52s00RvJLU0SiCXA9KAg9PelfwIw=";
                final  String CA_DOMAIN = "www.52pojie.cn";
                //校验公钥，使用 CertificatePinner，您可以为每个域名指定一个公钥，当客户端尝试连接到该域名时，它将只接受具有指定公钥的证书。add(CA_DOMAIN, CA_PUBLIC_KEY)指明当访问domin CA_DOMAIN时，只接受公钥为CA_PUBLIC_KEY的证书。
               CertificatePinner buildPinner = new CertificatePinner.Builder()
                                                   .add(CA_DOMAIN, CA_PUBLIC_KEY)
                                                   .build();
               // 通过Builder，设置buildPinner。确保客户端只连接到具有正确证书的服务器
                   OkHttpClient client = new OkHttpClient.Builder().certificatePinner(buildPinner).build();
 
               Request req = new Request.Builder().url("https://www.52pojie.cn/forum.php")
                       .build();
               Call call = client.newCall(req);
               try {
                   Response res = call.execute();
                   Log.e("请求成功", "状态码：" + res.code());
               } catch (IOException e) {
                   e.printStackTrace();
                   Log.e("请求失败", "异常" + e);
               }
 
           }
       }.start();
    }

```

```
这是相应的具体执行检测的源码：
```

![1700017273430](/assets/image/2024-08-07-Android网络/1700017273430.png)	下面是逻辑的具体步骤：

1. `val pins = findMatchingPins(hostname)`：通过调用 `findMatchingPins` 函数，获取与给定主机名匹配的固定证书列表。
2. `if (pins.isEmpty()) return`：如果没有找到与主机名匹配的固定证书，就直接返回，表示通过验证。
3. `val peerCertificates = cleanedPeerCertificatesFn()`：调用传入的 lambda 函数，清理和转换对等证书列表。
4. 遍历对等证书列表：

   - 对每个证书，根据固定证书列表中的算法，计算其 SHA-256 或 SHA-1 散列值。
   - 将计算得到的散列值与固定证书列表中的散列值进行比较，如果匹配，则验证通过，直接返回。
5. 如果所有对等证书都没有与固定证书列表匹配的项，就构造一个异常信息，并抛出 `SSLPeerUnverifiedException` 异常，表示证书固定失败。

   “**对等证书**”通常指的是由服务器提供给客户端的SSL/TLS证书，而“**固定证书**”则是客户端事先配置的一组预期证书的散列值（hashes），是构造时候传入的《host，hashValue》。

##### 绕过方法

相应hook代码：hook check函数，了解过原理之后就很简单了，我们直接修改传入的host参数即可，

```javascript
Java.perform(function () {
	// Invalidate the certificate pinner set up
    var OkHttpClient = Java.use("com.squareup.okhttp.OkHttpClient");
    OkHttpClient.setCertificatePinner.implementation = function(certificatePinner){
        // do nothing
    	console.log("Called!");
    	return this;
    };

    // Invalidate the certificate pinnet checks (if "setCertificatePinner" was called before the previous invalidation)
    var CertificatePinner = Java.use("com.squareup.okhttp.CertificatePinner");
    CertificatePinner.check.overload('java.lang.String', '[Ljava.security.cert.Certificate;').implementation = function(p0, p1){
        // do nothing
        console.log("Called! [Certificate]");
        return;
    };
    CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(p0, p1){
        // do nothing
        console.log("Called! [List]");
        return;
    };
});
```

#### 2.证书校验

##### 源码分析

其实就是把证书内置到资源文件目录![1699882259403](/assets/image/2024-08-07-Android网络/1699882259403.png)校验的核心逻辑：自定义的`trustManager` 类实现的checkServerTrusted接口 。

`X509TrustManager` 是 Java 中用于管理 X.509 证书的类，它属于 `javax.net.ssl` 包。`X509TrustManager` 用于管理客户端与服务器之间的 SSL/TLS 连接的信任管理器。

在 SSL/TLS 握手期间，客户端会验证服务器的身份，确保它正在连接到正确的服务器。服务器也会验证客户端的身份，以确保客户端是授权访问该服务的。**`X509TrustManager` 用于管理和验证这些证书**。

核心原理是通过信任锚点（Trust Anchors）和证书链验证来判断远程服务器的证书是否可信。以下是其工作原理的基本步骤：

1. **信任锚点（Trust Anchors）：**
   - 信任锚点是一个已知和可信任的证书集合，通常是一组根证书（Root Certificates）。
   - 这些根证书是由操作系统或Java运行时环境预先配置的，或者是应用程序自定义的。
   - 服务器提供的证书链的顶层证书必须是信任锚点中的一员，否则验证失败。
2. **证书链验证：**
   - 服务器在SSL/TLS握手过程中发送其证书链给客户端。
   - 客户端使用`X509TrustManager`的实现来验证证书链的有效性，这涉及到检查每个证书的签名是否有效、证书是否过期，以及是否在信任锚点中找到了匹配的证书。
   - 验证过程从服务器提供的证书链的顶部开始，也就是根证书，逐级向下验证，确保每个证书都能够被下一个证书签名。
3. **过期检查：**
   - 检查证书是否在有效期内。证书包含开始生效和过期的日期，客户端需要确保当前日期在这两个日期之间。
4. **Revocation（吊销）检查：**
   - 检查证书是否被吊销（revoked）。某些情况下，证书在其有效期内可能会被吊销，因此需要检查证书是否在吊销列表中。
5. **主机名验证：**
   - 针对服务器的主机名执行验证，确保服务器证书的主体与客户端试图连接的主机名匹配。这是防范主机名欺骗的关键部分。

```java
private void doRequest2(){
        X509TrustManager trustManager = new X509TrustManager() {
            // 服务器验证客户端证书，这里因为是客户端验证，所以不写具体验证方法，
            @Override
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
 
            }
 			// 客户端验证服务器证书；checkServerTrusted 是 X509TrustManager 类中的一个方法，用于验证服务器提供的证书链是否可信。方法参数 X509Certificate[] chain 是一个包含服务器证书链的数组。通常情况下，服务器在 SSL/TLS 握手期间会向客户端发送其证书，以及与该证书相关的链。链可能包括服务器的公钥证书、中间证书和根证书。checkServerTrusted 方法会验证这些证书是否可信，例如检查证书是否被吊销、是否过期、是否由受信任的颁发机构签发等。如果您需要对特定的服务器证书进行验证，您应该将包含该服务器证书及其链的数组传递给 checkServerTrusted 方法。您可以从服务器获取该证书链，然后将其封装在一个数组中，并将其作为参数传递给 checkServerTrusted 方法。参数 authType 表示在进行证书链验证时使用的密钥交换算法
            @Override
            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                //服务器返回的证书，chain[length-1]是根证书
                X509Certificate cf = chain[0];
                //转换为RSA的公钥
                RSAPublicKey rsaPublicKey = (RSAPublicKey) cf.getPublicKey();
                //Base64 encode
                String ServerPubkey = Base64.encodeToString(rsaPublicKey.getEncoded(), 0);
                Log.e("服务器端返回的证书",ServerPubkey);
 
                //读取客户端资源目录中的证书
                InputStream client_input = getResources().openRawResource(R.raw.pojie);
                // 创建一个x.509的证书工厂，这个类是 Java 中用于处理证书工厂的抽象类。它提供了一种标准的方式来处理 X.509 证书和其他证书格式。CertificateFactory 允许开发者将证书编码为不同的格式，或者从不同的格式解码为 Java 对象。
                CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                X509Certificate realCertificate = (X509Certificate) certificateFactory.generateCertificate(client_input);
                // 提取文件中的realpubkey
                String realPubkey = Base64.encodeToString(realCertificate.getPublicKey().getEncoded(), 0);
                Log.e("客户端资源目录中的证书",realPubkey);
 				// 检查证书是否在有效期内
                cf.checkValidity();
 				// 检查证书是否与信任锚点匹配
                final  boolean expected = realPubkey.equalsIgnoreCase(ServerPubkey);
                Log.e("eq = ",String.valueOf(expected));
 
                if (!expected){
                    throw new CertificateException("证书不一致");
                }
 
            }
 			// // 返回信任锚点中的证书数组
            @Override
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }
        };
 			// 这个实例用于创建加密的 SSLSocket，factory熟悉啊，之前也遇到过，管理一切与sslsocket创建、关闭等有关的实例。是 Java 中用于创建和配置 SSLSocket 实例的工厂类，主要用于支持安全的 SSL/TLS 连接。在 Android 和 Java 中，SSLSocketFactory 通常用于配置 HttpsURLConnection 或者类似的网络库，以实现对 HTTPS 请求的支持。SSLSocketFactory 是一个工厂类，用于创建 SSLSocket 实例，支持安全的 SSL/TLS 连接。
            SSLSocketFactory factory = null;
 
        try {
            // SSLContext 初始化，获取标准ssl上下文实例，SSLContext 是 Java 中负责管理 SSL/TLS 安全连接的核心类，用于创建和初始化 SSLSocket 实例。
            SSLContext sslContext = SSLContext.getInstance("SSL");
 			// 用于初始化 SSL 上下文，null 表示使用默认的密钥管理器（KeyManager）和默认的随机数生成器（SecureRandom），new TrustManager[]{trustManager} 指定了自定义的 TrustManager 实现，用于服务器证书验证。
            sslContext.init(	null,new TrustManager[]{trustManager},new SecureRandom());
 			//  返回一个 SSLSocketFactory 实例，
            factory = sslContext.getSocketFactory();
        } catch (Exception e) {
            e.printStackTrace();
        }
 
        SSLSocketFactory finalFactory = factory;
 
        new Thread(){
            @Override
            public void run() {
 
                try {
                    // 创建 OkHttpClient，将这个 SSLSocketFactory 实例传递给 OkHttpClient，以便在发送 HTTPS 请求时使用自定义的 SSL 上下文和证书验证。
                    OkHttpClient client = new OkHttpClient.Builder().sslSocketFactory(finalFactory, trustManager).build();
                    Request req = new Request.Builder().url("https://www.52pojie.cn/forum.php").build();
 
                    Call call = client.newCall(req);
 
                    Response res = call.execute();
 
                    Log.e("请求发送成功","状态码：" + res.code());
                } catch (IOException e) {
                    Log.e("请求发送失败","网络异常" + e);
                }
 
            }
        }.start();
 
    }


```

- 这个一般是自定义的类然后实现了这个trustManager的接口 ，所以不确定这个类在哪，不容易hook
- 但是定义好trustManager会传入sslcontext初始化以及okhttp build时候

##### 绕过方法

要是能知道具体类的地方，则我们只需要hook类中的checkServerTrusted方法即可

但是不可行，但是我们可以实现这样：

+ **实例化一个trustManager类，然后里面什么都不写，当上面两处调用到这个类时hook这两个地方，把自己定义的空trustManager类放进去，这样就可以绕过,参考下面的frida脚本**：它的目的是在 SSLContext 初始化时替换默认的 TrustManager，以绕过证书验证，特别是对于 Android 版本小于 7 的情况。

```javascript
// 获取具体的 TrustManager 和 SSLContext 类
var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
        var SSLContext = Java.use('javax.net.ssl.SSLContext');
       
        // TrustManager (Android < 7) //
        ////////////////////////////////
//这里注册了一个名为 dev.asd.test.TrustManager 的类，实现了 X509TrustManager 接口，但是它的实现方法都是空的，即不做实际的证书验证工作。
        var TrustManager = Java.registerClass({
            // Implement a custom TrustManager
            name: 'dev.asd.test.TrustManager',
            implements: [X509TrustManager],
            methods: {
                checkClientTrusted: function(chain, authType) {},
                checkServerTrusted: function(chain, authType) {},
                getAcceptedIssuers: function() {return []; }
            }
        });
        // 准备 TrustManager 数组用于传递给 SSLContext.init()：
        var TrustManagers = [TrustManager.$new()];
        // 获取 SSLContext.init 方法的句柄。
        var SSLContext_init = SSLContext.init.overload(
            '[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom');
	// 具体替换实现
        try {
            // Override the init method, specifying the custom TrustManager，替换 init 方法的实现：当 SSLContext 初始化时，将默认的 TrustManager 替换为自定义的 TrustManager，实现了绕过证书验证的目的。
            SSLContext_init.implementation = function(keyManager, trustManagers, secureRandom) {
                console.log('[+] Bypassing Trustmanager (Android < 7) pinner');
                SSLContext_init.call(this, keyManager, TrustManagers, secureRandom);
            };
        } catch (err) {
            console.log('[-] TrustManager (Android < 7) pinner not found');
            //console.log(err);
        }
```

js脚本中使用到了`Java.registerClass` ，这是 Frida 中的一个函数，用于在运行时动态注册一个 Java 类。这个函数允许你在 JavaScript 代码中创建一个 Java 类，并为其指定一些特定的实现，比如实现接口、继承父类等。

```javascript
var MyClass = Java.registerClass({
    name: 'com.example.MyClass', // 类的完整路径
    implements: ['java.lang.Runnable'], // 实现的接口，可选
    extends: 'java.lang.Object', // 继承的父类，可选
    methods: {
        myMethod: function() {
            // 自定义方法实现
        }
    }
});

// 举个例子
var TrustManager = Java.registerClass({
    name: 'dev.asd.test.TrustManager',
    implements: [X509TrustManager],
    methods: {
        checkClientTrusted: function(chain, authType) {},
        checkServerTrusted: function(chain, authType) {},
        getAcceptedIssuers: function() {return []; }
    }
});
```

`TrustManager.$new()` 是 Frida 中的语法，用于创建一个 Java 对象的实例。在 Frida 的 JavaScript API 中，`$new` 方法用于实例化 Java 类的对象。

#### 3.host（域名校验）

##### 源码分析

一个证书可能对应有很多域名都可以使用，但是开发者只想让当前的应用证书校验通过后只能往指定的域名发送请求，而不想证书校验通过后往其他可以校验证书通过的域名发送请求。（证书允许往很多域名发送请求，但是app限制只能往特定域名发送请求）

`HostnameVerifier` 是 Java 中用于实现主机名验证逻辑的接口。在使用 HTTPS 连接时，主机名验证是确保你连接的是期望的服务器的关键部分。它通常用于验证服务器证书中的主机名与实际连接的主机名是否匹配，以防止中间人攻击。

接口中的 verify方法，

- `hostname` 参数是服务器主机名。
- `session` 参数是与当前连接关联的 SSL 会话。

可以通过这个方法来进行主机名验证。如果主机名验证成功，`verify` 方法应该返回 `true`，否则返回 `false`。默认的主机名验证规则是比较服务器证书中的主机名与实际连接的主机名是否一致。

```java
private void doRequest3(){
 
       HostnameVerifier verifier =  new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
 
                if ("www.52pojie.cn".equalsIgnoreCase(hostname)){
                    return true;
                }
                return false;
            }
        };
 
        new Thread() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient.Builder().hostnameVerifier(verifier).build();
                    Request req = new Request.Builder().url("https://www.52pojie.cn/forum.php").build();
                    Call call = client.newCall(req);
 
                    Response res = call.execute();
                    Log.e("请求发送成功", "状态码：" + res.code());
 
                } catch (IOException ex) {
                    Log.e("Main", "网络请求异常" + ex);
                }
            }
        }.start();
 
    }
```

这里hook的关键也是，自己创建一个HostnameVerifier类实现的接口直接返回true，哪里调用传给哪里即可 ;

当你看到这行代码：

```java
OkHttpClient client = new OkHttpClient.Builder().hostnameVerifier(verifier).build();
```

我们逐步解释：

1. **new OkHttpClient.Builder()：**

   - 创建了一个 `OkHttpClient.Builder` 类的新实例。`Builder` 类是 OkHttp 库的一部分，用于构建和配置 `OkHttpClient` 实例。
2. **.hostnameVerifier(verifier)：**

   - 在 `OkHttpClient.Builder` 实例上调用了这个方法。它设置了客户端的主机名验证器。假设 `verifier` 是实现了 `HostnameVerifier` 接口的类的实例。主机名验证器负责验证服务器证书中的主机名是否与预期的主机名匹配。
3. **.build()：**

   - 在 `OkHttpClient.Builder` 实例上调用了这个方法。它完成了配置过程，构建了一个基于配置设置的 `OkHttpClient` 实例。
4. **OkHttpClient client = ...：**

   - 最终，得到的 `OkHttpClient` 实例被赋值给变量 `client`。

   因此很明显，我们只需要hook  OkHttpClient.Builder类即可![1700029459301](/assets/image/2024-08-07-Android网络/1700029459301.png)

##### 饶绕过方法

```javascript
function main() {
console.log('js loaded successfully!!');
Java.perform(function() {
	// 获取具体的 TrustManager接口 和 SSLContext 类
	var X509TrustManager = Java.use('javax.net.ssl.HostnameVerifier');
	var SSLContext = Java.use('okhttp3.OkHttpClient.Builder');


	//这里注册了一个名为 dev.asd.test.TrustManager 的类，实现了 X509TrustManager 接口，但是它的实现方法都是空的，即不做实际的证书验证工作。
	var TrustManager = Java.registerClass({
		// Implement a custom TrustManager
		name: 'dev.asd.test.TrustManager',
		implements: [X509TrustManager],
		methods: {
			verify: function (hostname, session) {return true },
		
		}
	});
	// 准备 TrustManager 数组用于传递给 SSLContext.init()：
	var TrustManagers = [TrustManager.$new()];
	// 获取 SSLContext.init 方法的句柄。
	var SSLContext_init = SSLContext.init.overload(
		'javax.net.ssl.HostnameVerifier');
	// 具体替换实现
	try {
		// Override the init method, specifying the custom TrustManager，替换 init 方法的实现：当 SSLContext 初始化时，将默认的 TrustManager 替换为自定义的 TrustManager，实现了绕过证书验证的目的。
		SSLContext_init.implementation = function (hostnameVerifier) {
			console.log('[+] Bypassing Trustmanager (Android < 7) pinner');
			// 替换成我们的对象
			hostnameVerifier = SSLContext_init;
		};
	} catch (err) {
		console.log('[-] TrustManager (Android < 7) pinner not found');
		//console.log(err);
	}

});
}
setTimeout(main());
```

### 服务器、客户端双认证实战：

[参考链接](https://blog.csdn.net/qq_38316655/article/details/104176882)

https://bbs.kanxue.com/thread-265404.htm

源apk文件失效了，等找到了再做吧

### 服务器端验证

#### 源码分析

1. **在客户端放入证书（p12/bks）**，客户端向服务端发送请求时，携带证书信息，在服务端会校验客户端携带过来的证书合法性

   - 在APK打包时，将证书放入assets或raw目录
   - 在开发代码时，发送请求读取证书文件内容+证书密码 携带发送到服务器端

   具体**实现原理：**

   客户端使用了 `KeyManager` 来提供客户端证书，它会在握手的 `Certificate` 部分附加客户端证书。这样，服务端在握手过程中收到了客户端的证书，便可以进行验证。验证成功后，建立安全的 SSL 连接。

   总体流程可能是这样的：

   - 客户端通过 `SSLContext.init` 方法配置了客户端证书和信任管理器。
   - 客户端启动握手，发送 `ClientHello`。
   - 如果服务器要求客户端提供证书，客户端发送 `Certificate` 和可能的 `CertificateVerify`。
   - 服务器验证客户端证书，如果成功，则继续握手。
   - 双方协商生成主密钥，之后的通信都基于该密钥进行加密解密。

   ```java
   private void doRequest4() {
           // 创建一个自定义的X509TrustManager实例，用于信任所有客户端证书
           X509TrustManager trustManager = new X509TrustManager() {
               @Override
               public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                   // 不对客户端证书进行验证，接受所有客户端证书
               }

               @Override
               public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                   // 不对服务器证书进行验证，接受所有服务器证书
               }

               @Override
               public X509Certificate[] getAcceptedIssuers() {
                   // 返回空数组，表示不认任何颁发机构的证书
                   return new X509Certificate[0];
               }
           };

           // 创建一个自定义的HostnameVerifier实例，用于信任所有主机名
           HostnameVerifier verify = new HostnameVerifier() {
               @Override
               public boolean verify(String hostname, SSLSession session) {
                   // 信任所有主机名
                   return true;
               }
           };

           new Thread() {
               @Override
               public void run() {
                   try {
                       // 从资源文件加载客户端证书
                       InputStream client_input = getResources().openRawResource(R.raw.client);
                       Log.e("x", client_input.getClass().toString());

                       // 创建SSLContext实例，用于配置SSL/TLS通信
                       SSLContext sslContext = SSLContext.getInstance("TLS");

                       // 创建KeyStore实例，用于加载客户端证书
                       KeyStore keyStore = KeyStore.getInstance("PKCS12");
                       keyStore.load(client_input, "demoli666".toCharArray());

                       // 创建KeyManagerFactory实例，用于初始化KeyManager
                       KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
                       keyManagerFactory.init(keyStore, "demoli666".toCharArray());

                       // 初始化SSLContext，配置KeyManager和自定义的TrustManager
                       sslContext.init(keyManagerFactory.getKeyManagers(), new TrustManager[]{trustManager}, new SecureRandom());

                       // 获取SSLSocketFactory实例，用于创建SSLSocket
                       SSLSocketFactory factory = sslContext.getSocketFactory();

                       // 创建OkHttpClient实例，配置SSLSocketFactory和HostnameVerifier
                       OkHttpClient client = new OkHttpClient.Builder()
                               .sslSocketFactory(factory, trustManager)
                               .hostnameVerifier(verify)
                               .build();

                       // 构建HTTP请求
                       Request req = new Request.Builder().url("https://xxx.xxx.xxx.xxx:443/index").build();

                       // 发起同步HTTP请求
                       Call call = client.newCall(req);
                       Response res = call.execute();

                       // 打印请求结果
                       Log.e("请求发送成功", "状态码：" + res.code());
                   } catch (Exception e) {
                       // 捕获异常，打印错误信息
                       Log.e("请求发送失败", "网络异常" + e);
                   }
               }
           }.start();
       }
   ```

   #### 绕过方法

   这个使用之前的hook就不行了，因为执行验证实在服务器上，因此我们只能"**伪装！！！**"；

   方法：


   - 找到证书文件（bsk/p12）
   - 通过hook获取证书相关密码

   ```javascript
   Java.perform(function () {
       /**
        * 生成指定长度和基数的 UUID
        * @param len UUID 长度
        * @param radix 进制，默认为 chars.length
        * @returns {string} 生成的 UUID
        */
       function uuid(len, radix) {
           var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
           var uuid = [], i;
           radix = radix || chars.length;

           if (len) {
               // Compact form: 生成指定长度的 UUID，使用 chars 数组的字符
               for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random() * radix];
           } else {
               // rfc4122, version 4 form: 生成符合 rfc4122 标准的 UUID
               var r;

               // rfc4122 requires these characters
               uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
               uuid[14] = '4';

               // Fill in random data. At i==19 set the high bits of clock sequence as
               // per rfc4122, sec. 4.1.5
               for (i = 0; i < 36; i++) {
                   if (!uuid[i]) {
                       r = 0 | Math.random() * 16;
                       uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
                   }
               }
           }

           return uuid.join('');
       }

       /**
        * 将客户端证书和私钥保存为 p12 格式的文件
        * @param pri 客户端私钥
        * @param p7 客户端证书
        * @param p12Path 保存的 p12 文件路径
        * @param p12Password p12 文件密码
        */
       function storeP12(pri, p7, p12Path, p12Password) {
           var X509Certificate = Java.use("java.security.cert.X509Certificate");
           var p7X509 = Java.cast(p7, X509Certificate);
           var chain = Java.array("java.security.cert.X509Certificate", [p7X509]);

           // 创建 PKCS12 KeyStore 实例
           var ks = Java.use("java.security.KeyStore").getInstance("PKCS12", "BC");
           ks.load(null, null);

           // 将客户端私钥和证书链存入 KeyStore
           ks.setKeyEntry("client", pri, Java.use('java.lang.String').$new(p12Password).toCharArray(), chain);

           try {
               // 将 KeyStore 存储到文件
               var out = Java.use("java.io.FileOutputStream").$new(p12Path);
               ks.store(out, Java.use('java.lang.String').$new(p12Password).toCharArray());
           } catch (exp) {
               console.log(exp);
           }
       }

       /**
        * 重写 getPrivateKey 方法，在服务器校验客户端的情况下，dump 客户端证书，并保存为 p12 格式
        */
       Java.use("java.security.KeyStore$PrivateKeyEntry").getPrivateKey.implementation = function () {
           // 调用原始 getPrivateKey 方法获取客户端私钥
           var result = this.getPrivateKey();

           // 获取当前应用包名
           var packageName = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext().getPackageName();

           // 调用 storeP12 函数，保存客户端证书和私钥为 p12 文件
           storeP12(this.getPrivateKey(), this.getCertificate(), '/sdcard/Download/' + packageName + uuid(10, 16) + '.p12', 'r0ysue');

           // 返回原始 getPrivateKey 方法的结果
           return result;
       };

       /**
        * 重写 getCertificateChain 方法，在服务器校验客户端的情况下，dump 客户端证书，并保存为 p12 格式
        */
       Java.use("java.security.KeyStore$PrivateKeyEntry").getCertificateChain.implementation = function () {
           // 调用原始 getCertificateChain 方法获取客户端证书链
           var result = this.getCertificateChain();

           // 获取当前应用包名
           var packageName = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext().getPackageName();

           // 调用 storeP12 函数，保存客户端证书和私钥为 p12 文件
           storeP12(this.getPrivateKey(), this.getCertificate(), '/sdcard/Download/' + packageName + uuid(10, 16) + '.p12', 'r0ysue');

           // 返回原始 getCertificateChain 方法的结果
           return result;
       };
   });

   ```



### 针对Android系统库的绕过

[项目链接](https://codeshare.frida.re/@pcipolloni/universal-android-ssl-pinning-bypass-with-frida/)

```javascript
/* 
   Android SSL Re-pinning frida script v0.2 030417-pier 

   $ adb push burpca-cert-der.crt /data/local/tmp/cert-der.crt
   $ frida -U -f it.app.mobile -l frida-android-repinning.js --no-pause
*/

setTimeout(function(){
    Java.perform(function (){
    	console.log("");
        // 脚本开始信息
	    console.log("[.] Cert Pinning Bypass/Re-Pinning");
	
	    var CertificateFactory = Java.use("java.security.cert.CertificateFactory");
	    var FileInputStream = Java.use("java.io.FileInputStream");
	    var BufferedInputStream = Java.use("java.io.BufferedInputStream");
	    var X509Certificate = Java.use("java.security.cert.X509Certificate");
	    var KeyStore = Java.use("java.security.KeyStore");
	    var TrustManagerFactory = Java.use("javax.net.ssl.TrustManagerFactory");
	    var SSLContext = Java.use("javax.net.ssl.SSLContext");

	    // Load CAs from an InputStream
	    console.log("[+] Loading our CA...")
	    var cf = CertificateFactory.getInstance("X.509");
	  
	    try {
	    	var fileInputStream = FileInputStream.$new("/data/local/tmp/cert-der.crt");
	    }
	    catch(err) {
	    	console.log("[o] " + err);
	    }
	  
	    var bufferedInputStream = BufferedInputStream.$new(fileInputStream);
	  	var ca = cf.generateCertificate(bufferedInputStream);
	    bufferedInputStream.close();

		var certInfo = Java.cast(ca, X509Certificate);
	    console.log("[o] Our CA Info: " + certInfo.getSubjectDN());

	    // Create a KeyStore containing our trusted CAs
	    console.log("[+] Creating a KeyStore for our CA...");
	    var keyStoreType = KeyStore.getDefaultType();
	    var keyStore = KeyStore.getInstance(keyStoreType);
	    keyStore.load(null, null);
	    keyStore.setCertificateEntry("ca", ca);
	  
	    // Create a TrustManager that trusts the CAs in our KeyStore
	    console.log("[+] Creating a TrustManager that trusts the CA in our KeyStore...");
	    var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
	    var tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
	    tmf.init(keyStore);
	    console.log("[+] Our TrustManager is ready...");

	    console.log("[+] Hijacking SSLContext methods now...")
	    console.log("[-] Waiting for the app to invoke SSLContext.init()...")

	   	SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").implementation = function(a,b,c) {
	   		console.log("[o] App invoked javax.net.ssl.SSLContext.init...");
	   		SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").call(this, a, tmf.getTrustManagers(), c);
	   		console.log("[+] SSLContext initialized with our custom TrustManager!");
	   	}
    });
},0);
```

## 代理检测绕过：

一般情况下APP抓包中我们在手机设备上设置连接WIFI时会手动指定一个代理地址指向我们的Fiddler，我们在这种系统层面上设置了代理，某些http客户端在进行http请求前会先检查系统代理，如果有设置代理，客户端会拒绝连接，知道了原因，解决起来也就有思路了，只要想办法让客户端重新连接到代理服务器就可以了。：

### 重要介绍

在手机上设置代理时，推荐使用`VPN`来将流量导出到抓包软件上，而不是通过给`WIFI`设置`HTTP`代理的方式。使用`VPN`可以同时抓到`Http(s)`和`Socket`的包，且不管其来自`Java`层还是`so`层。我们常用的代理软件是老牌的`Postern`，开`VPN`服务通过连接到开启`Socks5`服务端的抓包软件，将流量导出去。

当然有些应用会使用`System.getProperty(“http.proxyHost”)、System.getProperty(“http.proxyPort”);`这两个`API`来查看当前系统是否挂了`VPN`，这时候只能用`Frida`或`Xposed`来`hook`这个接口、修改其返回值，或者重打包来`nop`掉。当然还有一种最为终极、最为强悍的方法，那就是制作路由器，抓所有过网卡的包。

制作路由器的方法也很简单，给笔记本电脑装`Kali Linux`，`eth0`口插网线上网，`wlan0`口使用系统自带的热点功能，手机连上热点上网。史上最强，安卓应用是无法对抗的。

### app代理检测：

[参考连接](https://www.cnblogs.com/zgq123456/articles/17460263.html)

#### 代理IP检测：

```java
private boolean isWifiProxy(Context context) {
    final boolean IS_ICS_OR_LATER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH;
    String proxyAddress;
    int proxyPort;
    if (IS_ICS_OR_LATER) {
        proxyAddress = System.getProperty("http.proxyHost");
        String portStr = System.getProperty("http.proxyPort");
        proxyPort = Integer.parseInt((portStr != null ? portStr : "-1"));
    } else {
        proxyAddress = android.net.Proxy.getHost(context);
        proxyPort = android.net.Proxy.getPort(context);
    }
    return (!TextUtils.isEmpty(proxyAddress)) && (proxyPort != -1);
}
```

```java
private boolean isWifiProxy(Context context) {
    final boolean IS_ICS_OR_LATER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH;
    String proxyAddress;
    int proxyPort;
    if (IS_ICS_OR_LATER) {
        proxyAddress = System.getProperty("http.proxyHost");
        String portStr = System.getProperty("http.proxyPort");
        proxyPort = Integer.parseInt((portStr != null ? portStr : "-1"));
    } else {
        proxyAddress = android.net.Proxy.getHost(context);
        proxyPort = android.net.Proxy.getPort(context);
    }
    return (!TextUtils.isEmpty(proxyAddress)) && (proxyPort != -1);
}
```

#### VPN代理：

```java
boolean checkVPN(ConnectivityManager connMgr) {
    //don't know why always returns null:
    NetworkInfo networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_VPN);
    boolean isVpnConn = networkInfo == null ? false : networkInfo.isConnected();
    return isVpnConn;
}
```

### 绕过方法

#### 方法1：

- **使用VPN将终端设备的流量转发到代理服务器**。优点是使用VPN软件不用添加其他软件就可以搞定此事。缺**点是需要在手机上安装软件**，受限于*Android*/IOS系统版本，软件版本等，必要时可能还需要root。[参考连接](https://itimetraveler.github.io/2019/07/25/%E3%80%90Android%E3%80%91%E4%BD%BF%E7%94%A8VPN%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/)

#### 方法2：

在网络设备上直接做流量转发**，将指定终端设备上发往80/443端口的数据直接转到代理服务器的目标端口上。优点是手机端不需要安装任何软件和特别设置。缺点是**需要一个单独的支持混杂模式的USB无线网卡**。详细见http://www.itawp.com/185.html

#### 方法3：

```
且APP无感知 https://blog.seeflower.dev/archives/207/；
```


#### 方法4：

- 当然直接使用iptables太麻烦了，直接使用现存的基于iptable的软件更方便：[ProxyDroid](https://www.yuque.com/m1tang/itccm5/byyyox)可以参考。ProxyDroid全局代理工具就是通过iptables实现的，所以使用ProxyDroid开启代理，可以比较有效的绕过代理检测。 再来一个[参考连接](https://www.cnblogs.com/lulianqi/p/11380794.html#_label2)

#### 方法5：

+ 控制DNS解析，通过修改dns的方式让客户端以为我们的代理服务器就是		                    			  	 			目标服务器。

```
优势：操作方便，通过修改设备的hosts可以十分方便的首先
```


```
劣势：需要为每个需要操作的域名提前添加host
```


```
在手机等手持设备上难以修改hosts（即对移动APP这类应用很难实现）
```


若使用方法2，使用iptables来实现透明代理 ，我们会将Kali Linux配置成一台代理型路由器，连接至这台“路由器”的客户端（例如嵌入式设备和手机App）都可以正常进行网络通信，但是其中的某些数据包将会被我们的Kali Linux设备所拦截并重定向至代理服务器。 Kali Linux设备以及BurpSuite、Mitmproxy、Fiddler(需要额外一些设置)都将以透明代理的形式运行，客户端不会感受到它们的存在。整个运行架构如下图所示：

![透明代理抓包拓扑图](/assets/image/2024-08-07-Android网络/06054150400.png)

### 几种代理方法

#### **Shadowsocks:**

- **概述：** Shadowsocks是一个开源的代理工具，旨在提供一个安全、私密的通信渠道。它通过混淆和加密数据流量，使其难以被识别和干扰。
- **工作原理：** 用户在本地计算机上运行Shadowsocks客户端，连接到一个远程服务器上运行的Shadowsocks服务端。用户的数据经过本地加密，然后通过安全的通道发送到服务器，服务器解密并将请求发送到目标网站。这样，整个通信过程都是加密的。
- **加密：** Shadowsocks使用一种称为"**socks5"的协议**来进行通信，同时还使用**AES加密算法**来加密数据流。

#### **SSH (Secure Shell):**

- **概述：** SSH是一种加密的网络协议，用于通过不安全的网络（例如互联网）安全地连接到远程计算机。虽然SSH最初是为远程命令行访问设计的，但它也可以用作加密的隧道，用于安全传输其他协议的数据。
- **工作原理：** SSH客户端与SSH服务器建立安全连接后，所有的通信都会被加密。SSH还支持端口转发，可以创建本地和远程端口的隧道，使得数据可以通过加密通道传输。
- **用途：** SSH经常被**用作加密隧道**，**以便在不安全的网络上安全地传输其他协议，如FTP、VNC等**。

#### **SOCKS5:**

- **概述：** SOCKS是一个网络协议，定义了一个代理服务器和客户端之间通信的标准。SOCKS5是其第五个版本，它可以处理各种不同的网络协议，例如 TCP/IP、UDP、HTTP 等等。SOCKS5 协议的主要作用是充当客户端和服务器之间的中间人，从而提供流量管理和安全保护。
- **工作原理：** SOCKS5代理服务器充当中间人，将客户端的请求转发到目标服务器，并将响应返回给客户端。与其他代理协议不同，SOCKS5可以用于任何网络协议和任何应用程序。根据[OSI模型](https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B)，SOCKS是[会话层](https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82)的协议，位于[表示层](https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%B1%82)与[传输层](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82)之间
- 与常规http代理对比：SOCKS使用握手协议来通知代理软件其客户端试图进行的连接SOCKS，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头
- 工作流程：https://wiyi.org/socks5-protocol-in-deep.html

  ![](/assets/image/2024-08-07-Android网络/client-socks5_f.jpg)

  首先协商阶段双方**协商认证方法**，紧接着是**认证阶段**（图上没标），socks5服务器可以决定是否需要认证，此时客户端会给代理发送用户名和密码，如果不需要认证，那么认证阶段会被直接略过。  socks5服务器**收到请求**后，解析内容。如果是UDP请求，服务器直接转发; 如果是TCP请求，服务器向目标服务器建立TCP连接，后续负责把客户端的所有数据转发到目标服务
- **特点：** SOCKS5支持更多的协议和应用，因为它是一个通用的代理协议。

#### **HTTP CONNECT隧道:**

- **概述：** HTTP CONNECT是一种HTTP协议的方法，允许客户端通过代理服务器与目标服务器建立直接的TCP连接，创建一个隧道。这通常用于实现HTTP代理服务器上的SSL/TLS隧道，当你在手机的WiFi设置中配置了代理，很可能是配置的HTTP代理。
- **工作原理：** 当客户端请求通过HTTP CONNECT方法与代理服务器通信时，代理服务器将在目标服务器和客户端之间建立一个无干扰的隧道。这允许客户端通过代理服务器直接连接到目标服务器，而无需解析HTTP报文。
- 过程：
  - **客户端请求建立隧道连接：** 客户端向代理服务器发送HTTP CONNECT请求，请求与目标服务器建立连接。这个请求中包含目标服务器的地址和端口信息。
  - **代理服务器建立连接：** 代理服务器接收到客户端的HTTP CONNECT请求后，它会尝试与目标服务器建立直接的TCP连接。
  - **建立通信隧道：** 代理服务器与目标服务器之间建立成功后，代理服务器向客户端发送一个HTTP 200 OK响应，表示连接已建立。从此时起，客户端和目标服务器之间就直接建立了通信隧道，代理服务器不会解析或修改通过该隧道传输的数据。
  - **直接通信：** 接下来，客户端可以通过该隧道向目标服务器发送数据，这些数据会经过代理服务器直接传输到目标服务器，同样，目标服务器的响应也会通过代理服务器回传给客户端。
  - **通信关闭：** 当客户端或目标服务器关闭连接时，通信隧道也相应关闭。
- **用途：** HTTP CONNECT隧道通常用于实现SSL/TLS隧道，允许客户端通过代理服务器访问加密的连接，例如HTTPS。

#### 虚拟私人网络（VPN）

虚拟私人网络（VPN）和代理服务器（如HTTP代理、SOCKS代理、Shadowsocks等）都是用于保护用户隐私和提供安全、匿名网络访问的工具，但它们之间有一些关键的区别：[参考连接](https://itimetraveler.github.io/2019/07/25/%E3%80%90Android%E3%80%91%E4%BD%BF%E7%94%A8VPN%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/)

1. **加密级别：**

   - **VPN：** 提供端到端的加密，通常使用强大的加密算法来保护整个网络连接。这意味着在连接到VPN时，所有的网络流量都经过加密，包括访问的网站和使用的应用程序。
   - **代理：** 通常只加密代理服务器和用户之间的通信，而不一定对整个连接进行加密。部分代理可能仅对特定协议进行加密，如HTTP代理只对HTTP通信进行加密。
2. **应用范围：**

   - **VPN：** 作用于整个网络连接，将所有流量都通过一个加密的通道传输。这包括访问互联网、本地网络资源等。
   - **代理：** 通常只代理特定的应用程序或协议，如HTTP代理只处理HTTP流量，SOCKS代理可能处理更多类型的流量，但仍然是特定的。
3. **配置和使用：**

   - **VPN：** 通常需要在操作系统或设备的网络设置中配置。一旦配置完成，整个设备的流量都通过VPN连接。
   - **代理：** 可以在应用程序或系统级别进行配置。有些应用程序可以配置代理，也可以通过系统网络设置配置代理，但通常代理只代理设置了代理的应用程序的流量。
4. **匿名性：**

   - **VPN：** 提供较高级别的匿名性，因为所有的流量都通过一个加密通道传输，隐藏了用户的真实IP地址。
   - **代理：** 提供一定程度的匿名性，但通常只是隐藏了用户的IP地址，而不一定提供端到端的加密。
5. **适用场景：**

   - **VPN：** 更适合需要全局网络隐私和安全的场景，如保护公共无线网络连接、绕过地理限制、加密通信等。
   - **代理：** 适合特定应用程序或协议的代理，如HTTP代理用于匿名浏览、SOCKS代理用于特定应用程序的隧道等。

