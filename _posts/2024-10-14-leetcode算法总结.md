---
title: leetcode算法总结
date: 2024-10-14 11:00:00 +0800
categories: [leetcode]
tags: [leetcode,java]
---





# 算法

## Leetcode

### 两数相加

![image-20241014155006509](https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-900e598daa2f303057c37494b8cc026a.png)

1、最简单的，利用两个`stack`，将两链表反转，再从各位相加即可，最后将结果进行反转；

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Deque<Integer> stack1 = new ArrayDeque<Integer>();
        Deque<Integer> stack2 = new ArrayDeque<Integer>();
        while (l1 != null) {
            stack1.push(l1.val);
            l1 = l1.next;
        }
        while (l2 != null) {
            stack2.push(l2.val);
            l2 = l2.next;
        }
        int carry = 0;
        ListNode ans = null;
        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {
            int a = stack1.isEmpty() ? 0 : stack1.pop();
            int b = stack2.isEmpty() ? 0 : stack2.pop();
            int cur = a + b + carry;
            carry = cur / 10;
            cur %= 10;
            ListNode curnode = new ListNode(cur);
            // 注意，这里是队列前插
            curnode.next = ans;
            ans = curnode;
        }
        return ans;
    }
}
```

### 只出现一次的数字

数组中除了唯一一个数字出现一次，其余数字都出现3次，找出这个唯一的数字；

1、使用HashMap<Integer,Integer>

2、利用二进制：将数字转化为二进制形式，我们一次每一次计算二进制的每一位，每一位的计算方法如下：

​		所有数字的这一比特位相加，结果 %3 就是唯一出现数字这个比特位上的数值；

```java
public int singleNumber(int[] nums){
    // 从个位开始
    int res = 0;
    for(int i = 0;i< 32;i++){
        int sum = 0;
        for(int num: nums){
            // sum 不断累加 num的 第 i 比特位
            sum + = ((num >> 1) & 1);
        }
        // 第i个比特为整除3，结果只有1或者0，为1则将结果的第i比特位置为1
        if(sum % 3){
            res |=  1 << i; 
        }
        
    }
}
```

3、单独看数字的某一bit位，其在相加过程中我们不断的%3，则其结果 总是0、1、2，一共三个状态，是不是觉得非常熟悉，我们可以使用逻辑电路中的知识：

​    （1）确定表示状态的bit位数，这里为2位

  （2）状态转移图

（3）画状态转移表

（4）从状态转移表抽取单独 Q0（n+1）与Q1（n+1）的转台转移表，即抽取出卡诺图

（5）圈卡诺图（向下看，想坐看，留下bit相同的（相同就是这个bit位在圈出部分只出现过1或0一种））

（6）得出表达式

在本题中得出表达式如下(**图中第二个少一个x非**)：

<img src="https://raw.githubusercontent.com/mikeaaaaaa/cloudimg/main/img/2024-10-cfd4eb56bf436b48b67ed86e3f4c4c5a.jpg" alt="66d20d1cde14ac178632cf063bba98f" style="zoom: 33%;" />

由于每一比特位都是这个表达式我们可以写程序如下：

```java
class Solution {
    public int singleNumber(int[] nums) {
        int q0=0,q1=0;
   for(int num : nums){
   	   int q00 = (~q1 & q0 & ~num) | (~q1 & ~q0 & num);
       int q11 = (q1 & ~q0 & ~num) | (~q1 & q0 & num);
       q0 = q00;
       q1 = q11;
   }
    return q0;
    }
}
```

### 最大单词长度乘积

给定一个单词列表，求列表中 任意两个不含有公共字母的长度乘积最大值：

1、两两单词比较，若不含相同字母，则计算乘积，选出最大的乘积

当然如何快速判断两个单词是否有相同字母成了难题；这里一般有两种选择：（1）直接创造出一种算法，使得两两计算很快 （2）先对每一个字符串处理，之后设计算法使得两两比较非常快 ，这里我们有两种使得计算加快的方法：每个单词维护一个set，之后两两set求交集判断是否为空，但是这样太浪费了，我们可以使用bit，因为我们发现 字母一共也就26个而且对于一个word来说，其每个字母的状态只有存在或不存在，正好可以使用0 1表示，因此我们使用一个 int类型的数字来代替 set；

```java
public int maxProduct(String[] words) {
    // 数字的length是属性，而String的length是方法；
		int[] masks = new int[words.length];
        for(int i = 0;i<words.length;i++){
			// 计算每个单词的mask
			String word = words[i];
			for(int j = 0;j<word.length();j++){
				masks[i] |= 1 << (word.charAt(j) - 'a');
			}
		}

		int res = 0;
		for(int i=0;i<words.length;i++){
			for (int j = i+1;j<words.length;j++){
				// 若不含相同字母
				if((masks[i] & masks[j]) == 0){
					res = Math.max(res, words[i].length() * words[j].length());
				}
			}
		}
		return res;
	}
```

2、既然提前计算了，那我们能不能再提前处理一下，进一步避免更多的计算呢，拥有相同mask的单词我们只需要保留一份即可，取单词最长的那一个的mask用于两两比较就行，因此使用一个HashMap<Integr,Integer>过滤一下就行； 之后两两比较的时候，取map.keySet()得到mask数组两两比较就行；

### 三数之和

在数组中找所有满足条件且不重复的三个数满足和为0；

1、暴力 + Set去重法

这里有个小点：就是List已经重写了hash方法，使用每个元素的hash方法来计算总的hash直，而Integer好像直接是用数字而不是地址，所以只要List相同，即使地址不同HashSet也能识别出来；

```java
public List<List<Integer>> threeSum(int[] nums) {
    if (nums == null || nums.length < 3)
        return new ArrayList<>();

    Set<List<Integer>> res = new HashSet<>();

    Arrays.sort(nums); // O(nlogn)

    // O(n^3)
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            for (int k = j + 1; k < nums.length; k++) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));
                }
            }
        }
    }

    return new ArrayList<>(res);
}
```

2、这个方法说起来简单，但是需要一个技巧：就是换一种理解方法，三数之和，如果我们固定一个数字的话，其实就变成了两数之和，这个我们是做过的，复杂度为O(n)；可以降低总复杂度为 O（n2）； **去重在这道题中也是一个小难点**

```java
public List<List<Integer>> threeSum(int[] nums){
		List<List<Integer>> res = new ArrayList<>();
		if(nums.length < 3){
			return res;
		}
		Arrays.sort(nums);
		for(int i = 0; i < nums.length-2; i++){
			if(nums[i] > 0){
				return res;
			}
			// 去重
			if(i > 0 && nums[i] == nums[i-1]){
				continue;
			}
			int low = i + 1;
			int high = nums.length - 1;

			while(low < high){
				int sum = nums[low] + nums[high];
				if(sum == -nums[i]){
					res.add(Arrays.asList(nums[i],nums[low],nums[high]));
					// 去重
					while (low < high && nums[low] == nums[++low]);
					while (low < high && nums[high] == nums[--high]);
				}else if(sum < -nums[i]){
					low += 1;
				}else{
					high-=1;
				}
			}
		}
		return res;
	}
```





## 左程云
